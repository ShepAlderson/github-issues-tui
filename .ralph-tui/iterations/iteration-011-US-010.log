# Iteration 11 Log

## Metadata

- **Task ID**: US-010
- **Task Title**: Last Synced Indicator
- **Description**: As a user, I want to know when my data was last updated so that I understand how current my offline data is
- **Status**: completed
- **Task Completed**: Yes
- **Promise Detected**: Yes
- **Started At**: 2026-01-21T23:19:09.272Z
- **Ended At**: 2026-01-21T23:23:09.821Z
- **Duration**: 4m 0s
- **Agent**: claude
- **Sandbox Mode**: auto
- **Sandbox Network**: Enabled
--- RAW OUTPUT ---
{"type":"system","subtype":"init","cwd":"/Users/shepbook/git/github-issues-tui","session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","tools":["Task","TaskOutput","Bash","Glob","Grep","ExitPlanMode","Read","Edit","Write","NotebookEdit","WebFetch","TodoWrite","WebSearch","KillShell","AskUserQuestion","Skill","EnterPlanMode","MCPSearch","mcp__context7__resolve-library-id","mcp__context7__query-docs","mcp__web-search__webSearchPrime","mcp__web-reader__webReader"],"mcp_servers":[{"name":"context7","status":"connected"},{"name":"web-search","status":"connected"},{"name":"web-reader","status":"connected"}],"model":"claude-opus-4-5-20251101","permissionMode":"bypassPermissions","slash_commands":["ralph-tui-create-beads","ralph-tui-prd","ralph-tui-create-json","phase-complete","conductor","commit-message","plan-complete","code-review:code-review","compact","context","cost","init","pr-comments","release-notes","review","security-review"],"apiKeySource":"none","claude_code_version":"2.1.12","output_style":"default","agents":["Bash","general-purpose","statusline-setup","Explore","Plan","implementation-subagent","review-subagent"],"skills":["ralph-tui-create-beads","ralph-tui-prd","ralph-tui-create-json"],"plugins":[{"name":"gopls-lsp","path":"/Users/shepbook/.claude/plugins/cache/claude-plugins-official/gopls-lsp/1.0.0"},{"name":"code-review","path":"/Users/shepbook/.claude/plugins/cache/claude-plugins-official/code-review/e30768372b41"}],"uuid":"4d2ff570-6b9e-426e-9580-f6d09cdcc5e9"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EBQXxbPSNo4QgQUQ9fXaJD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QVXBS1DR2GHs5uxJWevebF","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7330,"cache_read_input_tokens":17623,"cache_creation":{"ephemeral_5m_input_tokens":7330,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"3e291bb0-fcf4-4223-aa8f-598c29cf8f77"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EBQXxbPSNo4QgQUQ9fXaJD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01GNZEdGTLFg2pjFLVazNNEe","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/internal/db/store.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7330,"cache_read_input_tokens":17623,"cache_creation":{"ephemeral_5m_input_tokens":7330,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"271ae298-8b3a-4621-b3c3-ff039ece237b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01EBQXxbPSNo4QgQUQ9fXaJD","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EWLjTHvNDfzy5GsV5baegD","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":3,"cache_creation_input_tokens":7330,"cache_read_input_tokens":17623,"cache_creation":{"ephemeral_5m_input_tokens":7330,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"f3272c9c-6488-4491-945b-5b20334be25f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QVXBS1DR2GHs5uxJWevebF","type":"tool_result","content":"     1→# Ralph Progress Log\n     2→\n     3→This file tracks progress across iterations. It's automatically updated\n     4→after each iteration and included in agent prompts for context.\n     5→\n     6→## Codebase Patterns (Study These First)\n     7→\n     8→### Project Structure\n     9→- `cmd/ghissues/main.go` - Main entry point, minimal - just calls `cmd.Execute()`\n    10→- `internal/config/` - Configuration types and TOML file handling\n    11→- `internal/setup/` - Interactive setup prompts using charmbracelet/huh\n    12→- `internal/cmd/` - Cobra CLI commands (root command and subcommands)\n    13→\n    14→### Configuration Pattern\n    15→- Config struct lives in `internal/config/config.go`\n    16→- Use `config.DefaultConfigPath()` to get `~/.config/ghissues/config.toml`\n    17→- Config saved with 0600 permissions for security (tokens may be stored)\n    18→- TOML format for human-readable configuration\n    19→\n    20→### CLI Command Pattern (Cobra)\n    21→- Root command created by `NewRootCmd()` function\n    22→- Subcommands added via `rootCmd.AddCommand()`\n    23→- For testable output, use `cmd.OutOrStdout()` not `fmt.Println()`\n    24→- Global state (like configPath, dbPath) exposed via getter/setter for testing\n    25→- Use `PersistentFlags()` for flags available to all subcommands (like --db)\n    26→- Use `PersistentPreRunE` to set global state from flags before RunE executes\n    27→\n    28→### Database Path Pattern\n    29→- `internal/db/path.go` - Database path resolution with precedence: flag -> config -> default\n    30→- Default database path is `.ghissues.db` in current working directory\n    31→- Config can override via `[database] path = \"...\"` in TOML\n    32→- `--db` flag takes highest precedence\n    33→- `EnsureDBPath()` creates parent directories and validates writability\n    34→- `IsPathWritable()` uses temp file creation to verify write access\n    35→\n    36→### Testing Pattern\n    37→- Tests use `t.TempDir()` for isolated file system tests\n    38→- Use `defer SetConfigPath(\"\")` to reset global state after tests\n    39→- Interactive prompts (huh) can't be tested directly - use `RunSetupWithValues()` for programmatic setup\n    40→- For external dependencies (gh CLI, APIs), use package-level function variables that can be replaced in tests\n    41→- Example: `var ghCLITokenFunc = getTokenFromGhCLI` allows mocking in tests\n    42→- Use `httptest.NewServer` to mock HTTP APIs in tests\n    43→- GitHub client has `SetBaseURL()` method for testing with mock servers\n    44→\n    45→### GitHub API Pattern\n    46→- `internal/github/client.go` - GraphQL API client for fetching issues and comments\n    47→- Use GraphQL for efficient fetching with automatic pagination\n    48→- `FetchIssues()` and `FetchIssueComments()` handle pagination automatically\n    49→- Progress callbacks allow real-time progress reporting\n    50→- Context cancellation support for graceful shutdown\n    51→\n    52→### Database Pattern\n    53→- `internal/db/store.go` - LibSQL/SQLite storage using `github.com/tursodatabase/go-libsql`\n    54→- Schema created on `NewStore()` - tables for issues, comments, metadata\n    55→- Store labels and assignees as JSON strings in issue table\n    56→- Use transactions for batch operations (`SaveIssues`, `SaveComments`)\n    57→- `defer func() { _ = tx.Rollback() }()` pattern for safe transaction cleanup\n    58→\n    59→### Sync Pattern\n    60→- `internal/sync/sync.go` - Orchestrates fetching and storing\n    61→- Progress callback reports phase (\"issues\" or \"comments\") and counts\n    62→- Fetches all issues first, then comments for issues that have them\n    63→- Updates `last_sync` metadata after successful sync\n    64→\n    65→### Authentication Pattern\n    66→- `internal/auth/auth.go` - Token retrieval with priority: env var -> config -> gh CLI\n    67→- `GetToken(cfg)` returns (token, source, error) - source indicates where token came from\n    68→- `ValidateToken(token)` validates against GitHub API with helpful error messages\n    69→- Sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) allow callers to check error types with `errors.Is()`\n    70→\n    71→### TUI Pattern\n    72→- `internal/tui/model.go` - Bubbletea Model for issue list view\n    73→- Model implements `tea.Model` interface: `Init()`, `Update()`, `View()`\n    74→- Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n    75→- `SetDisableTUI(true)` package-level variable allows bypassing TUI in tests\n    76→- Test TUI by calling `Update()` with `tea.KeyMsg` directly - no TTY needed\n    77→- View() can be tested by setting window size and checking output strings\n    78→\n    79→---\n    80→\n    81→## 2026-01-21 - US-001 First-Time Setup\n    82→- **What was implemented:**\n    83→  - Complete first-time setup flow with interactive prompts\n    84→  - Config package for TOML configuration file handling\n    85→  - Setup package with charmbracelet/huh for interactive forms\n    86→  - CLI commands using cobra (root and config subcommand)\n    87→  - Non-interactive setup via flags (--repo, --auth-method, --token)\n    88→\n    89→- **Files changed:**\n    90→  - `cmd/ghissues/main.go` - Main entry point\n    91→  - `go.mod`, `go.sum` - Module definition and dependencies\n    92→  - `internal/config/config.go` - Config types, load/save, validation\n    93→  - `internal/config/config_test.go` - Config tests\n    94→  - `internal/setup/setup.go` - Interactive and programmatic setup\n    95→  - `internal/setup/setup_test.go` - Setup tests\n    96→  - `internal/cmd/root.go` - Root and config CLI commands\n    97→  - `internal/cmd/root_test.go` - CLI tests\n    98→\n    99→- **Learnings:**\n   100→  - **Patterns discovered:**\n   101→    - Separating interactive setup (`RunInteractiveSetup`) from programmatic setup (`RunSetupWithValues`) enables testability\n   102→    - Use `cmd.OutOrStdout()` in cobra commands for testable output instead of `fmt.Println()`\n   103→    - Global package variables (configPath) need getter/setter functions for testing\n   104→  - **Gotchas encountered:**\n   105→    - `huh` forms require TTY and fail in test environments - provide programmatic alternative\n   106→    - When testing cobra subcommands, use `rootCmd.SetArgs([]string{\"subcommand\", \"--flag\", \"value\"})` then `rootCmd.Execute()` - not direct subcommand execution\n   107→    - `go mod tidy` may remove indirect dependencies needed by tests - run after adding test imports\n   108→\n   109→---\n   110→\n   111→## 2026-01-21 - US-002 GitHub Authentication\n   112→- **What was implemented:**\n   113→  - Auth package with `GetToken()` function supporting three authentication methods in priority order:\n   114→    1. GITHUB_TOKEN environment variable\n   115→    2. Config file token (when auth.method is \"token\")\n   116→    3. GitHub CLI (`gh auth token`)\n   117→  - `ValidateToken()` function that validates tokens against GitHub API\n   118→  - Clear, helpful error messages for authentication failures\n   119→  - TokenSource type to indicate where the token was retrieved from\n   120→\n   121→- **Files changed:**\n   122→  - `internal/auth/auth.go` - Token retrieval and validation logic\n   123→  - `internal/auth/auth_test.go` - Comprehensive tests with mocked gh CLI\n   124→\n   125→- **Learnings:**\n   126→  - **Patterns discovered:**\n   127→    - Use package-level function variables (`var ghCLITokenFunc = getTokenFromGhCLI`) to enable mocking external commands in tests\n   128→    - Return source information (TokenSource) alongside the token so callers know where auth came from\n   129→    - Use sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) with `fmt.Errorf(\"%w: ...\")` to allow `errors.Is()` checks\n   130→  - **Gotchas encountered:**\n   131→    - When the gh CLI is installed and authenticated on the dev machine, tests that expect \"no auth available\" will fail - must mock the gh CLI function\n   132→    - Use test helper functions (`mockGhCLI`, `mockGhCLIUnavailable`) that return cleanup functions for consistent test isolation\n   133→\n   134→---\n   135→\n   136→## 2026-01-21 - US-004 Database Storage Location\n   137→- **What was implemented:**\n   138→  - Database path configuration with three-level precedence: `--db` flag > config file > default\n   139→  - Default location is `.ghissues.db` in current working directory\n   140→  - `DatabaseConfig` struct added to config with TOML support\n   141→  - `internal/db/path.go` package for path resolution and validation\n   142→  - Parent directory creation when using custom paths\n   143→  - Clear error messages when paths are not writable\n   144→\n   145→- **Files changed:**\n   146→  - `internal/config/config.go` - Added `DatabaseConfig` struct to `Config`\n   147→  - `internal/config/config_test.go` - Tests for database config loading/saving\n   148→  - `internal/db/path.go` - New package for database path resolution\n   149→  - `internal/db/path_test.go` - Comprehensive tests for path resolution\n   150→  - `internal/cmd/root.go` - Added `--db` flag, `SetDBPath()`/`GetDBPath()` functions\n   151→  - `internal/cmd/root_test.go` - Tests for `--db` flag behavior and precedence\n   152→\n   153→- **Learnings:**\n   154→  - **Patterns discovered:**\n   155→    - Use `PersistentPreRunE` to set global state from flags before `RunE` executes\n   156→    - Use `PersistentFlags()` for flags that should be available to all subcommands\n   157→    - Test writability by attempting to create a temp file, not just checking permissions\n   158→  - **Gotchas encountered:**\n   159→    - `os.Getuid() == 0` check needed to skip writability tests when running as root\n   160→    - When testing path validation, use `/root/...` paths on Unix (generally unwritable)\n   161→    - Relative paths like `.ghissues.db` have parent dir `.` which requires special handling\n   162→\n   163→---\n   164→\n   165→## 2026-01-21 - US-003 Initial Issue Sync\n   166→- **What was implemented:**\n   167→  - GitHub GraphQL API client for fetching issues and comments with automatic pagination\n   168→  - LibSQL database store with schema for issues, comments, labels, assignees\n   169→  - Sync command (`ghissues sync`) with progress bar and Ctrl+C cancellation\n   170→  - Progress callback reporting during fetch operations\n   171→\n   172→- **Files changed:**\n   173→  - `internal/github/client.go` - GitHub GraphQL API client\n   174→  - `internal/github/client_test.go` - Tests with mock HTTP server\n   175→  - `internal/db/store.go` - Database store using libsql\n   176→  - `internal/db/store_test.go` - Database operation tests\n   177→  - `internal/sync/sync.go` - Sync orchestration logic\n   178→  - `internal/sync/sync_test.go` - Sync tests with mocked GitHub\n   179→  - `internal/cmd/sync.go` - CLI sync subcommand\n   180→  - `internal/cmd/sync_test.go` - CLI sync tests\n   181→  - `internal/cmd/root.go` - Added sync subcommand registration\n   182→  - `go.mod`, `go.sum` - Added libsql dependency\n   183→\n   184→- **Learnings:**\n   185→  - **Patterns discovered:**\n   186→    - LibSQL driver requires executing schema statements one at a time (not batched in single Exec)\n   187→    - Use `Client.SetBaseURL()` method to allow test injection of mock server URLs\n   188→    - Store complex data (labels, assignees) as JSON strings in SQLite for simplicity\n   189→    - Use `signal.Notify` with context cancellation for graceful Ctrl+C handling\n   190→  - **Gotchas encountered:**\n   191→    - LibSQL multi-statement Exec fails silently - split into individual statements\n   192→    - In tests with `httptest.NewServer`, need to check for context cancellation in handler\n   193→    - Transaction rollback return values should be explicitly ignored with `_ = tx.Rollback()`\n   194→    - When gh CLI is installed locally, tests expecting \"no auth\" may pass due to fallback auth\n   195→\n   196→---\n   197→\n   198→## 2026-01-21 - US-005 Issue List View\n   199→- **What was implemented:**\n   200→  - TUI package using charmbracelet/bubbletea for the issue list view\n   201→  - Configurable columns with defaults: number, title, author, date, comments\n   202→  - DisplayConfig struct added to config for storing column configuration\n   203→  - Vim keys (j/k) and arrow keys for navigation\n   204→  - Issue count shown in status bar\n   205→  - Selected issue highlighting\n   206→  - Empty state handling when no issues are synced\n   207→\n   208→- **Files changed:**\n   209→  - `internal/tui/model.go` - TUI model with bubbletea tea.Model implementation\n   210→  - `internal/tui/model_test.go` - Comprehensive tests for TUI navigation and rendering\n   211→  - `internal/config/config.go` - Added DisplayConfig struct, DefaultDisplayColumns(), ValidateDisplayColumn()\n   212→  - `internal/config/config_test.go` - Tests for display column configuration\n   213→  - `internal/cmd/root.go` - Integrated TUI startup, added SetDisableTUI() for testing\n   214→  - `internal/cmd/root_test.go` - Updated tests to use SetDisableTUI(true)\n   215→  - `go.mod`, `go.sum` - Added bubbletea and lipgloss as direct dependencies\n   216→\n   217→- **Learnings:**\n   218→  - **Patterns discovered:**\n   219→    - Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n   220→    - Test TUI models by calling Update() with tea.KeyMsg directly - no TTY needed\n   221→    - Use `SetDisableTUI(true)` pattern to skip TUI in tests (similar to other mock patterns)\n   222→    - Bubbletea Model.View() can be tested by setting window size and checking output strings\n   223→  - **Gotchas encountered:**\n   224→    - `tea.NewProgram().Run()` requires a TTY - tests fail with \"could not open a new TTY\"\n   225→    - Add package-level `disableTUI` variable with setter for testing to bypass TUI in tests\n   226→    - Remember to defer `SetDisableTUI(false)` to reset state after tests\n   227→\n   228→---\n   229→\n   230→## 2026-01-21 - US-006 Issue Sorting\n   231→- **What was implemented:**\n   232→  - Sorting functionality for the issue list view\n   233→  - Default sort: most recently updated first (updated date, descending)\n   234→  - Four sort options: updated date, created date, issue number, comment count\n   235→  - Keybindings: 's' cycles sort fields, 'S' (shift+s) toggles sort order\n   236→  - Status bar shows current sort field and direction with ↑/↓ indicators\n   237→  - Sort preference persisted to config file when changed\n   238→\n   239→- **Files changed:**\n   240→  - `internal/config/config.go` - Added SortField, SortOrder types, validation functions, and DisplayConfig fields\n   241→  - `internal/config/config_test.go` - Tests for sort configuration\n   242→  - `internal/tui/model.go` - Added sorting logic, keybindings, status bar display, NewModelWithSort()\n   243→  - `internal/tui/model_test.go` - Comprehensive tests for all sort options and keybindings\n   244→  - `internal/cmd/root.go` - Load sort prefs from config, save when changed\n   245→\n   246→- **Learnings:**\n   247→  - **Patterns discovered:**\n   248→    - Use `NewModelWithSort()` constructor variant to allow passing initial sort config from outside\n   249→    - Copy slice before sorting with `copy()` to avoid modifying original data\n   250→    - Use `sort.Slice()` with a comparison function that checks `sortOrder` to flip direction\n   251→    - Track state changes with a `sortChanged` bool to avoid unnecessary config saves\n   252→    - Return final model from `p.Run()` to extract state after TUI exits\n   253→  - **Gotchas encountered:**\n   254→    - When adding default sorting, existing tests that assumed original order will fail - must update to expect sorted order\n   255→    - Use `github.Issue.UpdatedAtTime()` / `CreatedAtTime()` helper methods to parse RFC3339 dates for comparison\n   256→    - Cursor should reset to 0 when sort changes to avoid confusing UX\n   257→\n   258→---\n   259→\n   260→## 2026-01-21 - US-007 Issue Detail View\n   261→- **What was implemented:**\n   262→  - Split-panel TUI layout with issue list on left and detail panel on right\n   263→  - Detail panel header shows: issue number, title, author, created/updated dates\n   264→  - Body rendered with glamour (charmbracelet markdown renderer)\n   265→  - Toggle between raw markdown and rendered view with 'm' key\n   266→  - Labels and assignees displayed when present\n   267→  - Scrollable detail panel with 'h' (up) and 'l' (down) keys\n   268→  - Enter key opens comments view (state tracking added)\n   269→  - Escape key exits comments view\n   270→\n   271→- **Files changed:**\n   272→  - `internal/tui/model.go` - Added detail panel rendering, new state fields, key handlers\n   273→  - `internal/tui/model_test.go` - Added comprehensive tests for detail view functionality\n   274→  - `go.mod`, `go.sum` - Added glamour dependency\n   275→\n   276→- **Learnings:**\n   277→  - **Patterns discovered:**\n   278→    - Use `glamour.NewTermRenderer()` with `WithAutoStyle()` and `WithWordWrap()` for terminal-aware markdown rendering\n   279→    - Use `lipgloss.Width()` to get visual width of strings with ANSI codes for proper padding\n   280→    - Store glamour renderer in Model struct to avoid recreating it on each render\n   281→    - Reset detail scroll offset when changing selected issue for better UX\n   282→  - **Gotchas encountered:**\n   283→    - When refactoring View() to use split panels, old column-based rendering methods become unused - clean them up\n   284→    - Glamour renderer width is set at creation time, not per-render - pass width to `WithWordWrap()` at initialization\n   285→    - Use `strings.TrimSpace()` on glamour output to remove trailing newlines\n   286→\n   287→---\n   288→## ✓ Iteration 7 - US-007: Issue Detail View\n   289→*2026-01-21T23:02:27.476Z (302s)*\n   290→\n   291→**Status:** Completed\n   292→\n   293→**Notes:**\n   294→ey toggles `rawMarkdown` boolean and `renderBody()` renders accordingly\\n- [x] **Labels and assignees displayed if present** - The detail panel conditionally shows labels and assignees when present\\n- [x] **Scrollable if content exceeds panel height** - The 'h' and 'l' keys scroll the detail panel, with `detailScrollY` tracking offset\\n- [x] **Enter on issue list opens dedicated comments view** - Enter key sets `inCommentsView = true`, Escape returns\\n\\nAll acceptance criteria are satisfied.\\n\\n\n   295→\n   296→---\n   297→\n   298→## 2026-01-21 - US-008 Comments View\n   299→- **What was implemented:**\n   300→  - Full-screen comments drill-down view that replaces the main interface\n   301→  - Issue title/number displayed as header in comments view\n   302→  - Comments displayed chronologically with author and date for each comment\n   303→  - Comment body with markdown rendering (reuses existing glamour renderer)\n   304→  - Toggle markdown rendering with 'm' key (shares state with detail panel)\n   305→  - Scrollable comment list with 'h' (scroll up) and 'l' (scroll down) keys\n   306→  - Esc or 'q' returns to issue list view\n   307→\n   308→- **Files changed:**\n   309→  - `internal/tui/model.go` - Added comments field, commentsScrollY, SetComments/GetComments/CommentsScrollOffset methods, renderCommentsView() function, updated View() and Update() to handle comments view\n   310→  - `internal/tui/model_test.go` - Added 15 new tests for comments view functionality\n   311→  - `go.mod`, `go.sum` - Updated dependencies (go mod tidy)\n   312→\n   313→- **Learnings:**\n   314→  - **Patterns discovered:**\n   315→    - Drill-down views can be implemented by checking state flag early in View() and returning different render function\n   316→    - Share state like `rawMarkdown` between views for consistent UX across detail panel and comments view\n   317→    - Use separate scroll offsets (`detailScrollY`, `commentsScrollY`) for independent scrolling contexts\n   318→    - When a key should behave differently based on context (like 'q' returning from comments vs quitting app), check state in Update() before processing\n   319→  - **Gotchas encountered:**\n   320→    - Go time format strings use specific reference date (2006-01-02 15:04:05) - using \"2024-01-02\" instead causes wrong date parsing\n   321→    - Need to reset scroll offset when entering comments view (`commentsScrollY = 0`) and when exiting\n   322→    - Disable navigation keys (j/k) when in comments view to prevent cursor changes while viewing comments\n   323→\n   324→---\n   325→## ✓ Iteration 8 - US-008: Comments View\n   326→*2026-01-21T23:07:06.878Z (278s)*\n   327→\n   328→**Status:** Completed\n   329→\n   330→**Notes:**\n   331→odies are rendered with glamour markdown\\n- **Markdown toggle** - Press 'm' to toggle between raw and rendered markdown\\n- **Scrollable list** - 'h' scrolls up, 'l' scrolls down through comments\\n- **Navigation back** - Esc or 'q' returns to the issue list view\\n\\n**Files changed:**\\n- `internal/tui/model.go` - Added comments state, scroll offset, rendering methods\\n- `internal/tui/model_test.go` - Added 15 comprehensive tests for comments view\\n- `go.mod`, `go.sum` - Updated via go mod tidy\\n\\n\n   332→\n   333→---\n   334→\n   335→## 2026-01-21 - US-009 Data Refresh\n   336→- **What was implemented:**\n   337→  - Manual refresh with 'r' or 'R' keybinding in TUI\n   338→  - Auto-refresh triggered on app launch via RefreshStartMsg sent after program starts\n   339→  - Progress indicator shown in status bar during refresh (\"Refreshing...\" or \"Refreshing issues: X/Y\")\n   340→  - Sync now removes closed/deleted issues from local database\n   341→  - Database methods GetAllIssueNumbers() and DeleteIssues() for tracking and removing closed issues\n   342→  - Cursor position maintained after refresh when possible (by remembering selected issue number)\n   343→  - Refresh disabled during comments view for better UX\n   344→\n   345→- **Files changed:**\n   346→  - `internal/tui/model.go` - Added refresh state (isRefreshing, refreshProgress, refreshError, refreshFunc), message types (RefreshProgressMsg, RefreshDoneMsg, RefreshErrorMsg, RefreshStartMsg), keybindings for 'r'/'R', status bar updates during refresh\n   347→  - `internal/tui/model_test.go` - Added 11 tests for refresh functionality\n   348→  - `internal/sync/sync.go` - Added logic to detect and remove closed/deleted issues\n   349→  - `internal/sync/sync_test.go` - Added 5 tests for incremental sync and deleted issue handling\n   350→  - `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\n   351→  - `internal/cmd/root.go` - Integrated refresh with TUI via createRefreshFunc(), auto-refresh on launch\n   352→\n   353→- **Learnings:**\n   354→  - **Patterns discovered:**\n   355→    - Bubbletea refresh pattern: Model stores refreshFunc (func() tea.Msg), keybinding triggers state change + returns refreshFunc as command\n   356→    - Use message types (RefreshDoneMsg, RefreshErrorMsg) to communicate async operation results back to model\n   357→    - Auto-refresh on launch: Start TUI first, then use goroutine to send RefreshStartMsg via p.Send()\n   358→    - Track existing issue numbers before sync, compare with fetched issues, delete the difference\n   359→    - Preserve cursor position across refresh by remembering selected issue number, then finding its new index after sort\n   360→  - **Gotchas encountered:**\n   361→    - refreshFunc must be set before TUI starts - can't access external dependencies from within tea.Cmd directly\n   362→    - Need SetRefreshFunc() method to allow injection of the refresh closure from root command\n   363→    - When checking if key was pressed, test for cmd != nil only if refreshFunc is set (tests need to set mock function)\n   364→    - p.Send() must be called after p.Run() starts - use goroutine to avoid race\n   365→\n   366→---\n   367→## ✓ Iteration 9 - US-009: Data Refresh\n   368→*2026-01-21T23:14:29.638Z (442s)*\n   369→\n   370→**Status:** Completed\n   371→\n   372→**Notes:**\n   373→ured.\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Added refresh state, message types, and keybindings\\n- `internal/tui/model_test.go` - Added 11 tests for refresh functionality\\n- `internal/sync/sync.go` - Added closed issue detection and removal logic\\n- `internal/sync/sync_test.go` - Added 5 tests for deleted issue handling\\n- `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\\n- `internal/cmd/root.go` - Integrated refresh with TUI, auto-refresh on launch\\n\\n\n   374→\n   375→---\n   376→\n   377→## 2026-01-21 - US-013 Error Handling\n   378→- **What was implemented:**\n   379→  - Two-tier error display system: minor errors in status bar, critical errors as modal\n   380→  - Minor errors (network timeout, rate limit) shown in red text in status bar with retry hint\n   381→  - Critical errors (invalid token, database corruption) shown as centered modal dialog\n   382→  - Modal requires acknowledgment (Enter, Escape, or 'q') before user can continue\n   383→  - Navigation and refresh blocked while error modal is shown\n   384→  - Actionable guidance displayed in modal when provided\n   385→  - CriticalErrorMsg message type for triggering modal errors from anywhere\n   386→\n   387→- **Files changed:**\n   388→  - `internal/tui/model.go` - Added CriticalErrorMsg type, error modal state fields, renderErrorModal(), wrapText(), modal key handling in Update(), error display in status bar\n   389→  - `internal/tui/model_test.go` - Added 12 tests for error handling: minor errors in status bar, critical errors as modal, modal acknowledgment, navigation blocking\n   390→\n   391→- **Learnings:**\n   392→  - **Patterns discovered:**\n   393→    - Use separate message types for minor vs critical errors (RefreshErrorMsg for minor, CriticalErrorMsg for modal)\n   394→    - Handle modal keys first in Update() before normal key handling to block actions while modal is shown\n   395→    - Use early return pattern `if m.showErrorModal { return m.renderErrorModal() }` at start of View() for modal overlay\n   396→    - Text wrapping helper function `wrapText()` useful for fitting content into modal width\n   397→    - Modal state requires multiple fields: showErrorModal (bool), errorModalTitle, errorModalMessage, errorModalGuidance\n   398→  - **Gotchas encountered:**\n   399→    - When blocking keys during modal, still allow Ctrl+C for emergency exit\n   400→    - 'q' should dismiss modal, not quit app (unlike normal behavior)\n   401→    - Modal centering calculation needs bounds checking for small terminal sizes\n   402→    - Error message in status bar should be truncated to fit terminal width\n   403→\n   404→---\n   405→## ✓ Iteration 10 - US-013: Error Handling\n   406→*2026-01-21T23:19:08.265Z (278s)*\n   407→\n   408→**Status:** Completed\n   409→\n   410→**Notes:**\n   411→asErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n   412→\n   413→---\n   414→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2b5662d7-0482-406a-883f-1aa1aeac808c","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md","content":"# Ralph Progress Log\n\nThis file tracks progress across iterations. It's automatically updated\nafter each iteration and included in agent prompts for context.\n\n## Codebase Patterns (Study These First)\n\n### Project Structure\n- `cmd/ghissues/main.go` - Main entry point, minimal - just calls `cmd.Execute()`\n- `internal/config/` - Configuration types and TOML file handling\n- `internal/setup/` - Interactive setup prompts using charmbracelet/huh\n- `internal/cmd/` - Cobra CLI commands (root command and subcommands)\n\n### Configuration Pattern\n- Config struct lives in `internal/config/config.go`\n- Use `config.DefaultConfigPath()` to get `~/.config/ghissues/config.toml`\n- Config saved with 0600 permissions for security (tokens may be stored)\n- TOML format for human-readable configuration\n\n### CLI Command Pattern (Cobra)\n- Root command created by `NewRootCmd()` function\n- Subcommands added via `rootCmd.AddCommand()`\n- For testable output, use `cmd.OutOrStdout()` not `fmt.Println()`\n- Global state (like configPath, dbPath) exposed via getter/setter for testing\n- Use `PersistentFlags()` for flags available to all subcommands (like --db)\n- Use `PersistentPreRunE` to set global state from flags before RunE executes\n\n### Database Path Pattern\n- `internal/db/path.go` - Database path resolution with precedence: flag -> config -> default\n- Default database path is `.ghissues.db` in current working directory\n- Config can override via `[database] path = \"...\"` in TOML\n- `--db` flag takes highest precedence\n- `EnsureDBPath()` creates parent directories and validates writability\n- `IsPathWritable()` uses temp file creation to verify write access\n\n### Testing Pattern\n- Tests use `t.TempDir()` for isolated file system tests\n- Use `defer SetConfigPath(\"\")` to reset global state after tests\n- Interactive prompts (huh) can't be tested directly - use `RunSetupWithValues()` for programmatic setup\n- For external dependencies (gh CLI, APIs), use package-level function variables that can be replaced in tests\n- Example: `var ghCLITokenFunc = getTokenFromGhCLI` allows mocking in tests\n- Use `httptest.NewServer` to mock HTTP APIs in tests\n- GitHub client has `SetBaseURL()` method for testing with mock servers\n\n### GitHub API Pattern\n- `internal/github/client.go` - GraphQL API client for fetching issues and comments\n- Use GraphQL for efficient fetching with automatic pagination\n- `FetchIssues()` and `FetchIssueComments()` handle pagination automatically\n- Progress callbacks allow real-time progress reporting\n- Context cancellation support for graceful shutdown\n\n### Database Pattern\n- `internal/db/store.go` - LibSQL/SQLite storage using `github.com/tursodatabase/go-libsql`\n- Schema created on `NewStore()` - tables for issues, comments, metadata\n- Store labels and assignees as JSON strings in issue table\n- Use transactions for batch operations (`SaveIssues`, `SaveComments`)\n- `defer func() { _ = tx.Rollback() }()` pattern for safe transaction cleanup\n\n### Sync Pattern\n- `internal/sync/sync.go` - Orchestrates fetching and storing\n- Progress callback reports phase (\"issues\" or \"comments\") and counts\n- Fetches all issues first, then comments for issues that have them\n- Updates `last_sync` metadata after successful sync\n\n### Authentication Pattern\n- `internal/auth/auth.go` - Token retrieval with priority: env var -> config -> gh CLI\n- `GetToken(cfg)` returns (token, source, error) - source indicates where token came from\n- `ValidateToken(token)` validates against GitHub API with helpful error messages\n- Sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) allow callers to check error types with `errors.Is()`\n\n### TUI Pattern\n- `internal/tui/model.go` - Bubbletea Model for issue list view\n- Model implements `tea.Model` interface: `Init()`, `Update()`, `View()`\n- Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n- `SetDisableTUI(true)` package-level variable allows bypassing TUI in tests\n- Test TUI by calling `Update()` with `tea.KeyMsg` directly - no TTY needed\n- View() can be tested by setting window size and checking output strings\n\n---\n\n## 2026-01-21 - US-001 First-Time Setup\n- **What was implemented:**\n  - Complete first-time setup flow with interactive prompts\n  - Config package for TOML configuration file handling\n  - Setup package with charmbracelet/huh for interactive forms\n  - CLI commands using cobra (root and config subcommand)\n  - Non-interactive setup via flags (--repo, --auth-method, --token)\n\n- **Files changed:**\n  - `cmd/ghissues/main.go` - Main entry point\n  - `go.mod`, `go.sum` - Module definition and dependencies\n  - `internal/config/config.go` - Config types, load/save, validation\n  - `internal/config/config_test.go` - Config tests\n  - `internal/setup/setup.go` - Interactive and programmatic setup\n  - `internal/setup/setup_test.go` - Setup tests\n  - `internal/cmd/root.go` - Root and config CLI commands\n  - `internal/cmd/root_test.go` - CLI tests\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Separating interactive setup (`RunInteractiveSetup`) from programmatic setup (`RunSetupWithValues`) enables testability\n    - Use `cmd.OutOrStdout()` in cobra commands for testable output instead of `fmt.Println()`\n    - Global package variables (configPath) need getter/setter functions for testing\n  - **Gotchas encountered:**\n    - `huh` forms require TTY and fail in test environments - provide programmatic alternative\n    - When testing cobra subcommands, use `rootCmd.SetArgs([]string{\"subcommand\", \"--flag\", \"value\"})` then `rootCmd.Execute()` - not direct subcommand execution\n    - `go mod tidy` may remove indirect dependencies needed by tests - run after adding test imports\n\n---\n\n## 2026-01-21 - US-002 GitHub Authentication\n- **What was implemented:**\n  - Auth package with `GetToken()` function supporting three authentication methods in priority order:\n    1. GITHUB_TOKEN environment variable\n    2. Config file token (when auth.method is \"token\")\n    3. GitHub CLI (`gh auth token`)\n  - `ValidateToken()` function that validates tokens against GitHub API\n  - Clear, helpful error messages for authentication failures\n  - TokenSource type to indicate where the token was retrieved from\n\n- **Files changed:**\n  - `internal/auth/auth.go` - Token retrieval and validation logic\n  - `internal/auth/auth_test.go` - Comprehensive tests with mocked gh CLI\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use package-level function variables (`var ghCLITokenFunc = getTokenFromGhCLI`) to enable mocking external commands in tests\n    - Return source information (TokenSource) alongside the token so callers know where auth came from\n    - Use sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) with `fmt.Errorf(\"%w: ...\")` to allow `errors.Is()` checks\n  - **Gotchas encountered:**\n    - When the gh CLI is installed and authenticated on the dev machine, tests that expect \"no auth available\" will fail - must mock the gh CLI function\n    - Use test helper functions (`mockGhCLI`, `mockGhCLIUnavailable`) that return cleanup functions for consistent test isolation\n\n---\n\n## 2026-01-21 - US-004 Database Storage Location\n- **What was implemented:**\n  - Database path configuration with three-level precedence: `--db` flag > config file > default\n  - Default location is `.ghissues.db` in current working directory\n  - `DatabaseConfig` struct added to config with TOML support\n  - `internal/db/path.go` package for path resolution and validation\n  - Parent directory creation when using custom paths\n  - Clear error messages when paths are not writable\n\n- **Files changed:**\n  - `internal/config/config.go` - Added `DatabaseConfig` struct to `Config`\n  - `internal/config/config_test.go` - Tests for database config loading/saving\n  - `internal/db/path.go` - New package for database path resolution\n  - `internal/db/path_test.go` - Comprehensive tests for path resolution\n  - `internal/cmd/root.go` - Added `--db` flag, `SetDBPath()`/`GetDBPath()` functions\n  - `internal/cmd/root_test.go` - Tests for `--db` flag behavior and precedence\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `PersistentPreRunE` to set global state from flags before `RunE` executes\n    - Use `PersistentFlags()` for flags that should be available to all subcommands\n    - Test writability by attempting to create a temp file, not just checking permissions\n  - **Gotchas encountered:**\n    - `os.Getuid() == 0` check needed to skip writability tests when running as root\n    - When testing path validation, use `/root/...` paths on Unix (generally unwritable)\n    - Relative paths like `.ghissues.db` have parent dir `.` which requires special handling\n\n---\n\n## 2026-01-21 - US-003 Initial Issue Sync\n- **What was implemented:**\n  - GitHub GraphQL API client for fetching issues and comments with automatic pagination\n  - LibSQL database store with schema for issues, comments, labels, assignees\n  - Sync command (`ghissues sync`) with progress bar and Ctrl+C cancellation\n  - Progress callback reporting during fetch operations\n\n- **Files changed:**\n  - `internal/github/client.go` - GitHub GraphQL API client\n  - `internal/github/client_test.go` - Tests with mock HTTP server\n  - `internal/db/store.go` - Database store using libsql\n  - `internal/db/store_test.go` - Database operation tests\n  - `internal/sync/sync.go` - Sync orchestration logic\n  - `internal/sync/sync_test.go` - Sync tests with mocked GitHub\n  - `internal/cmd/sync.go` - CLI sync subcommand\n  - `internal/cmd/sync_test.go` - CLI sync tests\n  - `internal/cmd/root.go` - Added sync subcommand registration\n  - `go.mod`, `go.sum` - Added libsql dependency\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - LibSQL driver requires executing schema statements one at a time (not batched in single Exec)\n    - Use `Client.SetBaseURL()` method to allow test injection of mock server URLs\n    - Store complex data (labels, assignees) as JSON strings in SQLite for simplicity\n    - Use `signal.Notify` with context cancellation for graceful Ctrl+C handling\n  - **Gotchas encountered:**\n    - LibSQL multi-statement Exec fails silently - split into individual statements\n    - In tests with `httptest.NewServer`, need to check for context cancellation in handler\n    - Transaction rollback return values should be explicitly ignored with `_ = tx.Rollback()`\n    - When gh CLI is installed locally, tests expecting \"no auth\" may pass due to fallback auth\n\n---\n\n## 2026-01-21 - US-005 Issue List View\n- **What was implemented:**\n  - TUI package using charmbracelet/bubbletea for the issue list view\n  - Configurable columns with defaults: number, title, author, date, comments\n  - DisplayConfig struct added to config for storing column configuration\n  - Vim keys (j/k) and arrow keys for navigation\n  - Issue count shown in status bar\n  - Selected issue highlighting\n  - Empty state handling when no issues are synced\n\n- **Files changed:**\n  - `internal/tui/model.go` - TUI model with bubbletea tea.Model implementation\n  - `internal/tui/model_test.go` - Comprehensive tests for TUI navigation and rendering\n  - `internal/config/config.go` - Added DisplayConfig struct, DefaultDisplayColumns(), ValidateDisplayColumn()\n  - `internal/config/config_test.go` - Tests for display column configuration\n  - `internal/cmd/root.go` - Integrated TUI startup, added SetDisableTUI() for testing\n  - `internal/cmd/root_test.go` - Updated tests to use SetDisableTUI(true)\n  - `go.mod`, `go.sum` - Added bubbletea and lipgloss as direct dependencies\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n    - Test TUI models by calling Update() with tea.KeyMsg directly - no TTY needed\n    - Use `SetDisableTUI(true)` pattern to skip TUI in tests (similar to other mock patterns)\n    - Bubbletea Model.View() can be tested by setting window size and checking output strings\n  - **Gotchas encountered:**\n    - `tea.NewProgram().Run()` requires a TTY - tests fail with \"could not open a new TTY\"\n    - Add package-level `disableTUI` variable with setter for testing to bypass TUI in tests\n    - Remember to defer `SetDisableTUI(false)` to reset state after tests\n\n---\n\n## 2026-01-21 - US-006 Issue Sorting\n- **What was implemented:**\n  - Sorting functionality for the issue list view\n  - Default sort: most recently updated first (updated date, descending)\n  - Four sort options: updated date, created date, issue number, comment count\n  - Keybindings: 's' cycles sort fields, 'S' (shift+s) toggles sort order\n  - Status bar shows current sort field and direction with ↑/↓ indicators\n  - Sort preference persisted to config file when changed\n\n- **Files changed:**\n  - `internal/config/config.go` - Added SortField, SortOrder types, validation functions, and DisplayConfig fields\n  - `internal/config/config_test.go` - Tests for sort configuration\n  - `internal/tui/model.go` - Added sorting logic, keybindings, status bar display, NewModelWithSort()\n  - `internal/tui/model_test.go` - Comprehensive tests for all sort options and keybindings\n  - `internal/cmd/root.go` - Load sort prefs from config, save when changed\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `NewModelWithSort()` constructor variant to allow passing initial sort config from outside\n    - Copy slice before sorting with `copy()` to avoid modifying original data\n    - Use `sort.Slice()` with a comparison function that checks `sortOrder` to flip direction\n    - Track state changes with a `sortChanged` bool to avoid unnecessary config saves\n    - Return final model from `p.Run()` to extract state after TUI exits\n  - **Gotchas encountered:**\n    - When adding default sorting, existing tests that assumed original order will fail - must update to expect sorted order\n    - Use `github.Issue.UpdatedAtTime()` / `CreatedAtTime()` helper methods to parse RFC3339 dates for comparison\n    - Cursor should reset to 0 when sort changes to avoid confusing UX\n\n---\n\n## 2026-01-21 - US-007 Issue Detail View\n- **What was implemented:**\n  - Split-panel TUI layout with issue list on left and detail panel on right\n  - Detail panel header shows: issue number, title, author, created/updated dates\n  - Body rendered with glamour (charmbracelet markdown renderer)\n  - Toggle between raw markdown and rendered view with 'm' key\n  - Labels and assignees displayed when present\n  - Scrollable detail panel with 'h' (up) and 'l' (down) keys\n  - Enter key opens comments view (state tracking added)\n  - Escape key exits comments view\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added detail panel rendering, new state fields, key handlers\n  - `internal/tui/model_test.go` - Added comprehensive tests for detail view functionality\n  - `go.mod`, `go.sum` - Added glamour dependency\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `glamour.NewTermRenderer()` with `WithAutoStyle()` and `WithWordWrap()` for terminal-aware markdown rendering\n    - Use `lipgloss.Width()` to get visual width of strings with ANSI codes for proper padding\n    - Store glamour renderer in Model struct to avoid recreating it on each render\n    - Reset detail scroll offset when changing selected issue for better UX\n  - **Gotchas encountered:**\n    - When refactoring View() to use split panels, old column-based rendering methods become unused - clean them up\n    - Glamour renderer width is set at creation time, not per-render - pass width to `WithWordWrap()` at initialization\n    - Use `strings.TrimSpace()` on glamour output to remove trailing newlines\n\n---\n## ✓ Iteration 7 - US-007: Issue Detail View\n*2026-01-21T23:02:27.476Z (302s)*\n\n**Status:** Completed\n\n**Notes:**\ney toggles `rawMarkdown` boolean and `renderBody()` renders accordingly\\n- [x] **Labels and assignees displayed if present** - The detail panel conditionally shows labels and assignees when present\\n- [x] **Scrollable if content exceeds panel height** - The 'h' and 'l' keys scroll the detail panel, with `detailScrollY` tracking offset\\n- [x] **Enter on issue list opens dedicated comments view** - Enter key sets `inCommentsView = true`, Escape returns\\n\\nAll acceptance criteria are satisfied.\\n\\n\n\n---\n\n## 2026-01-21 - US-008 Comments View\n- **What was implemented:**\n  - Full-screen comments drill-down view that replaces the main interface\n  - Issue title/number displayed as header in comments view\n  - Comments displayed chronologically with author and date for each comment\n  - Comment body with markdown rendering (reuses existing glamour renderer)\n  - Toggle markdown rendering with 'm' key (shares state with detail panel)\n  - Scrollable comment list with 'h' (scroll up) and 'l' (scroll down) keys\n  - Esc or 'q' returns to issue list view\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added comments field, commentsScrollY, SetComments/GetComments/CommentsScrollOffset methods, renderCommentsView() function, updated View() and Update() to handle comments view\n  - `internal/tui/model_test.go` - Added 15 new tests for comments view functionality\n  - `go.mod`, `go.sum` - Updated dependencies (go mod tidy)\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Drill-down views can be implemented by checking state flag early in View() and returning different render function\n    - Share state like `rawMarkdown` between views for consistent UX across detail panel and comments view\n    - Use separate scroll offsets (`detailScrollY`, `commentsScrollY`) for independent scrolling contexts\n    - When a key should behave differently based on context (like 'q' returning from comments vs quitting app), check state in Update() before processing\n  - **Gotchas encountered:**\n    - Go time format strings use specific reference date (2006-01-02 15:04:05) - using \"2024-01-02\" instead causes wrong date parsing\n    - Need to reset scroll offset when entering comments view (`commentsScrollY = 0`) and when exiting\n    - Disable navigation keys (j/k) when in comments view to prevent cursor changes while viewing comments\n\n---\n## ✓ Iteration 8 - US-008: Comments View\n*2026-01-21T23:07:06.878Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nodies are rendered with glamour markdown\\n- **Markdown toggle** - Press 'm' to toggle between raw and rendered markdown\\n- **Scrollable list** - 'h' scrolls up, 'l' scrolls down through comments\\n- **Navigation back** - Esc or 'q' returns to the issue list view\\n\\n**Files changed:**\\n- `internal/tui/model.go` - Added comments state, scroll offset, rendering methods\\n- `internal/tui/model_test.go` - Added 15 comprehensive tests for comments view\\n- `go.mod`, `go.sum` - Updated via go mod tidy\\n\\n\n\n---\n\n## 2026-01-21 - US-009 Data Refresh\n- **What was implemented:**\n  - Manual refresh with 'r' or 'R' keybinding in TUI\n  - Auto-refresh triggered on app launch via RefreshStartMsg sent after program starts\n  - Progress indicator shown in status bar during refresh (\"Refreshing...\" or \"Refreshing issues: X/Y\")\n  - Sync now removes closed/deleted issues from local database\n  - Database methods GetAllIssueNumbers() and DeleteIssues() for tracking and removing closed issues\n  - Cursor position maintained after refresh when possible (by remembering selected issue number)\n  - Refresh disabled during comments view for better UX\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added refresh state (isRefreshing, refreshProgress, refreshError, refreshFunc), message types (RefreshProgressMsg, RefreshDoneMsg, RefreshErrorMsg, RefreshStartMsg), keybindings for 'r'/'R', status bar updates during refresh\n  - `internal/tui/model_test.go` - Added 11 tests for refresh functionality\n  - `internal/sync/sync.go` - Added logic to detect and remove closed/deleted issues\n  - `internal/sync/sync_test.go` - Added 5 tests for incremental sync and deleted issue handling\n  - `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\n  - `internal/cmd/root.go` - Integrated refresh with TUI via createRefreshFunc(), auto-refresh on launch\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Bubbletea refresh pattern: Model stores refreshFunc (func() tea.Msg), keybinding triggers state change + returns refreshFunc as command\n    - Use message types (RefreshDoneMsg, RefreshErrorMsg) to communicate async operation results back to model\n    - Auto-refresh on launch: Start TUI first, then use goroutine to send RefreshStartMsg via p.Send()\n    - Track existing issue numbers before sync, compare with fetched issues, delete the difference\n    - Preserve cursor position across refresh by remembering selected issue number, then finding its new index after sort\n  - **Gotchas encountered:**\n    - refreshFunc must be set before TUI starts - can't access external dependencies from within tea.Cmd directly\n    - Need SetRefreshFunc() method to allow injection of the refresh closure from root command\n    - When checking if key was pressed, test for cmd != nil only if refreshFunc is set (tests need to set mock function)\n    - p.Send() must be called after p.Run() starts - use goroutine to avoid race\n\n---\n## ✓ Iteration 9 - US-009: Data Refresh\n*2026-01-21T23:14:29.638Z (442s)*\n\n**Status:** Completed\n\n**Notes:**\nured.\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Added refresh state, message types, and keybindings\\n- `internal/tui/model_test.go` - Added 11 tests for refresh functionality\\n- `internal/sync/sync.go` - Added closed issue detection and removal logic\\n- `internal/sync/sync_test.go` - Added 5 tests for deleted issue handling\\n- `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\\n- `internal/cmd/root.go` - Integrated refresh with TUI, auto-refresh on launch\\n\\n\n\n---\n\n## 2026-01-21 - US-013 Error Handling\n- **What was implemented:**\n  - Two-tier error display system: minor errors in status bar, critical errors as modal\n  - Minor errors (network timeout, rate limit) shown in red text in status bar with retry hint\n  - Critical errors (invalid token, database corruption) shown as centered modal dialog\n  - Modal requires acknowledgment (Enter, Escape, or 'q') before user can continue\n  - Navigation and refresh blocked while error modal is shown\n  - Actionable guidance displayed in modal when provided\n  - CriticalErrorMsg message type for triggering modal errors from anywhere\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added CriticalErrorMsg type, error modal state fields, renderErrorModal(), wrapText(), modal key handling in Update(), error display in status bar\n  - `internal/tui/model_test.go` - Added 12 tests for error handling: minor errors in status bar, critical errors as modal, modal acknowledgment, navigation blocking\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use separate message types for minor vs critical errors (RefreshErrorMsg for minor, CriticalErrorMsg for modal)\n    - Handle modal keys first in Update() before normal key handling to block actions while modal is shown\n    - Use early return pattern `if m.showErrorModal { return m.renderErrorModal() }` at start of View() for modal overlay\n    - Text wrapping helper function `wrapText()` useful for fitting content into modal width\n    - Modal state requires multiple fields: showErrorModal (bool), errorModalTitle, errorModalMessage, errorModalGuidance\n  - **Gotchas encountered:**\n    - When blocking keys during modal, still allow Ctrl+C for emergency exit\n    - 'q' should dismiss modal, not quit app (unlike normal behavior)\n    - Modal centering calculation needs bounds checking for small terminal sizes\n    - Error message in status bar should be truncated to fit terminal width\n\n---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---\n","numLines":414,"startLine":1,"totalLines":414}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01GNZEdGTLFg2pjFLVazNNEe","type":"tool_result","content":"     1→package db\n     2→\n     3→import (\n     4→\t\"context\"\n     5→\t\"database/sql\"\n     6→\t\"encoding/json\"\n     7→\t\"fmt\"\n     8→\t\"time\"\n     9→\n    10→\t\"github.com/shepbook/ghissues/internal/github\"\n    11→\t_ \"github.com/tursodatabase/go-libsql\"\n    12→)\n    13→\n    14→// Store provides database operations for issues\n    15→type Store struct {\n    16→\tdb *sql.DB\n    17→}\n    18→\n    19→// NewStore creates a new database store and initializes the schema\n    20→func NewStore(path string) (*Store, error) {\n    21→\tdb, err := sql.Open(\"libsql\", \"file:\"+path)\n    22→\tif err != nil {\n    23→\t\treturn nil, fmt.Errorf(\"failed to open database: %w\", err)\n    24→\t}\n    25→\n    26→\tstore := &Store{db: db}\n    27→\n    28→\tif err := store.initSchema(); err != nil {\n    29→\t\tdb.Close()\n    30→\t\treturn nil, fmt.Errorf(\"failed to initialize schema: %w\", err)\n    31→\t}\n    32→\n    33→\treturn store, nil\n    34→}\n    35→\n    36→// Close closes the database connection\n    37→func (s *Store) Close() error {\n    38→\treturn s.db.Close()\n    39→}\n    40→\n    41→func (s *Store) initSchema() error {\n    42→\tstatements := []string{\n    43→\t\t`CREATE TABLE IF NOT EXISTS issues (\n    44→\t\t\tnumber INTEGER PRIMARY KEY,\n    45→\t\t\ttitle TEXT NOT NULL,\n    46→\t\t\tbody TEXT,\n    47→\t\t\tauthor TEXT NOT NULL,\n    48→\t\t\tcreated_at TEXT NOT NULL,\n    49→\t\t\tupdated_at TEXT NOT NULL,\n    50→\t\t\tcomment_count INTEGER DEFAULT 0,\n    51→\t\t\tlabels TEXT,\n    52→\t\t\tassignees TEXT\n    53→\t\t)`,\n    54→\t\t`CREATE TABLE IF NOT EXISTS comments (\n    55→\t\t\tid TEXT PRIMARY KEY,\n    56→\t\t\tissue_number INTEGER NOT NULL,\n    57→\t\t\tbody TEXT,\n    58→\t\t\tauthor TEXT NOT NULL,\n    59→\t\t\tcreated_at TEXT NOT NULL,\n    60→\t\t\tFOREIGN KEY (issue_number) REFERENCES issues(number) ON DELETE CASCADE\n    61→\t\t)`,\n    62→\t\t`CREATE TABLE IF NOT EXISTS metadata (\n    63→\t\t\tkey TEXT PRIMARY KEY,\n    64→\t\t\tvalue TEXT\n    65→\t\t)`,\n    66→\t\t`CREATE INDEX IF NOT EXISTS idx_comments_issue ON comments(issue_number)`,\n    67→\t\t`CREATE INDEX IF NOT EXISTS idx_issues_updated ON issues(updated_at)`,\n    68→\t}\n    69→\n    70→\tfor _, stmt := range statements {\n    71→\t\tif _, err := s.db.Exec(stmt); err != nil {\n    72→\t\t\treturn fmt.Errorf(\"failed to execute schema statement: %w\", err)\n    73→\t\t}\n    74→\t}\n    75→\n    76→\treturn nil\n    77→}\n    78→\n    79→// SaveIssue saves or updates a single issue\n    80→func (s *Store) SaveIssue(ctx context.Context, issue *github.Issue) error {\n    81→\tlabelsJSON, err := json.Marshal(issue.Labels)\n    82→\tif err != nil {\n    83→\t\treturn fmt.Errorf(\"failed to marshal labels: %w\", err)\n    84→\t}\n    85→\n    86→\tassigneesJSON, err := json.Marshal(issue.Assignees)\n    87→\tif err != nil {\n    88→\t\treturn fmt.Errorf(\"failed to marshal assignees: %w\", err)\n    89→\t}\n    90→\n    91→\tquery := `\n    92→\tINSERT OR REPLACE INTO issues (number, title, body, author, created_at, updated_at, comment_count, labels, assignees)\n    93→\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n    94→\t`\n    95→\n    96→\t_, err = s.db.ExecContext(ctx, query,\n    97→\t\tissue.Number,\n    98→\t\tissue.Title,\n    99→\t\tissue.Body,\n   100→\t\tissue.Author.Login,\n   101→\t\tissue.CreatedAt,\n   102→\t\tissue.UpdatedAt,\n   103→\t\tissue.CommentCount,\n   104→\t\tstring(labelsJSON),\n   105→\t\tstring(assigneesJSON),\n   106→\t)\n   107→\n   108→\treturn err\n   109→}\n   110→\n   111→// SaveIssues saves multiple issues in a transaction\n   112→func (s *Store) SaveIssues(ctx context.Context, issues []github.Issue) error {\n   113→\ttx, err := s.db.BeginTx(ctx, nil)\n   114→\tif err != nil {\n   115→\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n   116→\t}\n   117→\tdefer func() { _ = tx.Rollback() }()\n   118→\n   119→\tstmt, err := tx.PrepareContext(ctx, `\n   120→\t\tINSERT OR REPLACE INTO issues (number, title, body, author, created_at, updated_at, comment_count, labels, assignees)\n   121→\t\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n   122→\t`)\n   123→\tif err != nil {\n   124→\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n   125→\t}\n   126→\tdefer stmt.Close()\n   127→\n   128→\tfor _, issue := range issues {\n   129→\t\tlabelsJSON, err := json.Marshal(issue.Labels)\n   130→\t\tif err != nil {\n   131→\t\t\treturn fmt.Errorf(\"failed to marshal labels: %w\", err)\n   132→\t\t}\n   133→\n   134→\t\tassigneesJSON, err := json.Marshal(issue.Assignees)\n   135→\t\tif err != nil {\n   136→\t\t\treturn fmt.Errorf(\"failed to marshal assignees: %w\", err)\n   137→\t\t}\n   138→\n   139→\t\t_, err = stmt.ExecContext(ctx,\n   140→\t\t\tissue.Number,\n   141→\t\t\tissue.Title,\n   142→\t\t\tissue.Body,\n   143→\t\t\tissue.Author.Login,\n   144→\t\t\tissue.CreatedAt,\n   145→\t\t\tissue.UpdatedAt,\n   146→\t\t\tissue.CommentCount,\n   147→\t\t\tstring(labelsJSON),\n   148→\t\t\tstring(assigneesJSON),\n   149→\t\t)\n   150→\t\tif err != nil {\n   151→\t\t\treturn fmt.Errorf(\"failed to save issue %d: %w\", issue.Number, err)\n   152→\t\t}\n   153→\t}\n   154→\n   155→\treturn tx.Commit()\n   156→}\n   157→\n   158→// GetIssue retrieves an issue by number\n   159→func (s *Store) GetIssue(ctx context.Context, number int) (*github.Issue, error) {\n   160→\tquery := `\n   161→\tSELECT number, title, body, author, created_at, updated_at, comment_count, labels, assignees\n   162→\tFROM issues WHERE number = ?\n   163→\t`\n   164→\n   165→\trow := s.db.QueryRowContext(ctx, query, number)\n   166→\treturn s.scanIssue(row)\n   167→}\n   168→\n   169→// GetAllIssues retrieves all issues\n   170→func (s *Store) GetAllIssues(ctx context.Context) ([]github.Issue, error) {\n   171→\tquery := `\n   172→\tSELECT number, title, body, author, created_at, updated_at, comment_count, labels, assignees\n   173→\tFROM issues ORDER BY updated_at DESC\n   174→\t`\n   175→\n   176→\trows, err := s.db.QueryContext(ctx, query)\n   177→\tif err != nil {\n   178→\t\treturn nil, err\n   179→\t}\n   180→\tdefer rows.Close()\n   181→\n   182→\tvar issues []github.Issue\n   183→\tfor rows.Next() {\n   184→\t\tissue, err := s.scanIssueRow(rows)\n   185→\t\tif err != nil {\n   186→\t\t\treturn nil, err\n   187→\t\t}\n   188→\t\tissues = append(issues, *issue)\n   189→\t}\n   190→\n   191→\treturn issues, rows.Err()\n   192→}\n   193→\n   194→func (s *Store) scanIssue(row *sql.Row) (*github.Issue, error) {\n   195→\tvar issue github.Issue\n   196→\tvar author string\n   197→\tvar labelsJSON, assigneesJSON string\n   198→\n   199→\terr := row.Scan(\n   200→\t\t&issue.Number,\n   201→\t\t&issue.Title,\n   202→\t\t&issue.Body,\n   203→\t\t&author,\n   204→\t\t&issue.CreatedAt,\n   205→\t\t&issue.UpdatedAt,\n   206→\t\t&issue.CommentCount,\n   207→\t\t&labelsJSON,\n   208→\t\t&assigneesJSON,\n   209→\t)\n   210→\n   211→\tif err == sql.ErrNoRows {\n   212→\t\treturn nil, nil\n   213→\t}\n   214→\tif err != nil {\n   215→\t\treturn nil, err\n   216→\t}\n   217→\n   218→\tissue.Author = github.User{Login: author}\n   219→\n   220→\tif labelsJSON != \"\" {\n   221→\t\tif err := json.Unmarshal([]byte(labelsJSON), &issue.Labels); err != nil {\n   222→\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal labels: %w\", err)\n   223→\t\t}\n   224→\t}\n   225→\n   226→\tif assigneesJSON != \"\" {\n   227→\t\tif err := json.Unmarshal([]byte(assigneesJSON), &issue.Assignees); err != nil {\n   228→\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal assignees: %w\", err)\n   229→\t\t}\n   230→\t}\n   231→\n   232→\treturn &issue, nil\n   233→}\n   234→\n   235→func (s *Store) scanIssueRow(rows *sql.Rows) (*github.Issue, error) {\n   236→\tvar issue github.Issue\n   237→\tvar author string\n   238→\tvar labelsJSON, assigneesJSON string\n   239→\n   240→\terr := rows.Scan(\n   241→\t\t&issue.Number,\n   242→\t\t&issue.Title,\n   243→\t\t&issue.Body,\n   244→\t\t&author,\n   245→\t\t&issue.CreatedAt,\n   246→\t\t&issue.UpdatedAt,\n   247→\t\t&issue.CommentCount,\n   248→\t\t&labelsJSON,\n   249→\t\t&assigneesJSON,\n   250→\t)\n   251→\tif err != nil {\n   252→\t\treturn nil, err\n   253→\t}\n   254→\n   255→\tissue.Author = github.User{Login: author}\n   256→\n   257→\tif labelsJSON != \"\" {\n   258→\t\tif err := json.Unmarshal([]byte(labelsJSON), &issue.Labels); err != nil {\n   259→\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal labels: %w\", err)\n   260→\t\t}\n   261→\t}\n   262→\n   263→\tif assigneesJSON != \"\" {\n   264→\t\tif err := json.Unmarshal([]byte(assigneesJSON), &issue.Assignees); err != nil {\n   265→\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal assignees: %w\", err)\n   266→\t\t}\n   267→\t}\n   268→\n   269→\treturn &issue, nil\n   270→}\n   271→\n   272→// SaveComments saves comments for an issue\n   273→func (s *Store) SaveComments(ctx context.Context, issueNumber int, comments []github.Comment) error {\n   274→\ttx, err := s.db.BeginTx(ctx, nil)\n   275→\tif err != nil {\n   276→\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n   277→\t}\n   278→\tdefer func() { _ = tx.Rollback() }()\n   279→\n   280→\t// Delete existing comments for this issue\n   281→\t_, err = tx.ExecContext(ctx, \"DELETE FROM comments WHERE issue_number = ?\", issueNumber)\n   282→\tif err != nil {\n   283→\t\treturn fmt.Errorf(\"failed to delete existing comments: %w\", err)\n   284→\t}\n   285→\n   286→\tstmt, err := tx.PrepareContext(ctx, `\n   287→\t\tINSERT INTO comments (id, issue_number, body, author, created_at)\n   288→\t\tVALUES (?, ?, ?, ?, ?)\n   289→\t`)\n   290→\tif err != nil {\n   291→\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n   292→\t}\n   293→\tdefer stmt.Close()\n   294→\n   295→\tfor _, comment := range comments {\n   296→\t\t_, err = stmt.ExecContext(ctx,\n   297→\t\t\tcomment.ID,\n   298→\t\t\tissueNumber,\n   299→\t\t\tcomment.Body,\n   300→\t\t\tcomment.Author.Login,\n   301→\t\t\tcomment.CreatedAt,\n   302→\t\t)\n   303→\t\tif err != nil {\n   304→\t\t\treturn fmt.Errorf(\"failed to save comment %s: %w\", comment.ID, err)\n   305→\t\t}\n   306→\t}\n   307→\n   308→\treturn tx.Commit()\n   309→}\n   310→\n   311→// GetComments retrieves comments for an issue\n   312→func (s *Store) GetComments(ctx context.Context, issueNumber int) ([]github.Comment, error) {\n   313→\tquery := `\n   314→\tSELECT id, body, author, created_at\n   315→\tFROM comments WHERE issue_number = ? ORDER BY created_at ASC\n   316→\t`\n   317→\n   318→\trows, err := s.db.QueryContext(ctx, query, issueNumber)\n   319→\tif err != nil {\n   320→\t\treturn nil, err\n   321→\t}\n   322→\tdefer rows.Close()\n   323→\n   324→\tvar comments []github.Comment\n   325→\tfor rows.Next() {\n   326→\t\tvar comment github.Comment\n   327→\t\tvar author string\n   328→\n   329→\t\terr := rows.Scan(&comment.ID, &comment.Body, &author, &comment.CreatedAt)\n   330→\t\tif err != nil {\n   331→\t\t\treturn nil, err\n   332→\t\t}\n   333→\n   334→\t\tcomment.Author = github.User{Login: author}\n   335→\t\tcomments = append(comments, comment)\n   336→\t}\n   337→\n   338→\treturn comments, rows.Err()\n   339→}\n   340→\n   341→// ClearIssues removes all issues and comments\n   342→func (s *Store) ClearIssues(ctx context.Context) error {\n   343→\t_, err := s.db.ExecContext(ctx, \"DELETE FROM comments\")\n   344→\tif err != nil {\n   345→\t\treturn err\n   346→\t}\n   347→\t_, err = s.db.ExecContext(ctx, \"DELETE FROM issues\")\n   348→\treturn err\n   349→}\n   350→\n   351→// GetLastSyncTime returns the last sync time, or zero time if never synced\n   352→func (s *Store) GetLastSyncTime(ctx context.Context) (time.Time, error) {\n   353→\tvar value string\n   354→\terr := s.db.QueryRowContext(ctx, \"SELECT value FROM metadata WHERE key = 'last_sync'\").Scan(&value)\n   355→\n   356→\tif err == sql.ErrNoRows {\n   357→\t\treturn time.Time{}, nil\n   358→\t}\n   359→\tif err != nil {\n   360→\t\treturn time.Time{}, err\n   361→\t}\n   362→\n   363→\treturn time.Parse(time.RFC3339, value)\n   364→}\n   365→\n   366→// SetLastSyncTime sets the last sync time\n   367→func (s *Store) SetLastSyncTime(ctx context.Context, t time.Time) error {\n   368→\t_, err := s.db.ExecContext(ctx,\n   369→\t\t\"INSERT OR REPLACE INTO metadata (key, value) VALUES ('last_sync', ?)\",\n   370→\t\tt.UTC().Format(time.RFC3339),\n   371→\t)\n   372→\treturn err\n   373→}\n   374→\n   375→// GetAllIssueNumbers returns all issue numbers currently in the database\n   376→func (s *Store) GetAllIssueNumbers(ctx context.Context) ([]int, error) {\n   377→\trows, err := s.db.QueryContext(ctx, \"SELECT number FROM issues\")\n   378→\tif err != nil {\n   379→\t\treturn nil, err\n   380→\t}\n   381→\tdefer rows.Close()\n   382→\n   383→\tvar numbers []int\n   384→\tfor rows.Next() {\n   385→\t\tvar num int\n   386→\t\tif err := rows.Scan(&num); err != nil {\n   387→\t\t\treturn nil, err\n   388→\t\t}\n   389→\t\tnumbers = append(numbers, num)\n   390→\t}\n   391→\n   392→\treturn numbers, rows.Err()\n   393→}\n   394→\n   395→// DeleteIssues removes issues by their numbers, along with their comments\n   396→func (s *Store) DeleteIssues(ctx context.Context, numbers []int) error {\n   397→\tif len(numbers) == 0 {\n   398→\t\treturn nil\n   399→\t}\n   400→\n   401→\ttx, err := s.db.BeginTx(ctx, nil)\n   402→\tif err != nil {\n   403→\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n   404→\t}\n   405→\tdefer func() { _ = tx.Rollback() }()\n   406→\n   407→\tfor _, num := range numbers {\n   408→\t\t// Delete comments first (foreign key)\n   409→\t\t_, err := tx.ExecContext(ctx, \"DELETE FROM comments WHERE issue_number = ?\", num)\n   410→\t\tif err != nil {\n   411→\t\t\treturn fmt.Errorf(\"failed to delete comments for issue %d: %w\", num, err)\n   412→\t\t}\n   413→\n   414→\t\t// Delete the issue\n   415→\t\t_, err = tx.ExecContext(ctx, \"DELETE FROM issues WHERE number = ?\", num)\n   416→\t\tif err != nil {\n   417→\t\t\treturn fmt.Errorf(\"failed to delete issue %d: %w\", num, err)\n   418→\t\t}\n   419→\t}\n   420→\n   421→\treturn tx.Commit()\n   422→}\n   423→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2baeece3-0ec4-44cf-8395-f156be913348","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/db/store.go","content":"package db\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t_ \"github.com/tursodatabase/go-libsql\"\n)\n\n// Store provides database operations for issues\ntype Store struct {\n\tdb *sql.DB\n}\n\n// NewStore creates a new database store and initializes the schema\nfunc NewStore(path string) (*Store, error) {\n\tdb, err := sql.Open(\"libsql\", \"file:\"+path)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open database: %w\", err)\n\t}\n\n\tstore := &Store{db: db}\n\n\tif err := store.initSchema(); err != nil {\n\t\tdb.Close()\n\t\treturn nil, fmt.Errorf(\"failed to initialize schema: %w\", err)\n\t}\n\n\treturn store, nil\n}\n\n// Close closes the database connection\nfunc (s *Store) Close() error {\n\treturn s.db.Close()\n}\n\nfunc (s *Store) initSchema() error {\n\tstatements := []string{\n\t\t`CREATE TABLE IF NOT EXISTS issues (\n\t\t\tnumber INTEGER PRIMARY KEY,\n\t\t\ttitle TEXT NOT NULL,\n\t\t\tbody TEXT,\n\t\t\tauthor TEXT NOT NULL,\n\t\t\tcreated_at TEXT NOT NULL,\n\t\t\tupdated_at TEXT NOT NULL,\n\t\t\tcomment_count INTEGER DEFAULT 0,\n\t\t\tlabels TEXT,\n\t\t\tassignees TEXT\n\t\t)`,\n\t\t`CREATE TABLE IF NOT EXISTS comments (\n\t\t\tid TEXT PRIMARY KEY,\n\t\t\tissue_number INTEGER NOT NULL,\n\t\t\tbody TEXT,\n\t\t\tauthor TEXT NOT NULL,\n\t\t\tcreated_at TEXT NOT NULL,\n\t\t\tFOREIGN KEY (issue_number) REFERENCES issues(number) ON DELETE CASCADE\n\t\t)`,\n\t\t`CREATE TABLE IF NOT EXISTS metadata (\n\t\t\tkey TEXT PRIMARY KEY,\n\t\t\tvalue TEXT\n\t\t)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_comments_issue ON comments(issue_number)`,\n\t\t`CREATE INDEX IF NOT EXISTS idx_issues_updated ON issues(updated_at)`,\n\t}\n\n\tfor _, stmt := range statements {\n\t\tif _, err := s.db.Exec(stmt); err != nil {\n\t\t\treturn fmt.Errorf(\"failed to execute schema statement: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// SaveIssue saves or updates a single issue\nfunc (s *Store) SaveIssue(ctx context.Context, issue *github.Issue) error {\n\tlabelsJSON, err := json.Marshal(issue.Labels)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal labels: %w\", err)\n\t}\n\n\tassigneesJSON, err := json.Marshal(issue.Assignees)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to marshal assignees: %w\", err)\n\t}\n\n\tquery := `\n\tINSERT OR REPLACE INTO issues (number, title, body, author, created_at, updated_at, comment_count, labels, assignees)\n\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`\n\n\t_, err = s.db.ExecContext(ctx, query,\n\t\tissue.Number,\n\t\tissue.Title,\n\t\tissue.Body,\n\t\tissue.Author.Login,\n\t\tissue.CreatedAt,\n\t\tissue.UpdatedAt,\n\t\tissue.CommentCount,\n\t\tstring(labelsJSON),\n\t\tstring(assigneesJSON),\n\t)\n\n\treturn err\n}\n\n// SaveIssues saves multiple issues in a transaction\nfunc (s *Store) SaveIssues(ctx context.Context, issues []github.Issue) error {\n\ttx, err := s.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer func() { _ = tx.Rollback() }()\n\n\tstmt, err := tx.PrepareContext(ctx, `\n\t\tINSERT OR REPLACE INTO issues (number, title, body, author, created_at, updated_at, comment_count, labels, assignees)\n\t\tVALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)\n\t`)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\tfor _, issue := range issues {\n\t\tlabelsJSON, err := json.Marshal(issue.Labels)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal labels: %w\", err)\n\t\t}\n\n\t\tassigneesJSON, err := json.Marshal(issue.Assignees)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to marshal assignees: %w\", err)\n\t\t}\n\n\t\t_, err = stmt.ExecContext(ctx,\n\t\t\tissue.Number,\n\t\t\tissue.Title,\n\t\t\tissue.Body,\n\t\t\tissue.Author.Login,\n\t\t\tissue.CreatedAt,\n\t\t\tissue.UpdatedAt,\n\t\t\tissue.CommentCount,\n\t\t\tstring(labelsJSON),\n\t\t\tstring(assigneesJSON),\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save issue %d: %w\", issue.Number, err)\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n\n// GetIssue retrieves an issue by number\nfunc (s *Store) GetIssue(ctx context.Context, number int) (*github.Issue, error) {\n\tquery := `\n\tSELECT number, title, body, author, created_at, updated_at, comment_count, labels, assignees\n\tFROM issues WHERE number = ?\n\t`\n\n\trow := s.db.QueryRowContext(ctx, query, number)\n\treturn s.scanIssue(row)\n}\n\n// GetAllIssues retrieves all issues\nfunc (s *Store) GetAllIssues(ctx context.Context) ([]github.Issue, error) {\n\tquery := `\n\tSELECT number, title, body, author, created_at, updated_at, comment_count, labels, assignees\n\tFROM issues ORDER BY updated_at DESC\n\t`\n\n\trows, err := s.db.QueryContext(ctx, query)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar issues []github.Issue\n\tfor rows.Next() {\n\t\tissue, err := s.scanIssueRow(rows)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tissues = append(issues, *issue)\n\t}\n\n\treturn issues, rows.Err()\n}\n\nfunc (s *Store) scanIssue(row *sql.Row) (*github.Issue, error) {\n\tvar issue github.Issue\n\tvar author string\n\tvar labelsJSON, assigneesJSON string\n\n\terr := row.Scan(\n\t\t&issue.Number,\n\t\t&issue.Title,\n\t\t&issue.Body,\n\t\t&author,\n\t\t&issue.CreatedAt,\n\t\t&issue.UpdatedAt,\n\t\t&issue.CommentCount,\n\t\t&labelsJSON,\n\t\t&assigneesJSON,\n\t)\n\n\tif err == sql.ErrNoRows {\n\t\treturn nil, nil\n\t}\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tissue.Author = github.User{Login: author}\n\n\tif labelsJSON != \"\" {\n\t\tif err := json.Unmarshal([]byte(labelsJSON), &issue.Labels); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal labels: %w\", err)\n\t\t}\n\t}\n\n\tif assigneesJSON != \"\" {\n\t\tif err := json.Unmarshal([]byte(assigneesJSON), &issue.Assignees); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal assignees: %w\", err)\n\t\t}\n\t}\n\n\treturn &issue, nil\n}\n\nfunc (s *Store) scanIssueRow(rows *sql.Rows) (*github.Issue, error) {\n\tvar issue github.Issue\n\tvar author string\n\tvar labelsJSON, assigneesJSON string\n\n\terr := rows.Scan(\n\t\t&issue.Number,\n\t\t&issue.Title,\n\t\t&issue.Body,\n\t\t&author,\n\t\t&issue.CreatedAt,\n\t\t&issue.UpdatedAt,\n\t\t&issue.CommentCount,\n\t\t&labelsJSON,\n\t\t&assigneesJSON,\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tissue.Author = github.User{Login: author}\n\n\tif labelsJSON != \"\" {\n\t\tif err := json.Unmarshal([]byte(labelsJSON), &issue.Labels); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal labels: %w\", err)\n\t\t}\n\t}\n\n\tif assigneesJSON != \"\" {\n\t\tif err := json.Unmarshal([]byte(assigneesJSON), &issue.Assignees); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to unmarshal assignees: %w\", err)\n\t\t}\n\t}\n\n\treturn &issue, nil\n}\n\n// SaveComments saves comments for an issue\nfunc (s *Store) SaveComments(ctx context.Context, issueNumber int, comments []github.Comment) error {\n\ttx, err := s.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer func() { _ = tx.Rollback() }()\n\n\t// Delete existing comments for this issue\n\t_, err = tx.ExecContext(ctx, \"DELETE FROM comments WHERE issue_number = ?\", issueNumber)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to delete existing comments: %w\", err)\n\t}\n\n\tstmt, err := tx.PrepareContext(ctx, `\n\t\tINSERT INTO comments (id, issue_number, body, author, created_at)\n\t\tVALUES (?, ?, ?, ?, ?)\n\t`)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to prepare statement: %w\", err)\n\t}\n\tdefer stmt.Close()\n\n\tfor _, comment := range comments {\n\t\t_, err = stmt.ExecContext(ctx,\n\t\t\tcomment.ID,\n\t\t\tissueNumber,\n\t\t\tcomment.Body,\n\t\t\tcomment.Author.Login,\n\t\t\tcomment.CreatedAt,\n\t\t)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to save comment %s: %w\", comment.ID, err)\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n\n// GetComments retrieves comments for an issue\nfunc (s *Store) GetComments(ctx context.Context, issueNumber int) ([]github.Comment, error) {\n\tquery := `\n\tSELECT id, body, author, created_at\n\tFROM comments WHERE issue_number = ? ORDER BY created_at ASC\n\t`\n\n\trows, err := s.db.QueryContext(ctx, query, issueNumber)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar comments []github.Comment\n\tfor rows.Next() {\n\t\tvar comment github.Comment\n\t\tvar author string\n\n\t\terr := rows.Scan(&comment.ID, &comment.Body, &author, &comment.CreatedAt)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tcomment.Author = github.User{Login: author}\n\t\tcomments = append(comments, comment)\n\t}\n\n\treturn comments, rows.Err()\n}\n\n// ClearIssues removes all issues and comments\nfunc (s *Store) ClearIssues(ctx context.Context) error {\n\t_, err := s.db.ExecContext(ctx, \"DELETE FROM comments\")\n\tif err != nil {\n\t\treturn err\n\t}\n\t_, err = s.db.ExecContext(ctx, \"DELETE FROM issues\")\n\treturn err\n}\n\n// GetLastSyncTime returns the last sync time, or zero time if never synced\nfunc (s *Store) GetLastSyncTime(ctx context.Context) (time.Time, error) {\n\tvar value string\n\terr := s.db.QueryRowContext(ctx, \"SELECT value FROM metadata WHERE key = 'last_sync'\").Scan(&value)\n\n\tif err == sql.ErrNoRows {\n\t\treturn time.Time{}, nil\n\t}\n\tif err != nil {\n\t\treturn time.Time{}, err\n\t}\n\n\treturn time.Parse(time.RFC3339, value)\n}\n\n// SetLastSyncTime sets the last sync time\nfunc (s *Store) SetLastSyncTime(ctx context.Context, t time.Time) error {\n\t_, err := s.db.ExecContext(ctx,\n\t\t\"INSERT OR REPLACE INTO metadata (key, value) VALUES ('last_sync', ?)\",\n\t\tt.UTC().Format(time.RFC3339),\n\t)\n\treturn err\n}\n\n// GetAllIssueNumbers returns all issue numbers currently in the database\nfunc (s *Store) GetAllIssueNumbers(ctx context.Context) ([]int, error) {\n\trows, err := s.db.QueryContext(ctx, \"SELECT number FROM issues\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar numbers []int\n\tfor rows.Next() {\n\t\tvar num int\n\t\tif err := rows.Scan(&num); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tnumbers = append(numbers, num)\n\t}\n\n\treturn numbers, rows.Err()\n}\n\n// DeleteIssues removes issues by their numbers, along with their comments\nfunc (s *Store) DeleteIssues(ctx context.Context, numbers []int) error {\n\tif len(numbers) == 0 {\n\t\treturn nil\n\t}\n\n\ttx, err := s.db.BeginTx(ctx, nil)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"failed to begin transaction: %w\", err)\n\t}\n\tdefer func() { _ = tx.Rollback() }()\n\n\tfor _, num := range numbers {\n\t\t// Delete comments first (foreign key)\n\t\t_, err := tx.ExecContext(ctx, \"DELETE FROM comments WHERE issue_number = ?\", num)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to delete comments for issue %d: %w\", num, err)\n\t\t}\n\n\t\t// Delete the issue\n\t\t_, err = tx.ExecContext(ctx, \"DELETE FROM issues WHERE number = ?\", num)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to delete issue %d: %w\", num, err)\n\t\t}\n\t}\n\n\treturn tx.Commit()\n}\n","numLines":423,"startLine":1,"totalLines":423}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EWLjTHvNDfzy5GsV5baegD","type":"tool_result","content":"     1→package tui\n     2→\n     3→import (\n     4→\t\"fmt\"\n     5→\t\"sort\"\n     6→\t\"strings\"\n     7→\t\"time\"\n     8→\n     9→\ttea \"github.com/charmbracelet/bubbletea\"\n    10→\t\"github.com/charmbracelet/glamour\"\n    11→\t\"github.com/charmbracelet/lipgloss\"\n    12→\t\"github.com/shepbook/ghissues/internal/config\"\n    13→\t\"github.com/shepbook/ghissues/internal/github\"\n    14→)\n    15→\n    16→// DefaultColumns returns the default columns to display\n    17→func DefaultColumns() []string {\n    18→\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n    19→}\n    20→\n    21→// RefreshProgress contains progress information during a refresh operation\n    22→type RefreshProgress struct {\n    23→\tPhase   string // \"issues\" or \"comments\"\n    24→\tCurrent int\n    25→\tTotal   int\n    26→}\n    27→\n    28→// RefreshProgressMsg is sent when refresh progress updates\n    29→type RefreshProgressMsg struct {\n    30→\tProgress RefreshProgress\n    31→}\n    32→\n    33→// RefreshDoneMsg is sent when refresh completes successfully\n    34→type RefreshDoneMsg struct {\n    35→\tIssues []github.Issue\n    36→}\n    37→\n    38→// RefreshErrorMsg is sent when refresh fails\n    39→type RefreshErrorMsg struct {\n    40→\tErr error\n    41→}\n    42→\n    43→// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\n    44→type RefreshStartMsg struct{}\n    45→\n    46→// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\n    47→type CriticalErrorMsg struct {\n    48→\tErr      error  // The underlying error\n    49→\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n    50→\tGuidance string // Optional actionable guidance for resolving the error\n    51→}\n    52→\n    53→// Model represents the TUI application state\n    54→type Model struct {\n    55→\tissues           []github.Issue\n    56→\tcomments         []github.Comment\n    57→\tcolumns          []string\n    58→\tcursor           int\n    59→\twidth            int\n    60→\theight           int\n    61→\tsortField        config.SortField\n    62→\tsortOrder        config.SortOrder\n    63→\tsortChanged      bool // Track if sort was changed during session\n    64→\trawMarkdown      bool // Toggle between raw and rendered markdown\n    65→\tdetailScrollY    int  // Scroll offset for detail panel\n    66→\tcommentsScrollY  int  // Scroll offset for comments view\n    67→\tinCommentsView   bool // Whether we're in the comments view\n    68→\tglamourRenderer  *glamour.TermRenderer\n    69→\n    70→\t// Refresh state\n    71→\tisRefreshing    bool            // Whether a refresh is in progress\n    72→\trefreshProgress RefreshProgress // Current refresh progress\n    73→\trefreshError    string          // Last refresh error message\n    74→\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n    75→\n    76→\t// Error modal state (for critical errors)\n    77→\tshowErrorModal    bool   // Whether the error modal is visible\n    78→\terrorModalTitle   string // Title of the error modal\n    79→\terrorModalMessage string // Error message to display\n    80→\terrorModalGuidance string // Optional actionable guidance\n    81→}\n    82→\n    83→// NewModel creates a new TUI model with the given issues and columns\n    84→// Uses default sort: most recently updated first (updated descending)\n    85→func NewModel(issues []github.Issue, columns []string) Model {\n    86→\tsortField, sortOrder := config.DefaultSortConfig()\n    87→\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n    88→}\n    89→\n    90→// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\n    91→func NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n    92→\tif columns == nil {\n    93→\t\tcolumns = DefaultColumns()\n    94→\t}\n    95→\tif sortField == \"\" {\n    96→\t\tsortField, _ = config.DefaultSortConfig()\n    97→\t}\n    98→\tif sortOrder == \"\" {\n    99→\t\t_, sortOrder = config.DefaultSortConfig()\n   100→\t}\n   101→\n   102→\t// Create a glamour renderer for markdown rendering\n   103→\trenderer, _ := glamour.NewTermRenderer(\n   104→\t\tglamour.WithAutoStyle(),\n   105→\t\tglamour.WithWordWrap(60),\n   106→\t)\n   107→\n   108→\tm := Model{\n   109→\t\tissues:          make([]github.Issue, len(issues)),\n   110→\t\tcolumns:         columns,\n   111→\t\tcursor:          0,\n   112→\t\tsortField:       sortField,\n   113→\t\tsortOrder:       sortOrder,\n   114→\t\tglamourRenderer: renderer,\n   115→\t}\n   116→\n   117→\t// Copy issues to avoid modifying the original slice\n   118→\tcopy(m.issues, issues)\n   119→\n   120→\t// Apply initial sort\n   121→\tm.sortIssues()\n   122→\n   123→\treturn m\n   124→}\n   125→\n   126→// Init initializes the model\n   127→func (m Model) Init() tea.Cmd {\n   128→\treturn nil\n   129→}\n   130→\n   131→// Update handles messages and updates the model\n   132→func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n   133→\tswitch msg := msg.(type) {\n   134→\tcase tea.KeyMsg:\n   135→\t\t// Handle error modal first - block most keys when modal is shown\n   136→\t\tif m.showErrorModal {\n   137→\t\t\tswitch {\n   138→\t\t\tcase msg.Type == tea.KeyCtrlC:\n   139→\t\t\t\treturn m, tea.Quit\n   140→\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n   141→\t\t\t\t// Dismiss the error modal\n   142→\t\t\t\tm.showErrorModal = false\n   143→\t\t\t\tm.errorModalTitle = \"\"\n   144→\t\t\t\tm.errorModalMessage = \"\"\n   145→\t\t\t\tm.errorModalGuidance = \"\"\n   146→\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n   147→\t\t\t\t// Dismiss modal with 'q' as well\n   148→\t\t\t\tm.showErrorModal = false\n   149→\t\t\t\tm.errorModalTitle = \"\"\n   150→\t\t\t\tm.errorModalMessage = \"\"\n   151→\t\t\t\tm.errorModalGuidance = \"\"\n   152→\t\t\t}\n   153→\t\t\t// Block all other keys while modal is shown\n   154→\t\t\treturn m, nil\n   155→\t\t}\n   156→\n   157→\t\tswitch {\n   158→\t\tcase msg.Type == tea.KeyCtrlC:\n   159→\t\t\treturn m, tea.Quit\n   160→\t\tcase msg.Type == tea.KeyEscape:\n   161→\t\t\t// Exit comments view if in it\n   162→\t\t\tif m.inCommentsView {\n   163→\t\t\t\tm.inCommentsView = false\n   164→\t\t\t\tm.commentsScrollY = 0\n   165→\t\t\t}\n   166→\t\tcase msg.Type == tea.KeyEnter:\n   167→\t\t\t// Open comments view for selected issue\n   168→\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n   169→\t\t\t\tm.inCommentsView = true\n   170→\t\t\t\tm.commentsScrollY = 0\n   171→\t\t\t}\n   172→\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n   173→\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n   174→\t\t\t\tm.cursor++\n   175→\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n   176→\t\t\t}\n   177→\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n   178→\t\t\tif !m.inCommentsView && m.cursor > 0 {\n   179→\t\t\t\tm.cursor--\n   180→\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n   181→\t\t\t}\n   182→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n   183→\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n   184→\t\t\tif m.inCommentsView {\n   185→\t\t\t\tm.inCommentsView = false\n   186→\t\t\t\tm.commentsScrollY = 0\n   187→\t\t\t} else {\n   188→\t\t\t\treturn m, tea.Quit\n   189→\t\t\t}\n   190→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n   191→\t\t\t// Cycle sort field (only in issue list view)\n   192→\t\t\tif !m.inCommentsView {\n   193→\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n   194→\t\t\t\tm.sortIssues()\n   195→\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n   196→\t\t\t\tm.sortChanged = true\n   197→\t\t\t}\n   198→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n   199→\t\t\t// Toggle sort order (only in issue list view)\n   200→\t\t\tif !m.inCommentsView {\n   201→\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n   202→\t\t\t\tm.sortIssues()\n   203→\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n   204→\t\t\t\tm.sortChanged = true\n   205→\t\t\t}\n   206→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n   207→\t\t\t// Toggle raw/rendered markdown\n   208→\t\t\tm.rawMarkdown = !m.rawMarkdown\n   209→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n   210→\t\t\t// Scroll down - either detail panel or comments view\n   211→\t\t\tif m.inCommentsView {\n   212→\t\t\t\tm.commentsScrollY++\n   213→\t\t\t} else {\n   214→\t\t\t\tm.detailScrollY++\n   215→\t\t\t}\n   216→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n   217→\t\t\t// Scroll up - either detail panel or comments view\n   218→\t\t\tif m.inCommentsView {\n   219→\t\t\t\tif m.commentsScrollY > 0 {\n   220→\t\t\t\t\tm.commentsScrollY--\n   221→\t\t\t\t}\n   222→\t\t\t} else {\n   223→\t\t\t\tif m.detailScrollY > 0 {\n   224→\t\t\t\t\tm.detailScrollY--\n   225→\t\t\t\t}\n   226→\t\t\t}\n   227→\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n   228→\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n   229→\t\t\tif !m.inCommentsView && !m.isRefreshing {\n   230→\t\t\t\tm.isRefreshing = true\n   231→\t\t\t\tm.refreshError = \"\" // Clear previous error\n   232→\t\t\t\tm.refreshProgress = RefreshProgress{}\n   233→\t\t\t\tif m.refreshFunc != nil {\n   234→\t\t\t\t\treturn m, m.refreshFunc\n   235→\t\t\t\t}\n   236→\t\t\t\treturn m, nil\n   237→\t\t\t}\n   238→\t\t}\n   239→\tcase tea.WindowSizeMsg:\n   240→\t\tm.width = msg.Width\n   241→\t\tm.height = msg.Height\n   242→\tcase RefreshProgressMsg:\n   243→\t\tm.refreshProgress = msg.Progress\n   244→\tcase RefreshDoneMsg:\n   245→\t\tm.isRefreshing = false\n   246→\t\tm.refreshProgress = RefreshProgress{}\n   247→\t\t// Remember the currently selected issue number\n   248→\t\tvar selectedNumber int\n   249→\t\tif m.cursor < len(m.issues) {\n   250→\t\t\tselectedNumber = m.issues[m.cursor].Number\n   251→\t\t}\n   252→\t\t// Update issues\n   253→\t\tm.issues = make([]github.Issue, len(msg.Issues))\n   254→\t\tcopy(m.issues, msg.Issues)\n   255→\t\tm.sortIssues()\n   256→\t\t// Try to restore cursor to the same issue\n   257→\t\tm.cursor = 0\n   258→\t\tfor i, issue := range m.issues {\n   259→\t\t\tif issue.Number == selectedNumber {\n   260→\t\t\t\tm.cursor = i\n   261→\t\t\t\tbreak\n   262→\t\t\t}\n   263→\t\t}\n   264→\tcase RefreshErrorMsg:\n   265→\t\tm.isRefreshing = false\n   266→\t\tm.refreshProgress = RefreshProgress{}\n   267→\t\tif msg.Err != nil {\n   268→\t\t\tm.refreshError = msg.Err.Error()\n   269→\t\t}\n   270→\tcase CriticalErrorMsg:\n   271→\t\t// Show error modal for critical errors\n   272→\t\tm.showErrorModal = true\n   273→\t\tm.errorModalTitle = msg.Title\n   274→\t\tif msg.Err != nil {\n   275→\t\t\tm.errorModalMessage = msg.Err.Error()\n   276→\t\t}\n   277→\t\tm.errorModalGuidance = msg.Guidance\n   278→\tcase RefreshStartMsg:\n   279→\t\t// Auto-refresh trigger from Init\n   280→\t\tif !m.isRefreshing {\n   281→\t\t\tm.isRefreshing = true\n   282→\t\t\tm.refreshError = \"\"\n   283→\t\t\tm.refreshProgress = RefreshProgress{}\n   284→\t\t\tif m.refreshFunc != nil {\n   285→\t\t\t\treturn m, m.refreshFunc\n   286→\t\t\t}\n   287→\t\t}\n   288→\t}\n   289→\treturn m, nil\n   290→}\n   291→\n   292→// View renders the TUI\n   293→func (m Model) View() string {\n   294→\tif m.width == 0 {\n   295→\t\treturn \"\"\n   296→\t}\n   297→\n   298→\t// If error modal is shown, render it over everything\n   299→\tif m.showErrorModal {\n   300→\t\treturn m.renderErrorModal()\n   301→\t}\n   302→\n   303→\t// If in comments view, render the drill-down view instead\n   304→\tif m.inCommentsView {\n   305→\t\treturn m.renderCommentsView()\n   306→\t}\n   307→\n   308→\tvar b strings.Builder\n   309→\n   310→\t// Styles\n   311→\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n   312→\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n   313→\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n   314→\n   315→\t// Title\n   316→\ttitle := titleStyle.Render(\"GitHub Issues\")\n   317→\tb.WriteString(title)\n   318→\tb.WriteString(\"\\n\\n\")\n   319→\n   320→\t// Handle empty state\n   321→\tif len(m.issues) == 0 {\n   322→\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n   323→\t} else {\n   324→\t\t// Calculate the panel widths (50/50 split, or use available space)\n   325→\t\tlistWidth := m.width / 2\n   326→\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n   327→\n   328→\t\t// Render issue list panel\n   329→\t\tlistPanel := m.renderIssueListPanel(listWidth)\n   330→\n   331→\t\t// Render detail panel\n   332→\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n   333→\n   334→\t\t// Combine panels side by side\n   335→\t\tlistLines := strings.Split(listPanel, \"\\n\")\n   336→\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n   337→\n   338→\t\t// Get the max lines to display\n   339→\t\tmaxLines := max(len(listLines), len(detailLines))\n   340→\t\tcontentHeight := m.height - 6 // Account for title, status\n   341→\t\tif contentHeight < 5 {\n   342→\t\t\tcontentHeight = 15\n   343→\t\t}\n   344→\t\tmaxLines = min(maxLines, contentHeight)\n   345→\n   346→\t\tfor i := 0; i < maxLines; i++ {\n   347→\t\t\tlistLine := \"\"\n   348→\t\t\tif i < len(listLines) {\n   349→\t\t\t\tlistLine = listLines[i]\n   350→\t\t\t}\n   351→\t\t\t// Pad list line to width\n   352→\t\t\tlistLine = padToWidth(listLine, listWidth)\n   353→\n   354→\t\t\tdetailLine := \"\"\n   355→\t\t\tif i < len(detailLines) {\n   356→\t\t\t\tdetailLine = detailLines[i]\n   357→\t\t\t}\n   358→\n   359→\t\t\tb.WriteString(listLine)\n   360→\t\t\tb.WriteString(\" │ \")\n   361→\t\t\tb.WriteString(detailLine)\n   362→\t\t\tb.WriteString(\"\\n\")\n   363→\t\t}\n   364→\t}\n   365→\n   366→\t// Status bar\n   367→\tb.WriteString(\"\\n\")\n   368→\tsortIndicator := \"↓\"\n   369→\tif m.sortOrder == config.SortAsc {\n   370→\t\tsortIndicator = \"↑\"\n   371→\t}\n   372→\n   373→\t// Build status line with refresh indicator or error\n   374→\tvar status string\n   375→\tif m.isRefreshing {\n   376→\t\tif m.refreshProgress.Total > 0 {\n   377→\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n   378→\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n   379→\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n   380→\t\t} else {\n   381→\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n   382→\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n   383→\t\t}\n   384→\t\tb.WriteString(statusStyle.Render(status))\n   385→\t} else if m.refreshError != \"\" {\n   386→\t\t// Show minor error in status bar with retry hint\n   387→\t\terrMsg := m.refreshError\n   388→\t\t// Truncate if too long for status bar\n   389→\t\tmaxErrLen := m.width - 30\n   390→\t\tif maxErrLen < 20 {\n   391→\t\t\tmaxErrLen = 40\n   392→\t\t}\n   393→\t\tif len(errMsg) > maxErrLen {\n   394→\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n   395→\t\t}\n   396→\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n   397→\t\tb.WriteString(errorStyle.Render(status))\n   398→\t} else {\n   399→\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n   400→\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n   401→\t\tb.WriteString(statusStyle.Render(status))\n   402→\t}\n   403→\n   404→\treturn b.String()\n   405→}\n   406→\n   407→// renderIssueListPanel renders the left panel with the issue list\n   408→func (m Model) renderIssueListPanel(width int) string {\n   409→\tvar b strings.Builder\n   410→\n   411→\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n   412→\tnormalStyle := lipgloss.NewStyle()\n   413→\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n   414→\n   415→\t// Render header\n   416→\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n   417→\tb.WriteString(headerStyle.Render(header))\n   418→\tb.WriteString(\"\\n\")\n   419→\tb.WriteString(strings.Repeat(\"─\", width))\n   420→\tb.WriteString(\"\\n\")\n   421→\n   422→\t// Calculate visible height\n   423→\tvisibleHeight := m.height - 8\n   424→\tif visibleHeight < 1 {\n   425→\t\tvisibleHeight = 10\n   426→\t}\n   427→\n   428→\tstartIdx := 0\n   429→\tif m.cursor >= visibleHeight {\n   430→\t\tstartIdx = m.cursor - visibleHeight + 1\n   431→\t}\n   432→\n   433→\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n   434→\n   435→\tfor i := startIdx; i < endIdx; i++ {\n   436→\t\tissue := m.issues[i]\n   437→\t\ttitleWidth := width - 12\n   438→\t\ttitle := issue.Title\n   439→\t\tif len(title) > titleWidth {\n   440→\t\t\ttitle = title[:titleWidth-3] + \"...\"\n   441→\t\t}\n   442→\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n   443→\n   444→\t\tif i == m.cursor {\n   445→\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n   446→\t\t} else {\n   447→\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n   448→\t\t}\n   449→\t\tb.WriteString(\"\\n\")\n   450→\t}\n   451→\n   452→\treturn b.String()\n   453→}\n   454→\n   455→// renderDetailPanel renders the right panel with issue details\n   456→func (m Model) renderDetailPanel(width int) string {\n   457→\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n   458→\t\treturn \"No issue selected\"\n   459→\t}\n   460→\n   461→\tissue := m.issues[m.cursor]\n   462→\tvar b strings.Builder\n   463→\n   464→\t// Styles\n   465→\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n   466→\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n   467→\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n   468→\n   469→\t// Issue header: number and title\n   470→\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n   471→\tb.WriteString(\" \")\n   472→\ttitle := issue.Title\n   473→\tif len(title) > width-10 {\n   474→\t\ttitle = title[:width-13] + \"...\"\n   475→\t}\n   476→\tb.WriteString(headerStyle.Render(title))\n   477→\tb.WriteString(\"\\n\")\n   478→\n   479→\t// Author\n   480→\tb.WriteString(dimStyle.Render(\"Author: \"))\n   481→\tb.WriteString(issue.Author.Login)\n   482→\tb.WriteString(\"\\n\")\n   483→\n   484→\t// Dates\n   485→\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n   486→\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n   487→\tb.WriteString(dimStyle.Render(\"Created: \"))\n   488→\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n   489→\tb.WriteString(\"  \")\n   490→\tb.WriteString(dimStyle.Render(\"Updated: \"))\n   491→\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n   492→\tb.WriteString(\"\\n\")\n   493→\n   494→\t// Labels\n   495→\tif len(issue.Labels) > 0 {\n   496→\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n   497→\t\tvar labels []string\n   498→\t\tfor _, label := range issue.Labels {\n   499→\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n   500→\t\t}\n   501→\t\tb.WriteString(strings.Join(labels, \", \"))\n   502→\t\tb.WriteString(\"\\n\")\n   503→\t}\n   504→\n   505→\t// Assignees\n   506→\tif len(issue.Assignees) > 0 {\n   507→\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n   508→\t\tvar assignees []string\n   509→\t\tfor _, a := range issue.Assignees {\n   510→\t\t\tassignees = append(assignees, a.Login)\n   511→\t\t}\n   512→\t\tb.WriteString(strings.Join(assignees, \", \"))\n   513→\t\tb.WriteString(\"\\n\")\n   514→\t}\n   515→\n   516→\t// Separator\n   517→\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n   518→\tb.WriteString(\"\\n\")\n   519→\n   520→\t// Body\n   521→\tif issue.Body != \"\" {\n   522→\t\tbodyContent := m.renderBody(issue.Body)\n   523→\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n   524→\n   525→\t\t// Apply scroll offset\n   526→\t\tstartLine := m.detailScrollY\n   527→\t\tif startLine >= len(bodyLines) {\n   528→\t\t\tstartLine = max(0, len(bodyLines)-1)\n   529→\t\t}\n   530→\n   531→\t\t// Calculate visible body height\n   532→\t\tvisibleHeight := m.height - 15\n   533→\t\tif visibleHeight < 3 {\n   534→\t\t\tvisibleHeight = 5\n   535→\t\t}\n   536→\n   537→\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n   538→\t\tfor i := startLine; i < endLine; i++ {\n   539→\t\t\tb.WriteString(bodyLines[i])\n   540→\t\t\tb.WriteString(\"\\n\")\n   541→\t\t}\n   542→\t}\n   543→\n   544→\treturn b.String()\n   545→}\n   546→\n   547→// renderBody renders the issue body, either raw or with glamour\n   548→func (m Model) renderBody(body string) string {\n   549→\tif m.rawMarkdown {\n   550→\t\treturn body\n   551→\t}\n   552→\n   553→\t// Render markdown with glamour\n   554→\tif m.glamourRenderer != nil {\n   555→\t\trendered, err := m.glamourRenderer.Render(body)\n   556→\t\tif err == nil {\n   557→\t\t\treturn strings.TrimSpace(rendered)\n   558→\t\t}\n   559→\t}\n   560→\n   561→\t// Fallback to raw if rendering fails\n   562→\treturn body\n   563→}\n   564→\n   565→// renderCommentsView renders the full-screen comments drill-down view\n   566→func (m Model) renderCommentsView() string {\n   567→\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n   568→\t\treturn \"No issue selected\"\n   569→\t}\n   570→\n   571→\tissue := m.issues[m.cursor]\n   572→\tvar b strings.Builder\n   573→\n   574→\t// Styles\n   575→\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n   576→\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n   577→\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n   578→\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n   579→\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n   580→\n   581→\t// Title: Issue number and title\n   582→\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n   583→\tb.WriteString(\"\\n\")\n   584→\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n   585→\tb.WriteString(\"\\n\\n\")\n   586→\n   587→\t// Handle empty comments\n   588→\tif len(m.comments) == 0 {\n   589→\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n   590→\t\tb.WriteString(\"\\n\")\n   591→\t} else {\n   592→\t\t// Render comments\n   593→\t\tvar allCommentLines []string\n   594→\n   595→\t\tfor i, comment := range m.comments {\n   596→\t\t\t// Comment header: author and date\n   597→\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n   598→\t\t\theader := fmt.Sprintf(\"%s  %s\",\n   599→\t\t\t\tauthorStyle.Render(comment.Author.Login),\n   600→\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n   601→\t\t\tallCommentLines = append(allCommentLines, header)\n   602→\n   603→\t\t\t// Comment body\n   604→\t\t\tbodyContent := m.renderBody(comment.Body)\n   605→\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n   606→\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n   607→\n   608→\t\t\t// Add separator between comments (except after last one)\n   609→\t\t\tif i < len(m.comments)-1 {\n   610→\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n   611→\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n   612→\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n   613→\t\t\t}\n   614→\t\t}\n   615→\n   616→\t\t// Apply scroll offset\n   617→\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n   618→\t\tif visibleHeight < 5 {\n   619→\t\t\tvisibleHeight = 10\n   620→\t\t}\n   621→\n   622→\t\tstartLine := m.commentsScrollY\n   623→\t\tif startLine >= len(allCommentLines) {\n   624→\t\t\tstartLine = max(0, len(allCommentLines)-1)\n   625→\t\t}\n   626→\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n   627→\n   628→\t\tfor i := startLine; i < endLine; i++ {\n   629→\t\t\tb.WriteString(allCommentLines[i])\n   630→\t\t\tb.WriteString(\"\\n\")\n   631→\t\t}\n   632→\t}\n   633→\n   634→\t// Status bar\n   635→\tb.WriteString(\"\\n\")\n   636→\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n   637→\t\tlen(m.comments))\n   638→\tb.WriteString(statusStyle.Render(status))\n   639→\n   640→\treturn b.String()\n   641→}\n   642→\n   643→// renderErrorModal renders a modal dialog for critical errors\n   644→func (m Model) renderErrorModal() string {\n   645→\tvar b strings.Builder\n   646→\n   647→\t// Styles for the error modal\n   648→\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n   649→\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n   650→\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n   651→\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n   652→\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n   653→\n   654→\t// Calculate modal dimensions\n   655→\tmodalWidth := min(m.width-4, 70)\n   656→\tif modalWidth < 40 {\n   657→\t\tmodalWidth = 40\n   658→\t}\n   659→\n   660→\t// Calculate padding for centering\n   661→\tleftPadding := (m.width - modalWidth) / 2\n   662→\tif leftPadding < 0 {\n   663→\t\tleftPadding = 0\n   664→\t}\n   665→\tpad := strings.Repeat(\" \", leftPadding)\n   666→\n   667→\t// Top spacing for vertical centering\n   668→\ttopPadding := (m.height - 12) / 2\n   669→\tif topPadding < 2 {\n   670→\t\ttopPadding = 2\n   671→\t}\n   672→\tfor i := 0; i < topPadding; i++ {\n   673→\t\tb.WriteString(\"\\n\")\n   674→\t}\n   675→\n   676→\t// Top border\n   677→\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n   678→\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n   679→\n   680→\t// Title line\n   681→\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n   682→\n   683→\t// Separator line\n   684→\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n   685→\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n   686→\n   687→\t// Message - wrap to fit modal width\n   688→\tmsgWidth := modalWidth - 4\n   689→\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n   690→\tfor _, line := range msgLines {\n   691→\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n   692→\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n   693→\t}\n   694→\n   695→\t// Empty line before guidance\n   696→\temptyLine := strings.Repeat(\" \", modalWidth-2)\n   697→\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n   698→\n   699→\t// Guidance if present\n   700→\tif m.errorModalGuidance != \"\" {\n   701→\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n   702→\t\tfor _, line := range guidanceLines {\n   703→\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n   704→\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n   705→\t\t}\n   706→\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n   707→\t}\n   708→\n   709→\t// Instructions line\n   710→\tinstructions := \"Press Enter or Esc to dismiss\"\n   711→\tinstrPadLen := modalWidth - 4 - len(instructions)\n   712→\tif instrPadLen < 0 {\n   713→\t\tinstrPadLen = 0\n   714→\t}\n   715→\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n   716→\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n   717→\n   718→\t// Bottom border\n   719→\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n   720→\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n   721→\n   722→\treturn b.String()\n   723→}\n   724→\n   725→// wrapText wraps text to fit within a specified width\n   726→func wrapText(text string, width int) []string {\n   727→\tif width <= 0 {\n   728→\t\treturn []string{text}\n   729→\t}\n   730→\n   731→\tvar lines []string\n   732→\twords := strings.Fields(text)\n   733→\tif len(words) == 0 {\n   734→\t\treturn []string{}\n   735→\t}\n   736→\n   737→\tcurrentLine := words[0]\n   738→\tfor _, word := range words[1:] {\n   739→\t\tif len(currentLine)+1+len(word) <= width {\n   740→\t\t\tcurrentLine += \" \" + word\n   741→\t\t} else {\n   742→\t\t\tlines = append(lines, currentLine)\n   743→\t\t\tcurrentLine = word\n   744→\t\t}\n   745→\t}\n   746→\tlines = append(lines, currentLine)\n   747→\treturn lines\n   748→}\n   749→\n   750→// padToWidth pads a string to a specific width, accounting for ANSI codes\n   751→func padToWidth(s string, width int) string {\n   752→\t// Get visual width (lipgloss handles ANSI codes)\n   753→\tvisualWidth := lipgloss.Width(s)\n   754→\tif visualWidth >= width {\n   755→\t\treturn s\n   756→\t}\n   757→\treturn s + strings.Repeat(\" \", width-visualWidth)\n   758→}\n   759→\n   760→// SelectedIssue returns the currently selected issue, or nil if no issues\n   761→func (m Model) SelectedIssue() *github.Issue {\n   762→\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n   763→\t\treturn nil\n   764→\t}\n   765→\treturn &m.issues[m.cursor]\n   766→}\n   767→\n   768→// IssueCount returns the total number of issues\n   769→func (m Model) IssueCount() int {\n   770→\treturn len(m.issues)\n   771→}\n   772→\n   773→// SetWindowSize sets the terminal window size\n   774→func (m *Model) SetWindowSize(width, height int) {\n   775→\tm.width = width\n   776→\tm.height = height\n   777→}\n   778→\n   779→// GetSortConfig returns the current sort field and order\n   780→func (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n   781→\treturn m.sortField, m.sortOrder\n   782→}\n   783→\n   784→// SortChanged returns true if the sort settings were changed during the session\n   785→func (m Model) SortChanged() bool {\n   786→\treturn m.sortChanged\n   787→}\n   788→\n   789→// IsRawMarkdown returns whether the detail panel is showing raw markdown\n   790→func (m Model) IsRawMarkdown() bool {\n   791→\treturn m.rawMarkdown\n   792→}\n   793→\n   794→// DetailScrollOffset returns the current scroll offset for the detail panel\n   795→func (m Model) DetailScrollOffset() int {\n   796→\treturn m.detailScrollY\n   797→}\n   798→\n   799→// InCommentsView returns whether the comments view is active\n   800→func (m Model) InCommentsView() bool {\n   801→\treturn m.inCommentsView\n   802→}\n   803→\n   804→// SetComments sets the comments for the currently selected issue\n   805→func (m *Model) SetComments(comments []github.Comment) {\n   806→\tm.comments = comments\n   807→\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n   808→}\n   809→\n   810→// GetComments returns the current comments\n   811→func (m Model) GetComments() []github.Comment {\n   812→\treturn m.comments\n   813→}\n   814→\n   815→// CommentsScrollOffset returns the current scroll offset for the comments view\n   816→func (m Model) CommentsScrollOffset() int {\n   817→\treturn m.commentsScrollY\n   818→}\n   819→\n   820→// IsRefreshing returns whether a refresh is in progress\n   821→func (m Model) IsRefreshing() bool {\n   822→\treturn m.isRefreshing\n   823→}\n   824→\n   825→// GetRefreshProgress returns the current refresh progress\n   826→func (m Model) GetRefreshProgress() RefreshProgress {\n   827→\treturn m.refreshProgress\n   828→}\n   829→\n   830→// GetRefreshError returns the last refresh error message\n   831→func (m Model) GetRefreshError() string {\n   832→\treturn m.refreshError\n   833→}\n   834→\n   835→// SetRefreshFunc sets the function to be called when refresh is triggered\n   836→func (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n   837→\tm.refreshFunc = fn\n   838→}\n   839→\n   840→// HasErrorModal returns whether the error modal is visible\n   841→func (m Model) HasErrorModal() bool {\n   842→\treturn m.showErrorModal\n   843→}\n   844→\n   845→// GetErrorModalTitle returns the title of the error modal\n   846→func (m Model) GetErrorModalTitle() string {\n   847→\treturn m.errorModalTitle\n   848→}\n   849→\n   850→// GetErrorModalMessage returns the error message in the modal\n   851→func (m Model) GetErrorModalMessage() string {\n   852→\treturn m.errorModalMessage\n   853→}\n   854→\n   855→// GetErrorModalGuidance returns the guidance text for the error modal\n   856→func (m Model) GetErrorModalGuidance() string {\n   857→\treturn m.errorModalGuidance\n   858→}\n   859→\n   860→// sortIssues sorts the issues based on the current sort field and order\n   861→func (m *Model) sortIssues() {\n   862→\tif len(m.issues) == 0 {\n   863→\t\treturn\n   864→\t}\n   865→\n   866→\tsort.Slice(m.issues, func(i, j int) bool {\n   867→\t\tvar less bool\n   868→\n   869→\t\tswitch m.sortField {\n   870→\t\tcase config.SortByUpdated:\n   871→\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n   872→\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n   873→\t\t\tless = ti.Before(tj)\n   874→\t\tcase config.SortByCreated:\n   875→\t\t\tti, _ := m.issues[i].CreatedAtTime()\n   876→\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n   877→\t\t\tless = ti.Before(tj)\n   878→\t\tcase config.SortByNumber:\n   879→\t\t\tless = m.issues[i].Number < m.issues[j].Number\n   880→\t\tcase config.SortByComments:\n   881→\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n   882→\t\tdefault:\n   883→\t\t\t// Default to updated date\n   884→\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n   885→\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n   886→\t\t\tless = ti.Before(tj)\n   887→\t\t}\n   888→\n   889→\t\t// Descending order reverses the comparison\n   890→\t\tif m.sortOrder == config.SortDesc {\n   891→\t\t\treturn !less\n   892→\t\t}\n   893→\t\treturn less\n   894→\t})\n   895→}\n   896→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"e006bd1d-43d9-4d82-ad6c-4e7a1ee5793d","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","content":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues []github.Issue\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal    bool   // Whether the error modal is visible\n\terrorModalTitle   string // Title of the error modal\n\terrorModalMessage string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","numLines":896,"startLine":1,"totalLines":896}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017FP8mbjo6tQoox65qKv5JU","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also read the sync.go to understand how last_sync time is being stored, and the root.go to see how refresh interacts with sync."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":25157,"cache_read_input_tokens":24953,"cache_creation":{"ephemeral_5m_input_tokens":25157,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"7ba9c9c5-f89a-47e3-a28d-db5d748b9330"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017FP8mbjo6tQoox65qKv5JU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_013Wb4jztKknuna6gUut7rzQ","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/internal/sync/sync.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":25157,"cache_read_input_tokens":24953,"cache_creation":{"ephemeral_5m_input_tokens":25157,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"386f8466-5efc-4c4b-a270-a94020fc3093"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017FP8mbjo6tQoox65qKv5JU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01B7JdPK7BXymhMEfNwkKuEN","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":25157,"cache_read_input_tokens":24953,"cache_creation":{"ephemeral_5m_input_tokens":25157,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"df2b8376-82e7-49b2-b0ee-5471d071574c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_013Wb4jztKknuna6gUut7rzQ","type":"tool_result","content":"     1→package sync\n     2→\n     3→import (\n     4→\t\"context\"\n     5→\t\"fmt\"\n     6→\t\"time\"\n     7→\n     8→\t\"github.com/shepbook/ghissues/internal/db\"\n     9→\t\"github.com/shepbook/ghissues/internal/github\"\n    10→)\n    11→\n    12→// Progress contains progress information during sync\n    13→type Progress struct {\n    14→\tPhase           string // \"issues\" or \"comments\"\n    15→\tIssuesFetched   int\n    16→\tTotalIssues     int\n    17→\tCommentsFetched int\n    18→\tCurrentIssue    int\n    19→}\n    20→\n    21→// ProgressCallback is called during sync operations to report progress\n    22→type ProgressCallback func(Progress)\n    23→\n    24→// Result contains the result of a sync operation\n    25→type Result struct {\n    26→\tIssuesFetched   int\n    27→\tCommentsFetched int\n    28→\tDuration        time.Duration\n    29→}\n    30→\n    31→// Syncer handles syncing issues from GitHub to the local database\n    32→type Syncer struct {\n    33→\tclient *github.Client\n    34→\tstore  *db.Store\n    35→}\n    36→\n    37→// NewSyncer creates a new Syncer\n    38→func NewSyncer(client *github.Client, store *db.Store) *Syncer {\n    39→\treturn &Syncer{\n    40→\t\tclient: client,\n    41→\t\tstore:  store,\n    42→\t}\n    43→}\n    44→\n    45→// Sync fetches all open issues and their comments from GitHub\n    46→func (s *Syncer) Sync(ctx context.Context, owner, repo string, progress ProgressCallback) (*Result, error) {\n    47→\tstartTime := time.Now()\n    48→\tresult := &Result{}\n    49→\n    50→\t// Get current issue numbers from database before sync\n    51→\t// This allows us to detect issues that have been closed/deleted\n    52→\texistingNumbers, err := s.store.GetAllIssueNumbers(ctx)\n    53→\tif err != nil {\n    54→\t\treturn nil, fmt.Errorf(\"failed to get existing issue numbers: %w\", err)\n    55→\t}\n    56→\texistingSet := make(map[int]bool)\n    57→\tfor _, num := range existingNumbers {\n    58→\t\texistingSet[num] = true\n    59→\t}\n    60→\n    61→\t// Fetch issues with progress\n    62→\tissues, err := s.client.FetchIssues(ctx, owner, repo, func(p github.FetchProgress) {\n    63→\t\tif progress != nil {\n    64→\t\t\tprogress(Progress{\n    65→\t\t\t\tPhase:         \"issues\",\n    66→\t\t\t\tIssuesFetched: p.Fetched,\n    67→\t\t\t\tTotalIssues:   p.Total,\n    68→\t\t\t})\n    69→\t\t}\n    70→\t})\n    71→\tif err != nil {\n    72→\t\treturn nil, fmt.Errorf(\"failed to fetch issues: %w\", err)\n    73→\t}\n    74→\n    75→\tresult.IssuesFetched = len(issues)\n    76→\tresult.Duration = time.Since(startTime)\n    77→\n    78→\t// Build set of fetched issue numbers\n    79→\tfetchedSet := make(map[int]bool)\n    80→\tfor _, issue := range issues {\n    81→\t\tfetchedSet[issue.Number] = true\n    82→\t}\n    83→\n    84→\t// Find issues that were in DB but not in the fresh fetch (closed/deleted)\n    85→\tvar issuesToRemove []int\n    86→\tfor num := range existingSet {\n    87→\t\tif !fetchedSet[num] {\n    88→\t\t\tissuesToRemove = append(issuesToRemove, num)\n    89→\t\t}\n    90→\t}\n    91→\n    92→\t// Remove closed/deleted issues from database\n    93→\tif len(issuesToRemove) > 0 {\n    94→\t\tif err := s.store.DeleteIssues(ctx, issuesToRemove); err != nil {\n    95→\t\t\treturn nil, fmt.Errorf(\"failed to remove closed issues: %w\", err)\n    96→\t\t}\n    97→\t}\n    98→\n    99→\t// Save issues to database\n   100→\tif err := s.store.SaveIssues(ctx, issues); err != nil {\n   101→\t\treturn nil, fmt.Errorf(\"failed to save issues: %w\", err)\n   102→\t}\n   103→\n   104→\t// Fetch comments for issues that have them\n   105→\tfor i, issue := range issues {\n   106→\t\tselect {\n   107→\t\tcase <-ctx.Done():\n   108→\t\t\treturn nil, ctx.Err()\n   109→\t\tdefault:\n   110→\t\t}\n   111→\n   112→\t\tif issue.CommentCount > 0 {\n   113→\t\t\tcomments, err := s.client.FetchIssueComments(ctx, owner, repo, issue.Number)\n   114→\t\t\tif err != nil {\n   115→\t\t\t\treturn nil, fmt.Errorf(\"failed to fetch comments for issue #%d: %w\", issue.Number, err)\n   116→\t\t\t}\n   117→\n   118→\t\t\tif err := s.store.SaveComments(ctx, issue.Number, comments); err != nil {\n   119→\t\t\t\treturn nil, fmt.Errorf(\"failed to save comments for issue #%d: %w\", issue.Number, err)\n   120→\t\t\t}\n   121→\n   122→\t\t\tresult.CommentsFetched += len(comments)\n   123→\n   124→\t\t\tif progress != nil {\n   125→\t\t\t\tprogress(Progress{\n   126→\t\t\t\t\tPhase:           \"comments\",\n   127→\t\t\t\t\tIssuesFetched:   len(issues),\n   128→\t\t\t\t\tTotalIssues:     len(issues),\n   129→\t\t\t\t\tCommentsFetched: result.CommentsFetched,\n   130→\t\t\t\t\tCurrentIssue:    i + 1,\n   131→\t\t\t\t})\n   132→\t\t\t}\n   133→\t\t}\n   134→\t}\n   135→\n   136→\t// Update last sync time\n   137→\tif err := s.store.SetLastSyncTime(ctx, time.Now()); err != nil {\n   138→\t\treturn nil, fmt.Errorf(\"failed to update sync time: %w\", err)\n   139→\t}\n   140→\n   141→\tresult.Duration = time.Since(startTime)\n   142→\treturn result, nil\n   143→}\n   144→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"1e171454-fe7f-471f-94a7-3a11cc306c34","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/sync/sync.go","content":"package sync\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// Progress contains progress information during sync\ntype Progress struct {\n\tPhase           string // \"issues\" or \"comments\"\n\tIssuesFetched   int\n\tTotalIssues     int\n\tCommentsFetched int\n\tCurrentIssue    int\n}\n\n// ProgressCallback is called during sync operations to report progress\ntype ProgressCallback func(Progress)\n\n// Result contains the result of a sync operation\ntype Result struct {\n\tIssuesFetched   int\n\tCommentsFetched int\n\tDuration        time.Duration\n}\n\n// Syncer handles syncing issues from GitHub to the local database\ntype Syncer struct {\n\tclient *github.Client\n\tstore  *db.Store\n}\n\n// NewSyncer creates a new Syncer\nfunc NewSyncer(client *github.Client, store *db.Store) *Syncer {\n\treturn &Syncer{\n\t\tclient: client,\n\t\tstore:  store,\n\t}\n}\n\n// Sync fetches all open issues and their comments from GitHub\nfunc (s *Syncer) Sync(ctx context.Context, owner, repo string, progress ProgressCallback) (*Result, error) {\n\tstartTime := time.Now()\n\tresult := &Result{}\n\n\t// Get current issue numbers from database before sync\n\t// This allows us to detect issues that have been closed/deleted\n\texistingNumbers, err := s.store.GetAllIssueNumbers(ctx)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to get existing issue numbers: %w\", err)\n\t}\n\texistingSet := make(map[int]bool)\n\tfor _, num := range existingNumbers {\n\t\texistingSet[num] = true\n\t}\n\n\t// Fetch issues with progress\n\tissues, err := s.client.FetchIssues(ctx, owner, repo, func(p github.FetchProgress) {\n\t\tif progress != nil {\n\t\t\tprogress(Progress{\n\t\t\t\tPhase:         \"issues\",\n\t\t\t\tIssuesFetched: p.Fetched,\n\t\t\t\tTotalIssues:   p.Total,\n\t\t\t})\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to fetch issues: %w\", err)\n\t}\n\n\tresult.IssuesFetched = len(issues)\n\tresult.Duration = time.Since(startTime)\n\n\t// Build set of fetched issue numbers\n\tfetchedSet := make(map[int]bool)\n\tfor _, issue := range issues {\n\t\tfetchedSet[issue.Number] = true\n\t}\n\n\t// Find issues that were in DB but not in the fresh fetch (closed/deleted)\n\tvar issuesToRemove []int\n\tfor num := range existingSet {\n\t\tif !fetchedSet[num] {\n\t\t\tissuesToRemove = append(issuesToRemove, num)\n\t\t}\n\t}\n\n\t// Remove closed/deleted issues from database\n\tif len(issuesToRemove) > 0 {\n\t\tif err := s.store.DeleteIssues(ctx, issuesToRemove); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to remove closed issues: %w\", err)\n\t\t}\n\t}\n\n\t// Save issues to database\n\tif err := s.store.SaveIssues(ctx, issues); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to save issues: %w\", err)\n\t}\n\n\t// Fetch comments for issues that have them\n\tfor i, issue := range issues {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, ctx.Err()\n\t\tdefault:\n\t\t}\n\n\t\tif issue.CommentCount > 0 {\n\t\t\tcomments, err := s.client.FetchIssueComments(ctx, owner, repo, issue.Number)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to fetch comments for issue #%d: %w\", issue.Number, err)\n\t\t\t}\n\n\t\t\tif err := s.store.SaveComments(ctx, issue.Number, comments); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"failed to save comments for issue #%d: %w\", issue.Number, err)\n\t\t\t}\n\n\t\t\tresult.CommentsFetched += len(comments)\n\n\t\t\tif progress != nil {\n\t\t\t\tprogress(Progress{\n\t\t\t\t\tPhase:           \"comments\",\n\t\t\t\t\tIssuesFetched:   len(issues),\n\t\t\t\t\tTotalIssues:     len(issues),\n\t\t\t\t\tCommentsFetched: result.CommentsFetched,\n\t\t\t\t\tCurrentIssue:    i + 1,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n\n\t// Update last sync time\n\tif err := s.store.SetLastSyncTime(ctx, time.Now()); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to update sync time: %w\", err)\n\t}\n\n\tresult.Duration = time.Since(startTime)\n\treturn result, nil\n}\n","numLines":144,"startLine":1,"totalLines":144}}}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01B7JdPK7BXymhMEfNwkKuEN","type":"tool_result","content":"     1→package cmd\n     2→\n     3→import (\n     4→\t\"context\"\n     5→\t\"fmt\"\n     6→\t\"strings\"\n     7→\n     8→\ttea \"github.com/charmbracelet/bubbletea\"\n     9→\t\"github.com/shepbook/ghissues/internal/auth\"\n    10→\t\"github.com/shepbook/ghissues/internal/config\"\n    11→\t\"github.com/shepbook/ghissues/internal/db\"\n    12→\t\"github.com/shepbook/ghissues/internal/github\"\n    13→\t\"github.com/shepbook/ghissues/internal/setup\"\n    14→\t\"github.com/shepbook/ghissues/internal/sync\"\n    15→\t\"github.com/shepbook/ghissues/internal/tui\"\n    16→\t\"github.com/spf13/cobra\"\n    17→)\n    18→\n    19→var configPath string\n    20→var dbPath string\n    21→var disableTUI bool // For testing - skips TUI startup\n    22→\n    23→// SetDisableTUI sets whether to skip TUI startup (for testing)\n    24→func SetDisableTUI(disable bool) {\n    25→\tdisableTUI = disable\n    26→}\n    27→\n    28→// SetConfigPath sets a custom config path (mainly for testing)\n    29→func SetConfigPath(path string) {\n    30→\tconfigPath = path\n    31→}\n    32→\n    33→// GetConfigPath returns the current config path, defaulting to the standard location\n    34→func GetConfigPath() string {\n    35→\tif configPath == \"\" {\n    36→\t\treturn config.DefaultConfigPath()\n    37→\t}\n    38→\treturn configPath\n    39→}\n    40→\n    41→// SetDBPath sets a custom database path (mainly for testing)\n    42→func SetDBPath(path string) {\n    43→\tdbPath = path\n    44→}\n    45→\n    46→// GetDBPath returns the current database path (empty string means use default)\n    47→func GetDBPath() string {\n    48→\treturn dbPath\n    49→}\n    50→\n    51→// ShouldRunSetup returns true if the interactive setup should be run\n    52→// (i.e., when config file doesn't exist)\n    53→func ShouldRunSetup(path string) bool {\n    54→\treturn !config.Exists(path)\n    55→}\n    56→\n    57→// NewRootCmd creates the root command for ghissues\n    58→func NewRootCmd() *cobra.Command {\n    59→\tvar dbFlagPath string\n    60→\n    61→\trootCmd := &cobra.Command{\n    62→\t\tUse:   \"ghissues\",\n    63→\t\tShort: \"GitHub Issues TUI - Browse and review GitHub issues offline\",\n    64→\t\tLong: `ghissues is a terminal user interface for browsing GitHub issues.\n    65→It syncs issues from a GitHub repository to a local database for offline access.\n    66→\n    67→On first run, you'll be prompted to configure your repository and authentication.\n    68→You can also run 'ghissues config' to reconfigure at any time.`,\n    69→\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n    70→\t\t\t// Set the dbPath global if flag was provided\n    71→\t\t\tif dbFlagPath != \"\" {\n    72→\t\t\t\tSetDBPath(dbFlagPath)\n    73→\t\t\t}\n    74→\t\t\treturn nil\n    75→\t\t},\n    76→\t\tRunE: func(cmd *cobra.Command, args []string) error {\n    77→\t\t\tpath := GetConfigPath()\n    78→\n    79→\t\t\t// Check if first-time setup is needed\n    80→\t\t\tif ShouldRunSetup(path) {\n    81→\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Welcome to ghissues! Let's set up your configuration.\")\n    82→\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n    83→\t\t\t\t_, err := setup.RunInteractiveSetup(path)\n    84→\t\t\t\tif err != nil {\n    85→\t\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n    86→\t\t\t\t}\n    87→\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n    88→\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Configuration saved! You can reconfigure anytime with 'ghissues config'\")\n    89→\t\t\t}\n    90→\n    91→\t\t\t// Load config and start TUI (placeholder for now)\n    92→\t\t\tcfg, err := config.Load(path)\n    93→\t\t\tif err != nil {\n    94→\t\t\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n    95→\t\t\t}\n    96→\n    97→\t\t\t// Resolve and validate database path\n    98→\t\t\tresolvedDBPath, err := db.ResolveDBPath(GetDBPath(), cfg)\n    99→\t\t\tif err != nil {\n   100→\t\t\t\treturn fmt.Errorf(\"failed to resolve database path: %w\", err)\n   101→\t\t\t}\n   102→\n   103→\t\t\tif err := db.EnsureDBPath(resolvedDBPath); err != nil {\n   104→\t\t\t\treturn err\n   105→\t\t\t}\n   106→\n   107→\t\t\t// Open database and load issues\n   108→\t\t\tstore, err := db.NewStore(resolvedDBPath)\n   109→\t\t\tif err != nil {\n   110→\t\t\t\treturn fmt.Errorf(\"failed to open database: %w\", err)\n   111→\t\t\t}\n   112→\t\t\tdefer store.Close()\n   113→\n   114→\t\t\tissues, err := store.GetAllIssues(context.Background())\n   115→\t\t\tif err != nil {\n   116→\t\t\t\treturn fmt.Errorf(\"failed to load issues: %w\", err)\n   117→\t\t\t}\n   118→\n   119→\t\t\t// Get display columns (from config or defaults)\n   120→\t\t\tcolumns := cfg.Display.Columns\n   121→\t\t\tif len(columns) == 0 {\n   122→\t\t\t\tcolumns = config.DefaultDisplayColumns()\n   123→\t\t\t}\n   124→\n   125→\t\t\t// Get sort settings (from config or defaults)\n   126→\t\t\tsortField := cfg.Display.SortField\n   127→\t\t\tsortOrder := cfg.Display.SortOrder\n   128→\t\t\tif sortField == \"\" {\n   129→\t\t\t\tsortField, _ = config.DefaultSortConfig()\n   130→\t\t\t}\n   131→\t\t\tif sortOrder == \"\" {\n   132→\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n   133→\t\t\t}\n   134→\n   135→\t\t\t// Skip TUI if disabled (for testing)\n   136→\t\t\tif disableTUI {\n   137→\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n   138→\t\t\t\treturn nil\n   139→\t\t\t}\n   140→\n   141→\t\t\t// Parse repository for sync\n   142→\t\t\towner, repo, err := parseRepo(cfg.Repository)\n   143→\t\t\tif err != nil {\n   144→\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n   145→\t\t\t}\n   146→\n   147→\t\t\t// Create and run TUI\n   148→\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n   149→\n   150→\t\t\t// Set up refresh function for manual refresh (r key)\n   151→\t\t\t// This creates a closure that captures the necessary context\n   152→\t\t\tmodel.SetRefreshFunc(createRefreshFunc(cfg, store, owner, repo))\n   153→\n   154→\t\t\tp := tea.NewProgram(model, tea.WithAltScreen())\n   155→\n   156→\t\t\t// Trigger auto-refresh on launch by sending RefreshStartMsg\n   157→\t\t\tgo func() {\n   158→\t\t\t\tp.Send(tui.RefreshStartMsg{})\n   159→\t\t\t}()\n   160→\n   161→\t\t\tfinalModel, err := p.Run()\n   162→\t\t\tif err != nil {\n   163→\t\t\t\treturn fmt.Errorf(\"TUI error: %w\", err)\n   164→\t\t\t}\n   165→\n   166→\t\t\t// Save sort preferences if they changed\n   167→\t\t\tif m, ok := finalModel.(tui.Model); ok && m.SortChanged() {\n   168→\t\t\t\tnewSortField, newSortOrder := m.GetSortConfig()\n   169→\t\t\t\tcfg.Display.SortField = newSortField\n   170→\t\t\t\tcfg.Display.SortOrder = newSortOrder\n   171→\t\t\t\tif err := config.Save(cfg, path); err != nil {\n   172→\t\t\t\t\t// Don't fail, just warn - the main operation succeeded\n   173→\t\t\t\t\tfmt.Fprintf(cmd.ErrOrStderr(), \"Warning: failed to save sort preferences: %v\\n\", err)\n   174→\t\t\t\t}\n   175→\t\t\t}\n   176→\n   177→\t\t\treturn nil\n   178→\t\t},\n   179→\t}\n   180→\n   181→\t// Add persistent flags (available to all subcommands)\n   182→\trootCmd.PersistentFlags().StringVar(&dbFlagPath, \"db\", \"\", \"Path to local database file (default: .ghissues.db)\")\n   183→\n   184→\t// Add subcommands\n   185→\trootCmd.AddCommand(newConfigCmd())\n   186→\trootCmd.AddCommand(newSyncCmd())\n   187→\n   188→\treturn rootCmd\n   189→}\n   190→\n   191→// newConfigCmd creates the config subcommand\n   192→func newConfigCmd() *cobra.Command {\n   193→\tvar repo string\n   194→\tvar authMethod string\n   195→\tvar token string\n   196→\n   197→\tcmd := &cobra.Command{\n   198→\t\tUse:   \"config\",\n   199→\t\tShort: \"Configure ghissues settings (run interactive configuration)\",\n   200→\t\tLong: `Configure ghissues settings including repository and authentication method.\n   201→\n   202→When run without flags, starts an interactive setup wizard.\n   203→You can also provide flags to configure non-interactively.`,\n   204→\t\tRunE: func(cmd *cobra.Command, args []string) error {\n   205→\t\t\tpath := GetConfigPath()\n   206→\n   207→\t\t\t// If flags provided, use non-interactive mode\n   208→\t\t\tif repo != \"\" && authMethod != \"\" {\n   209→\t\t\t\t_, err := setup.RunSetupWithValues(repo, authMethod, token, path)\n   210→\t\t\t\tif err != nil {\n   211→\t\t\t\t\treturn err\n   212→\t\t\t\t}\n   213→\t\t\t\tfmt.Println(\"Configuration saved successfully!\")\n   214→\t\t\t\treturn nil\n   215→\t\t\t}\n   216→\n   217→\t\t\t// Otherwise, run interactive setup\n   218→\t\t\tfmt.Println(\"Let's configure ghissues!\")\n   219→\t\t\tfmt.Println()\n   220→\t\t\t_, err := setup.RunInteractiveSetup(path)\n   221→\t\t\tif err != nil {\n   222→\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n   223→\t\t\t}\n   224→\t\t\tfmt.Println()\n   225→\t\t\tfmt.Println(\"Configuration saved!\")\n   226→\t\t\treturn nil\n   227→\t\t},\n   228→\t}\n   229→\n   230→\tcmd.Flags().StringVar(&repo, \"repo\", \"\", \"GitHub repository in owner/repo format\")\n   231→\tcmd.Flags().StringVar(&authMethod, \"auth-method\", \"\", \"Authentication method: env, token, or gh\")\n   232→\tcmd.Flags().StringVar(&token, \"token\", \"\", \"GitHub personal access token (required when auth-method is 'token')\")\n   233→\n   234→\treturn cmd\n   235→}\n   236→\n   237→// Execute runs the root command\n   238→func Execute() error {\n   239→\treturn NewRootCmd().Execute()\n   240→}\n   241→\n   242→// parseRepo parses a repository string in the format \"owner/repo\"\n   243→func parseRepo(repoStr string) (owner, repo string, err error) {\n   244→\tparts := strings.Split(repoStr, \"/\")\n   245→\tif len(parts) != 2 {\n   246→\t\treturn \"\", \"\", fmt.Errorf(\"invalid repository format: %s (expected owner/repo)\", repoStr)\n   247→\t}\n   248→\treturn parts[0], parts[1], nil\n   249→}\n   250→\n   251→// createRefreshFunc creates a function that performs a sync operation\n   252→// This function is called as a tea.Cmd and returns a tea.Msg\n   253→func createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n   254→\treturn func() tea.Msg {\n   255→\t\tctx := context.Background()\n   256→\n   257→\t\t// Get authentication token\n   258→\t\ttoken, _, err := auth.GetToken(cfg)\n   259→\t\tif err != nil {\n   260→\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n   261→\t\t}\n   262→\n   263→\t\t// Create client and syncer\n   264→\t\tclient := github.NewClient(token)\n   265→\t\tsyncer := sync.NewSyncer(client, store)\n   266→\n   267→\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n   268→\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n   269→\t\tif err != nil {\n   270→\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n   271→\t\t}\n   272→\n   273→\t\t// Re-fetch issues from database after sync\n   274→\t\tissues, err := store.GetAllIssues(ctx)\n   275→\t\tif err != nil {\n   276→\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n   277→\t\t}\n   278→\n   279→\t\treturn tui.RefreshDoneMsg{Issues: issues}\n   280→\t}\n   281→}\n   282→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"ba500331-0616-495f-8bd4-d1d131591272","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","content":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar configPath string\nvar dbPath string\nvar disableTUI bool // For testing - skips TUI startup\n\n// SetDisableTUI sets whether to skip TUI startup (for testing)\nfunc SetDisableTUI(disable bool) {\n\tdisableTUI = disable\n}\n\n// SetConfigPath sets a custom config path (mainly for testing)\nfunc SetConfigPath(path string) {\n\tconfigPath = path\n}\n\n// GetConfigPath returns the current config path, defaulting to the standard location\nfunc GetConfigPath() string {\n\tif configPath == \"\" {\n\t\treturn config.DefaultConfigPath()\n\t}\n\treturn configPath\n}\n\n// SetDBPath sets a custom database path (mainly for testing)\nfunc SetDBPath(path string) {\n\tdbPath = path\n}\n\n// GetDBPath returns the current database path (empty string means use default)\nfunc GetDBPath() string {\n\treturn dbPath\n}\n\n// ShouldRunSetup returns true if the interactive setup should be run\n// (i.e., when config file doesn't exist)\nfunc ShouldRunSetup(path string) bool {\n\treturn !config.Exists(path)\n}\n\n// NewRootCmd creates the root command for ghissues\nfunc NewRootCmd() *cobra.Command {\n\tvar dbFlagPath string\n\n\trootCmd := &cobra.Command{\n\t\tUse:   \"ghissues\",\n\t\tShort: \"GitHub Issues TUI - Browse and review GitHub issues offline\",\n\t\tLong: `ghissues is a terminal user interface for browsing GitHub issues.\nIt syncs issues from a GitHub repository to a local database for offline access.\n\nOn first run, you'll be prompted to configure your repository and authentication.\nYou can also run 'ghissues config' to reconfigure at any time.`,\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// Set the dbPath global if flag was provided\n\t\t\tif dbFlagPath != \"\" {\n\t\t\t\tSetDBPath(dbFlagPath)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// Check if first-time setup is needed\n\t\t\tif ShouldRunSetup(path) {\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Welcome to ghissues! Let's set up your configuration.\")\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Configuration saved! You can reconfigure anytime with 'ghissues config'\")\n\t\t\t}\n\n\t\t\t// Load config and start TUI (placeholder for now)\n\t\t\tcfg, err := config.Load(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n\t\t\t}\n\n\t\t\t// Resolve and validate database path\n\t\t\tresolvedDBPath, err := db.ResolveDBPath(GetDBPath(), cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to resolve database path: %w\", err)\n\t\t\t}\n\n\t\t\tif err := db.EnsureDBPath(resolvedDBPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Open database and load issues\n\t\t\tstore, err := db.NewStore(resolvedDBPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to open database: %w\", err)\n\t\t\t}\n\t\t\tdefer store.Close()\n\n\t\t\tissues, err := store.GetAllIssues(context.Background())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load issues: %w\", err)\n\t\t\t}\n\n\t\t\t// Get display columns (from config or defaults)\n\t\t\tcolumns := cfg.Display.Columns\n\t\t\tif len(columns) == 0 {\n\t\t\t\tcolumns = config.DefaultDisplayColumns()\n\t\t\t}\n\n\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\n\t\t\t// Set up refresh function for manual refresh (r key)\n\t\t\t// This creates a closure that captures the necessary context\n\t\t\tmodel.SetRefreshFunc(createRefreshFunc(cfg, store, owner, repo))\n\n\t\t\tp := tea.NewProgram(model, tea.WithAltScreen())\n\n\t\t\t// Trigger auto-refresh on launch by sending RefreshStartMsg\n\t\t\tgo func() {\n\t\t\t\tp.Send(tui.RefreshStartMsg{})\n\t\t\t}()\n\n\t\t\tfinalModel, err := p.Run()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"TUI error: %w\", err)\n\t\t\t}\n\n\t\t\t// Save sort preferences if they changed\n\t\t\tif m, ok := finalModel.(tui.Model); ok && m.SortChanged() {\n\t\t\t\tnewSortField, newSortOrder := m.GetSortConfig()\n\t\t\t\tcfg.Display.SortField = newSortField\n\t\t\t\tcfg.Display.SortOrder = newSortOrder\n\t\t\t\tif err := config.Save(cfg, path); err != nil {\n\t\t\t\t\t// Don't fail, just warn - the main operation succeeded\n\t\t\t\t\tfmt.Fprintf(cmd.ErrOrStderr(), \"Warning: failed to save sort preferences: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t// Add persistent flags (available to all subcommands)\n\trootCmd.PersistentFlags().StringVar(&dbFlagPath, \"db\", \"\", \"Path to local database file (default: .ghissues.db)\")\n\n\t// Add subcommands\n\trootCmd.AddCommand(newConfigCmd())\n\trootCmd.AddCommand(newSyncCmd())\n\n\treturn rootCmd\n}\n\n// newConfigCmd creates the config subcommand\nfunc newConfigCmd() *cobra.Command {\n\tvar repo string\n\tvar authMethod string\n\tvar token string\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"config\",\n\t\tShort: \"Configure ghissues settings (run interactive configuration)\",\n\t\tLong: `Configure ghissues settings including repository and authentication method.\n\nWhen run without flags, starts an interactive setup wizard.\nYou can also provide flags to configure non-interactively.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// If flags provided, use non-interactive mode\n\t\t\tif repo != \"\" && authMethod != \"\" {\n\t\t\t\t_, err := setup.RunSetupWithValues(repo, authMethod, token, path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Configuration saved successfully!\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise, run interactive setup\n\t\t\tfmt.Println(\"Let's configure ghissues!\")\n\t\t\tfmt.Println()\n\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t}\n\t\t\tfmt.Println()\n\t\t\tfmt.Println(\"Configuration saved!\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd.Flags().StringVar(&repo, \"repo\", \"\", \"GitHub repository in owner/repo format\")\n\tcmd.Flags().StringVar(&authMethod, \"auth-method\", \"\", \"Authentication method: env, token, or gh\")\n\tcmd.Flags().StringVar(&token, \"token\", \"\", \"GitHub personal access token (required when auth-method is 'token')\")\n\n\treturn cmd\n}\n\n// Execute runs the root command\nfunc Execute() error {\n\treturn NewRootCmd().Execute()\n}\n\n// parseRepo parses a repository string in the format \"owner/repo\"\nfunc parseRepo(repoStr string) (owner, repo string, err error) {\n\tparts := strings.Split(repoStr, \"/\")\n\tif len(parts) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid repository format: %s (expected owner/repo)\", repoStr)\n\t}\n\treturn parts[0], parts[1], nil\n}\n\n// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}\n","numLines":282,"startLine":1,"totalLines":282}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RhG7yG4AD1Lf1pFk8wH3NT","type":"message","role":"assistant","content":[{"type":"text","text":"Now I understand the current state. Let me analyze what's needed for US-010:\n\n**Acceptance Criteria:**\n1. Status bar shows `Last synced: <relative time>` (e.g., 5 minutes ago)\n2. Timestamp stored in database metadata table\n3. Updates after each successful sync\n\n**Current State:**\n- The database already has `GetLastSyncTime()` and `SetLastSyncTime()` methods in `internal/db/store.go` (lines 352-373)\n- The sync operation already calls `SetLastSyncTime()` after a successful sync (line 137 in sync.go)\n- The TUI status bar currently shows issue count, sort info, and keybindings but NOT the last synced time\n\nSo the timestamp storage is already implemented! I just need to:\n1. Pass the last sync time to the TUI model\n2. Display it in the status bar as a relative time (e.g., \"5 minutes ago\")\n3. Update it when refresh completes\n\nLet me create a todo list and implement this using TDD."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5658,"cache_read_input_tokens":50110,"cache_creation":{"ephemeral_5m_input_tokens":5658,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"95ec4a7a-8539-48d9-9898-354fc6c191d1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RhG7yG4AD1Lf1pFk8wH3NT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01G5sLvCCQiBBZsxsCi1J7YQ","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"in_progress","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"pending","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":5658,"cache_read_input_tokens":50110,"cache_creation":{"ephemeral_5m_input_tokens":5658,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"c503686f-262a-4c19-9067-4965d8995dc3"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01G5sLvCCQiBBZsxsCi1J7YQ","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"d5ee930c-96bd-4501-b9f6-024dcbc61a3e","tool_use_result":{"oldTodos":[],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"in_progress","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"pending","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0136HrvzxSWry7j6rgN9KtxU","type":"message","role":"assistant","content":[{"type":"text","text":"Let me read the existing TUI tests to understand the testing patterns."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":576,"cache_read_input_tokens":55768,"cache_creation":{"ephemeral_5m_input_tokens":576,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2c7aeef5-3f12-4bb3-9f47-b4aed6e1bcac"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0136HrvzxSWry7j6rgN9KtxU","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01T5piwYp79JyKwbYUR9WvTJ","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":576,"cache_read_input_tokens":55768,"cache_creation":{"ephemeral_5m_input_tokens":576,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"a839f480-505f-4289-a635-358130013e6d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01T5piwYp79JyKwbYUR9WvTJ","type":"tool_result","content":"     1→package tui\n     2→\n     3→import (\n     4→\t\"fmt\"\n     5→\t\"testing\"\n     6→\n     7→\ttea \"github.com/charmbracelet/bubbletea\"\n     8→\t\"github.com/shepbook/ghissues/internal/config\"\n     9→\t\"github.com/shepbook/ghissues/internal/github\"\n    10→\t\"github.com/stretchr/testify/assert\"\n    11→\t\"github.com/stretchr/testify/require\"\n    12→)\n    13→\n    14→func createTestIssues() []github.Issue {\n    15→\treturn []github.Issue{\n    16→\t\t{\n    17→\t\t\tNumber:       1,\n    18→\t\t\tTitle:        \"First issue\",\n    19→\t\t\tAuthor:       github.User{Login: \"user1\"},\n    20→\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n    21→\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n    22→\t\t\tCommentCount: 5,\n    23→\t\t},\n    24→\t\t{\n    25→\t\t\tNumber:       2,\n    26→\t\t\tTitle:        \"Second issue\",\n    27→\t\t\tAuthor:       github.User{Login: \"user2\"},\n    28→\t\t\tCreatedAt:    \"2024-01-02T12:00:00Z\",\n    29→\t\t\tUpdatedAt:    \"2024-01-16T12:00:00Z\",\n    30→\t\t\tCommentCount: 3,\n    31→\t\t},\n    32→\t\t{\n    33→\t\t\tNumber:       3,\n    34→\t\t\tTitle:        \"Third issue\",\n    35→\t\t\tAuthor:       github.User{Login: \"user3\"},\n    36→\t\t\tCreatedAt:    \"2024-01-03T12:00:00Z\",\n    37→\t\t\tUpdatedAt:    \"2024-01-17T12:00:00Z\",\n    38→\t\t\tCommentCount: 0,\n    39→\t\t},\n    40→\t}\n    41→}\n    42→\n    43→func TestNewModel(t *testing.T) {\n    44→\tissues := createTestIssues()\n    45→\tcolumns := []string{\"number\", \"title\", \"author\"}\n    46→\n    47→\tm := NewModel(issues, columns)\n    48→\n    49→\t// Issues are sorted by updated date descending by default\n    50→\t// createTestIssues has: 1 (Jan 15), 2 (Jan 16), 3 (Jan 17)\n    51→\t// So sorted: 3, 2, 1\n    52→\tassert.Equal(t, 3, m.issues[0].Number)\n    53→\tassert.Equal(t, 2, m.issues[1].Number)\n    54→\tassert.Equal(t, 1, m.issues[2].Number)\n    55→\tassert.Equal(t, columns, m.columns)\n    56→\tassert.Equal(t, 0, m.cursor)\n    57→\tassert.Equal(t, 3, m.IssueCount())\n    58→}\n    59→\n    60→func TestNewModelEmpty(t *testing.T) {\n    61→\tm := NewModel(nil, nil)\n    62→\n    63→\tassert.Empty(t, m.issues)\n    64→\tassert.Equal(t, DefaultColumns(), m.columns)\n    65→\tassert.Equal(t, 0, m.cursor)\n    66→\tassert.Equal(t, 0, m.IssueCount())\n    67→}\n    68→\n    69→func TestModelNavigationDown(t *testing.T) {\n    70→\tissues := createTestIssues()\n    71→\tm := NewModel(issues, nil)\n    72→\n    73→\t// Initial cursor position\n    74→\tassert.Equal(t, 0, m.cursor)\n    75→\n    76→\t// Move down with j key\n    77→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n    78→\tm = newModel.(Model)\n    79→\tassert.Equal(t, 1, m.cursor)\n    80→\n    81→\t// Move down with down arrow\n    82→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n    83→\tm = newModel.(Model)\n    84→\tassert.Equal(t, 2, m.cursor)\n    85→\n    86→\t// Should not go past last item\n    87→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n    88→\tm = newModel.(Model)\n    89→\tassert.Equal(t, 2, m.cursor)\n    90→}\n    91→\n    92→func TestModelNavigationUp(t *testing.T) {\n    93→\tissues := createTestIssues()\n    94→\tm := NewModel(issues, nil)\n    95→\tm.cursor = 2 // Start at bottom\n    96→\n    97→\t// Move up with k key\n    98→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n    99→\tm = newModel.(Model)\n   100→\tassert.Equal(t, 1, m.cursor)\n   101→\n   102→\t// Move up with up arrow\n   103→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n   104→\tm = newModel.(Model)\n   105→\tassert.Equal(t, 0, m.cursor)\n   106→\n   107→\t// Should not go past first item\n   108→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n   109→\tm = newModel.(Model)\n   110→\tassert.Equal(t, 0, m.cursor)\n   111→}\n   112→\n   113→func TestModelQuitKeys(t *testing.T) {\n   114→\tissues := createTestIssues()\n   115→\tm := NewModel(issues, nil)\n   116→\n   117→\t// q should quit\n   118→\t_, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n   119→\trequire.NotNil(t, cmd)\n   120→\tmsg := cmd()\n   121→\tassert.IsType(t, tea.QuitMsg{}, msg)\n   122→\n   123→\t// Ctrl+C should quit\n   124→\t_, cmd = m.Update(tea.KeyMsg{Type: tea.KeyCtrlC})\n   125→\trequire.NotNil(t, cmd)\n   126→\tmsg = cmd()\n   127→\tassert.IsType(t, tea.QuitMsg{}, msg)\n   128→}\n   129→\n   130→func TestModelSelectedIssue(t *testing.T) {\n   131→\tissues := createTestIssues()\n   132→\tm := NewModel(issues, nil)\n   133→\n   134→\t// Get selected issue at cursor 0\n   135→\t// Default sort is by updated date descending, so issue 3 is first (most recently updated)\n   136→\tissue := m.SelectedIssue()\n   137→\trequire.NotNil(t, issue)\n   138→\tassert.Equal(t, 3, issue.Number)\n   139→\tassert.Equal(t, \"Third issue\", issue.Title)\n   140→\n   141→\t// Move cursor and check again\n   142→\tm.cursor = 1\n   143→\tissue = m.SelectedIssue()\n   144→\trequire.NotNil(t, issue)\n   145→\tassert.Equal(t, 2, issue.Number) // Second most recently updated\n   146→}\n   147→\n   148→func TestModelSelectedIssueEmpty(t *testing.T) {\n   149→\tm := NewModel(nil, nil)\n   150→\n   151→\tissue := m.SelectedIssue()\n   152→\tassert.Nil(t, issue)\n   153→}\n   154→\n   155→func TestModelIssueCount(t *testing.T) {\n   156→\ttests := []struct {\n   157→\t\tname     string\n   158→\t\tissues   []github.Issue\n   159→\t\texpected int\n   160→\t}{\n   161→\t\t{name: \"three issues\", issues: createTestIssues(), expected: 3},\n   162→\t\t{name: \"empty\", issues: nil, expected: 0},\n   163→\t\t{name: \"one issue\", issues: []github.Issue{{Number: 1}}, expected: 1},\n   164→\t}\n   165→\n   166→\tfor _, tt := range tests {\n   167→\t\tt.Run(tt.name, func(t *testing.T) {\n   168→\t\t\tm := NewModel(tt.issues, nil)\n   169→\t\t\tassert.Equal(t, tt.expected, m.IssueCount())\n   170→\t\t})\n   171→\t}\n   172→}\n   173→\n   174→func TestModelSetWindowSize(t *testing.T) {\n   175→\tm := NewModel(createTestIssues(), nil)\n   176→\n   177→\tm.SetWindowSize(100, 50)\n   178→\n   179→\tassert.Equal(t, 100, m.width)\n   180→\tassert.Equal(t, 50, m.height)\n   181→}\n   182→\n   183→func TestModelWindowSizeMsg(t *testing.T) {\n   184→\tm := NewModel(createTestIssues(), nil)\n   185→\n   186→\tnewModel, _ := m.Update(tea.WindowSizeMsg{Width: 120, Height: 40})\n   187→\tm = newModel.(Model)\n   188→\n   189→\tassert.Equal(t, 120, m.width)\n   190→\tassert.Equal(t, 40, m.height)\n   191→}\n   192→\n   193→func TestDefaultColumns(t *testing.T) {\n   194→\tcols := DefaultColumns()\n   195→\tassert.Equal(t, []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}, cols)\n   196→}\n   197→\n   198→func TestModelViewContainsIssueCount(t *testing.T) {\n   199→\tissues := createTestIssues()\n   200→\tm := NewModel(issues, nil)\n   201→\tm.SetWindowSize(80, 24)\n   202→\n   203→\tview := m.View()\n   204→\n   205→\t// Status area should show issue count\n   206→\tassert.Contains(t, view, \"3 issues\")\n   207→}\n   208→\n   209→func TestModelViewContainsSelectedHighlight(t *testing.T) {\n   210→\tissues := createTestIssues()\n   211→\tm := NewModel(issues, nil)\n   212→\tm.SetWindowSize(80, 24)\n   213→\n   214→\tview := m.View()\n   215→\n   216→\t// Selected issue should be in the view\n   217→\tassert.Contains(t, view, \"First issue\")\n   218→}\n   219→\n   220→func TestModelViewEmptyState(t *testing.T) {\n   221→\tm := NewModel(nil, nil)\n   222→\tm.SetWindowSize(80, 24)\n   223→\n   224→\tview := m.View()\n   225→\n   226→\t// Should show no issues message\n   227→\tassert.Contains(t, view, \"No issues\")\n   228→\tassert.Contains(t, view, \"0 issues\")\n   229→}\n   230→\n   231→// Helper to create test issues with varied dates and counts for sorting tests\n   232→func createSortTestIssues() []github.Issue {\n   233→\treturn []github.Issue{\n   234→\t\t{\n   235→\t\t\tNumber:       10,\n   236→\t\t\tTitle:        \"Issue ten\",\n   237→\t\t\tAuthor:       github.User{Login: \"alice\"},\n   238→\t\t\tCreatedAt:    \"2024-01-05T12:00:00Z\",\n   239→\t\t\tUpdatedAt:    \"2024-01-20T12:00:00Z\",\n   240→\t\t\tCommentCount: 2,\n   241→\t\t},\n   242→\t\t{\n   243→\t\t\tNumber:       5,\n   244→\t\t\tTitle:        \"Issue five\",\n   245→\t\t\tAuthor:       github.User{Login: \"bob\"},\n   246→\t\t\tCreatedAt:    \"2024-01-10T12:00:00Z\",\n   247→\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n   248→\t\t\tCommentCount: 10,\n   249→\t\t},\n   250→\t\t{\n   251→\t\t\tNumber:       15,\n   252→\t\t\tTitle:        \"Issue fifteen\",\n   253→\t\t\tAuthor:       github.User{Login: \"charlie\"},\n   254→\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n   255→\t\t\tUpdatedAt:    \"2024-01-25T12:00:00Z\",\n   256→\t\t\tCommentCount: 5,\n   257→\t\t},\n   258→\t}\n   259→}\n   260→\n   261→func TestNewModelWithSort(t *testing.T) {\n   262→\tissues := createSortTestIssues()\n   263→\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n   264→\n   265→\tassert.Equal(t, config.SortByUpdated, m.sortField)\n   266→\tassert.Equal(t, config.SortDesc, m.sortOrder)\n   267→\tassert.Equal(t, 3, m.IssueCount())\n   268→}\n   269→\n   270→func TestDefaultSortIsUpdatedDescending(t *testing.T) {\n   271→\tissues := createSortTestIssues()\n   272→\tm := NewModel(issues, nil)\n   273→\n   274→\t// Default sort should be by updated date descending (most recently updated first)\n   275→\tassert.Equal(t, config.SortByUpdated, m.sortField)\n   276→\tassert.Equal(t, config.SortDesc, m.sortOrder)\n   277→\n   278→\t// First issue should be the most recently updated (issue 15)\n   279→\tselected := m.SelectedIssue()\n   280→\trequire.NotNil(t, selected)\n   281→\tassert.Equal(t, 15, selected.Number)\n   282→}\n   283→\n   284→func TestSortByUpdatedDescending(t *testing.T) {\n   285→\tissues := createSortTestIssues()\n   286→\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n   287→\tm.SetWindowSize(80, 24)\n   288→\n   289→\t// Most recently updated first: 15 (Jan 25), 10 (Jan 20), 5 (Jan 15)\n   290→\tassert.Equal(t, 15, m.issues[0].Number)\n   291→\tassert.Equal(t, 10, m.issues[1].Number)\n   292→\tassert.Equal(t, 5, m.issues[2].Number)\n   293→}\n   294→\n   295→func TestSortByUpdatedAscending(t *testing.T) {\n   296→\tissues := createSortTestIssues()\n   297→\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortAsc)\n   298→\n   299→\t// Oldest updated first: 5 (Jan 15), 10 (Jan 20), 15 (Jan 25)\n   300→\tassert.Equal(t, 5, m.issues[0].Number)\n   301→\tassert.Equal(t, 10, m.issues[1].Number)\n   302→\tassert.Equal(t, 15, m.issues[2].Number)\n   303→}\n   304→\n   305→func TestSortByCreatedDescending(t *testing.T) {\n   306→\tissues := createSortTestIssues()\n   307→\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortDesc)\n   308→\n   309→\t// Most recently created first: 5 (Jan 10), 10 (Jan 5), 15 (Jan 1)\n   310→\tassert.Equal(t, 5, m.issues[0].Number)\n   311→\tassert.Equal(t, 10, m.issues[1].Number)\n   312→\tassert.Equal(t, 15, m.issues[2].Number)\n   313→}\n   314→\n   315→func TestSortByCreatedAscending(t *testing.T) {\n   316→\tissues := createSortTestIssues()\n   317→\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortAsc)\n   318→\n   319→\t// Oldest created first: 15 (Jan 1), 10 (Jan 5), 5 (Jan 10)\n   320→\tassert.Equal(t, 15, m.issues[0].Number)\n   321→\tassert.Equal(t, 10, m.issues[1].Number)\n   322→\tassert.Equal(t, 5, m.issues[2].Number)\n   323→}\n   324→\n   325→func TestSortByNumberDescending(t *testing.T) {\n   326→\tissues := createSortTestIssues()\n   327→\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortDesc)\n   328→\n   329→\t// Highest number first: 15, 10, 5\n   330→\tassert.Equal(t, 15, m.issues[0].Number)\n   331→\tassert.Equal(t, 10, m.issues[1].Number)\n   332→\tassert.Equal(t, 5, m.issues[2].Number)\n   333→}\n   334→\n   335→func TestSortByNumberAscending(t *testing.T) {\n   336→\tissues := createSortTestIssues()\n   337→\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n   338→\n   339→\t// Lowest number first: 5, 10, 15\n   340→\tassert.Equal(t, 5, m.issues[0].Number)\n   341→\tassert.Equal(t, 10, m.issues[1].Number)\n   342→\tassert.Equal(t, 15, m.issues[2].Number)\n   343→}\n   344→\n   345→func TestSortByCommentsDescending(t *testing.T) {\n   346→\tissues := createSortTestIssues()\n   347→\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortDesc)\n   348→\n   349→\t// Most comments first: 5 (10 comments), 15 (5 comments), 10 (2 comments)\n   350→\tassert.Equal(t, 5, m.issues[0].Number)\n   351→\tassert.Equal(t, 15, m.issues[1].Number)\n   352→\tassert.Equal(t, 10, m.issues[2].Number)\n   353→}\n   354→\n   355→func TestSortByCommentsAscending(t *testing.T) {\n   356→\tissues := createSortTestIssues()\n   357→\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n   358→\n   359→\t// Fewest comments first: 10 (2 comments), 15 (5 comments), 5 (10 comments)\n   360→\tassert.Equal(t, 10, m.issues[0].Number)\n   361→\tassert.Equal(t, 15, m.issues[1].Number)\n   362→\tassert.Equal(t, 5, m.issues[2].Number)\n   363→}\n   364→\n   365→func TestCycleSortFieldWithSKey(t *testing.T) {\n   366→\tissues := createSortTestIssues()\n   367→\tm := NewModel(issues, nil)\n   368→\n   369→\t// Initial sort: updated\n   370→\tassert.Equal(t, config.SortByUpdated, m.sortField)\n   371→\n   372→\t// Press 's' to cycle to created\n   373→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   374→\tm = newModel.(Model)\n   375→\tassert.Equal(t, config.SortByCreated, m.sortField)\n   376→\n   377→\t// Press 's' to cycle to number\n   378→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   379→\tm = newModel.(Model)\n   380→\tassert.Equal(t, config.SortByNumber, m.sortField)\n   381→\n   382→\t// Press 's' to cycle to comments\n   383→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   384→\tm = newModel.(Model)\n   385→\tassert.Equal(t, config.SortByComments, m.sortField)\n   386→\n   387→\t// Press 's' to wrap back to updated\n   388→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   389→\tm = newModel.(Model)\n   390→\tassert.Equal(t, config.SortByUpdated, m.sortField)\n   391→}\n   392→\n   393→func TestReverseSortOrderWithShiftSKey(t *testing.T) {\n   394→\tissues := createSortTestIssues()\n   395→\tm := NewModel(issues, nil)\n   396→\n   397→\t// Initial order: descending\n   398→\tassert.Equal(t, config.SortDesc, m.sortOrder)\n   399→\n   400→\t// Press 'S' to toggle to ascending\n   401→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n   402→\tm = newModel.(Model)\n   403→\tassert.Equal(t, config.SortAsc, m.sortOrder)\n   404→\n   405→\t// Press 'S' to toggle back to descending\n   406→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n   407→\tm = newModel.(Model)\n   408→\tassert.Equal(t, config.SortDesc, m.sortOrder)\n   409→}\n   410→\n   411→func TestSortReordersIssuesAndResetsCursor(t *testing.T) {\n   412→\tissues := createSortTestIssues()\n   413→\tm := NewModel(issues, nil)\n   414→\n   415→\t// Move cursor to second item\n   416→\tm.cursor = 1\n   417→\n   418→\t// Press 's' to change sort\n   419→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   420→\tm = newModel.(Model)\n   421→\n   422→\t// Cursor should reset to 0 after sort change\n   423→\tassert.Equal(t, 0, m.cursor)\n   424→}\n   425→\n   426→func TestStatusBarShowsCurrentSort(t *testing.T) {\n   427→\tissues := createSortTestIssues()\n   428→\tm := NewModel(issues, nil)\n   429→\tm.SetWindowSize(120, 24)\n   430→\n   431→\tview := m.View()\n   432→\n   433→\t// Status bar should show current sort field and order\n   434→\tassert.Contains(t, view, \"Updated\")\n   435→\tassert.Contains(t, view, \"↓\") // Descending indicator\n   436→}\n   437→\n   438→func TestStatusBarShowsAscendingIndicator(t *testing.T) {\n   439→\tissues := createSortTestIssues()\n   440→\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n   441→\tm.SetWindowSize(120, 24)\n   442→\n   443→\tview := m.View()\n   444→\n   445→\tassert.Contains(t, view, \"Number\")\n   446→\tassert.Contains(t, view, \"↑\") // Ascending indicator\n   447→}\n   448→\n   449→func TestGetSortConfig(t *testing.T) {\n   450→\tissues := createSortTestIssues()\n   451→\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n   452→\n   453→\tfield, order := m.GetSortConfig()\n   454→\n   455→\tassert.Equal(t, config.SortByComments, field)\n   456→\tassert.Equal(t, config.SortAsc, order)\n   457→}\n   458→\n   459→func TestSortChangedInitiallyFalse(t *testing.T) {\n   460→\tissues := createSortTestIssues()\n   461→\tm := NewModel(issues, nil)\n   462→\n   463→\tassert.False(t, m.SortChanged())\n   464→}\n   465→\n   466→func TestSortChangedAfterCycleField(t *testing.T) {\n   467→\tissues := createSortTestIssues()\n   468→\tm := NewModel(issues, nil)\n   469→\n   470→\t// Press 's' to cycle sort field\n   471→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n   472→\tm = newModel.(Model)\n   473→\n   474→\tassert.True(t, m.SortChanged())\n   475→}\n   476→\n   477→func TestSortChangedAfterToggleOrder(t *testing.T) {\n   478→\tissues := createSortTestIssues()\n   479→\tm := NewModel(issues, nil)\n   480→\n   481→\t// Press 'S' to toggle sort order\n   482→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n   483→\tm = newModel.(Model)\n   484→\n   485→\tassert.True(t, m.SortChanged())\n   486→}\n   487→\n   488→// Helper to create test issues with body content for detail view tests\n   489→func createDetailTestIssues() []github.Issue {\n   490→\treturn []github.Issue{\n   491→\t\t{\n   492→\t\t\tNumber:       42,\n   493→\t\t\tTitle:        \"Test issue with markdown body\",\n   494→\t\t\tBody:         \"## Description\\n\\nThis is a **bold** description with `code`.\\n\\n- Item 1\\n- Item 2\",\n   495→\t\t\tAuthor:       github.User{Login: \"testuser\"},\n   496→\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n   497→\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n   498→\t\t\tCommentCount: 5,\n   499→\t\t\tLabels:       []github.Label{{Name: \"bug\", Color: \"d73a4a\"}, {Name: \"priority\", Color: \"0052cc\"}},\n   500→\t\t\tAssignees:    []github.User{{Login: \"assignee1\"}, {Login: \"assignee2\"}},\n   501→\t\t},\n   502→\t\t{\n   503→\t\t\tNumber:       43,\n   504→\t\t\tTitle:        \"Another issue\",\n   505→\t\t\tBody:         \"Simple body text\",\n   506→\t\t\tAuthor:       github.User{Login: \"user2\"},\n   507→\t\t\tCreatedAt:    \"2024-01-16T10:30:00Z\",\n   508→\t\t\tUpdatedAt:    \"2024-01-21T14:45:00Z\",\n   509→\t\t\tCommentCount: 0,\n   510→\t\t\tLabels:       nil,\n   511→\t\t\tAssignees:    nil,\n   512→\t\t},\n   513→\t}\n   514→}\n   515→\n   516→func TestDetailPanelShowsSelectedIssue(t *testing.T) {\n   517→\tissues := createDetailTestIssues()\n   518→\tm := NewModel(issues, nil)\n   519→\tm.SetWindowSize(120, 30)\n   520→\n   521→\tview := m.View()\n   522→\n   523→\t// Detail panel should show the selected issue info\n   524→\t// Issue 43 is first because it has a more recent UpdatedAt date\n   525→\tassert.Contains(t, view, \"#43\")\n   526→\tassert.Contains(t, view, \"Another issue\")\n   527→\tassert.Contains(t, view, \"user2\")\n   528→}\n   529→\n   530→func TestDetailPanelShowsHeader(t *testing.T) {\n   531→\tissues := createDetailTestIssues()\n   532→\tm := NewModel(issues, nil)\n   533→\tm.SetWindowSize(120, 30)\n   534→\n   535→\t// Select issue 42 (second in sorted order)\n   536→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   537→\tm = newModel.(Model)\n   538→\n   539→\tview := m.View()\n   540→\n   541→\t// Header should show: issue number, title, author, status indicators\n   542→\tassert.Contains(t, view, \"#42\")\n   543→\tassert.Contains(t, view, \"Test issue with markdown body\")\n   544→\tassert.Contains(t, view, \"testuser\")\n   545→}\n   546→\n   547→func TestDetailPanelShowsDates(t *testing.T) {\n   548→\tissues := createDetailTestIssues()\n   549→\tm := NewModel(issues, nil)\n   550→\tm.SetWindowSize(120, 30)\n   551→\n   552→\t// Select issue 42 (second in sorted order)\n   553→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   554→\tm = newModel.(Model)\n   555→\n   556→\tview := m.View()\n   557→\n   558→\t// Should show created and updated dates\n   559→\tassert.Contains(t, view, \"2024-01-15\")\n   560→\tassert.Contains(t, view, \"2024-01-20\")\n   561→}\n   562→\n   563→func TestDetailPanelShowsLabels(t *testing.T) {\n   564→\tissues := createDetailTestIssues()\n   565→\tm := NewModel(issues, nil)\n   566→\tm.SetWindowSize(120, 30)\n   567→\n   568→\t// Select issue 42 (second in sorted order)\n   569→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   570→\tm = newModel.(Model)\n   571→\n   572→\tview := m.View()\n   573→\n   574→\t// Should show labels\n   575→\tassert.Contains(t, view, \"bug\")\n   576→\tassert.Contains(t, view, \"priority\")\n   577→}\n   578→\n   579→func TestDetailPanelShowsAssignees(t *testing.T) {\n   580→\tissues := createDetailTestIssues()\n   581→\tm := NewModel(issues, nil)\n   582→\tm.SetWindowSize(120, 30)\n   583→\n   584→\t// Select issue 42 (second in sorted order)\n   585→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   586→\tm = newModel.(Model)\n   587→\n   588→\tview := m.View()\n   589→\n   590→\t// Should show assignees\n   591→\tassert.Contains(t, view, \"assignee1\")\n   592→\tassert.Contains(t, view, \"assignee2\")\n   593→}\n   594→\n   595→func TestDetailPanelShowsBody(t *testing.T) {\n   596→\tissues := createDetailTestIssues()\n   597→\tm := NewModel(issues, nil)\n   598→\tm.SetWindowSize(120, 30)\n   599→\n   600→\t// Select issue 42 (second in sorted order)\n   601→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   602→\tm = newModel.(Model)\n   603→\n   604→\tview := m.View()\n   605→\n   606→\t// Should show body content (rendered markdown may have transformed text)\n   607→\tassert.Contains(t, view, \"Description\")\n   608→}\n   609→\n   610→func TestDetailPanelToggleRawMarkdown(t *testing.T) {\n   611→\tissues := createDetailTestIssues()\n   612→\tm := NewModel(issues, nil)\n   613→\tm.SetWindowSize(120, 30)\n   614→\n   615→\t// Select issue 42 (second in sorted order)\n   616→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n   617→\tm = newModel.(Model)\n   618→\n   619→\t// Initial state should be rendered markdown\n   620→\tassert.False(t, m.IsRawMarkdown())\n   621→\n   622→\t// Press 'm' to toggle to raw markdown\n   623→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n   624→\tm = newModel.(Model)\n   625→\n   626→\tassert.True(t, m.IsRawMarkdown())\n   627→\tview := m.View()\n   628→\t// Raw view should contain markdown syntax\n   629→\tassert.Contains(t, view, \"**bold**\")\n   630→\tassert.Contains(t, view, \"`code`\")\n   631→\n   632→\t// Press 'm' again to toggle back to rendered\n   633→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n   634→\tm = newModel.(Model)\n   635→\n   636→\tassert.False(t, m.IsRawMarkdown())\n   637→}\n   638→\n   639→func TestDetailPanelScroll(t *testing.T) {\n   640→\t// Create an issue with a long body\n   641→\tissues := []github.Issue{\n   642→\t\t{\n   643→\t\t\tNumber:       1,\n   644→\t\t\tTitle:        \"Long issue\",\n   645→\t\t\tBody:         \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\\nLine 11\\nLine 12\\nLine 13\\nLine 14\\nLine 15\\nLine 16\\nLine 17\\nLine 18\\nLine 19\\nLine 20\",\n   646→\t\t\tAuthor:       github.User{Login: \"testuser\"},\n   647→\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n   648→\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n   649→\t\t\tCommentCount: 0,\n   650→\t\t},\n   651→\t}\n   652→\n   653→\tm := NewModel(issues, nil)\n   654→\tm.SetWindowSize(120, 15) // Small height to trigger scrolling\n   655→\n   656→\t// Initial scroll should be at 0\n   657→\tassert.Equal(t, 0, m.DetailScrollOffset())\n   658→\n   659→\t// Press 'l' to scroll down in the detail panel\n   660→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n   661→\tm = newModel.(Model)\n   662→\n   663→\tassert.Greater(t, m.DetailScrollOffset(), 0)\n   664→\n   665→\t// Press 'h' to scroll up in the detail panel\n   666→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n   667→\tm = newModel.(Model)\n   668→\n   669→\tassert.Equal(t, 0, m.DetailScrollOffset())\n   670→}\n   671→\n   672→func TestEnterKeyOpensCommentsView(t *testing.T) {\n   673→\tissues := createDetailTestIssues()\n   674→\tm := NewModel(issues, nil)\n   675→\tm.SetWindowSize(120, 30)\n   676→\n   677→\t// Initial state: not in comments view\n   678→\tassert.False(t, m.InCommentsView())\n   679→\n   680→\t// Press Enter to open comments view\n   681→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   682→\tm = newModel.(Model)\n   683→\n   684→\tassert.True(t, m.InCommentsView())\n   685→\n   686→\t// Press Escape to go back\n   687→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n   688→\tm = newModel.(Model)\n   689→\n   690→\tassert.False(t, m.InCommentsView())\n   691→}\n   692→\n   693→func TestDetailPanelNoLabelsOrAssignees(t *testing.T) {\n   694→\tissues := createDetailTestIssues()\n   695→\tm := NewModel(issues, nil)\n   696→\tm.SetWindowSize(120, 30)\n   697→\n   698→\t// Issue 43 is first (more recent UpdatedAt) and has no labels or assignees\n   699→\tview := m.View()\n   700→\n   701→\t// Should still render without crashing, just not show label/assignee sections\n   702→\tassert.Contains(t, view, \"#43\")\n   703→\tassert.Contains(t, view, \"Another issue\")\n   704→}\n   705→\n   706→// Helper to create test comments\n   707→func createTestComments() []github.Comment {\n   708→\treturn []github.Comment{\n   709→\t\t{\n   710→\t\t\tID:        \"comment1\",\n   711→\t\t\tBody:      \"This is the **first** comment with `code`.\",\n   712→\t\t\tAuthor:    github.User{Login: \"commenter1\"},\n   713→\t\t\tCreatedAt: \"2024-01-10T10:00:00Z\",\n   714→\t\t},\n   715→\t\t{\n   716→\t\t\tID:        \"comment2\",\n   717→\t\t\tBody:      \"Second comment here.\",\n   718→\t\t\tAuthor:    github.User{Login: \"commenter2\"},\n   719→\t\t\tCreatedAt: \"2024-01-11T14:30:00Z\",\n   720→\t\t},\n   721→\t\t{\n   722→\t\t\tID:        \"comment3\",\n   723→\t\t\tBody:      \"Third comment with more details.\\n\\n- Point 1\\n- Point 2\",\n   724→\t\t\tAuthor:    github.User{Login: \"commenter3\"},\n   725→\t\t\tCreatedAt: \"2024-01-12T09:15:00Z\",\n   726→\t\t},\n   727→\t}\n   728→}\n   729→\n   730→func TestSetComments(t *testing.T) {\n   731→\tissues := createDetailTestIssues()\n   732→\tm := NewModel(issues, nil)\n   733→\n   734→\tcomments := createTestComments()\n   735→\tm.SetComments(comments)\n   736→\n   737→\tassert.Equal(t, 3, len(m.GetComments()))\n   738→}\n   739→\n   740→func TestCommentsViewShowsIssueHeader(t *testing.T) {\n   741→\tissues := createDetailTestIssues()\n   742→\tm := NewModel(issues, nil)\n   743→\tm.SetWindowSize(120, 30)\n   744→\tm.SetComments(createTestComments())\n   745→\n   746→\t// Press Enter to open comments view\n   747→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   748→\tm = newModel.(Model)\n   749→\n   750→\tview := m.View()\n   751→\n   752→\t// Comments view should replace main interface (no issue list panel)\n   753→\t// and show issue title/number as header\n   754→\tassert.True(t, m.InCommentsView())\n   755→\tassert.Contains(t, view, \"#43\") // Issue number\n   756→\tassert.Contains(t, view, \"Another issue\") // Issue title\n   757→}\n   758→\n   759→func TestCommentsViewShowsCommentsChronologically(t *testing.T) {\n   760→\tissues := createDetailTestIssues()\n   761→\tm := NewModel(issues, nil)\n   762→\tm.SetWindowSize(120, 40)\n   763→\tm.SetComments(createTestComments())\n   764→\n   765→\t// Press Enter to open comments view\n   766→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   767→\tm = newModel.(Model)\n   768→\n   769→\tview := m.View()\n   770→\n   771→\t// Comments should be displayed chronologically\n   772→\t// Check that all comment authors are visible\n   773→\tassert.Contains(t, view, \"commenter1\")\n   774→\tassert.Contains(t, view, \"commenter2\")\n   775→\tassert.Contains(t, view, \"commenter3\")\n   776→}\n   777→\n   778→func TestCommentsViewShowsCommentDate(t *testing.T) {\n   779→\tissues := createDetailTestIssues()\n   780→\tm := NewModel(issues, nil)\n   781→\tm.SetWindowSize(120, 40)\n   782→\tm.SetComments(createTestComments())\n   783→\n   784→\t// Press Enter to open comments view\n   785→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   786→\tm = newModel.(Model)\n   787→\n   788→\tview := m.View()\n   789→\n   790→\t// Comments should show dates\n   791→\tassert.Contains(t, view, \"2024-01-10\")\n   792→\tassert.Contains(t, view, \"2024-01-11\")\n   793→\tassert.Contains(t, view, \"2024-01-12\")\n   794→}\n   795→\n   796→func TestCommentsViewShowsCommentBody(t *testing.T) {\n   797→\tissues := createDetailTestIssues()\n   798→\tm := NewModel(issues, nil)\n   799→\tm.SetWindowSize(120, 40)\n   800→\tm.SetComments(createTestComments())\n   801→\n   802→\t// Press Enter to open comments view\n   803→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   804→\tm = newModel.(Model)\n   805→\n   806→\tview := m.View()\n   807→\n   808→\t// Comments should show body content\n   809→\tassert.Contains(t, view, \"first\")\n   810→\tassert.Contains(t, view, \"Second comment\")\n   811→}\n   812→\n   813→func TestCommentsViewToggleMarkdown(t *testing.T) {\n   814→\tissues := createDetailTestIssues()\n   815→\tm := NewModel(issues, nil)\n   816→\tm.SetWindowSize(120, 40)\n   817→\tm.SetComments(createTestComments())\n   818→\n   819→\t// Press Enter to open comments view\n   820→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   821→\tm = newModel.(Model)\n   822→\n   823→\t// Default is rendered markdown\n   824→\tassert.False(t, m.IsRawMarkdown())\n   825→\n   826→\t// Press 'm' to toggle to raw markdown\n   827→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n   828→\tm = newModel.(Model)\n   829→\n   830→\tassert.True(t, m.IsRawMarkdown())\n   831→\tview := m.View()\n   832→\t// Raw view should contain markdown syntax\n   833→\tassert.Contains(t, view, \"**first**\")\n   834→\tassert.Contains(t, view, \"`code`\")\n   835→\n   836→\t// Press 'm' again to toggle back\n   837→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n   838→\tm = newModel.(Model)\n   839→\n   840→\tassert.False(t, m.IsRawMarkdown())\n   841→}\n   842→\n   843→func TestCommentsViewScrollable(t *testing.T) {\n   844→\tissues := createDetailTestIssues()\n   845→\tm := NewModel(issues, nil)\n   846→\tm.SetWindowSize(120, 15) // Small height to test scrolling\n   847→\n   848→\t// Create many comments to test scrolling\n   849→\tmanyComments := []github.Comment{}\n   850→\tfor i := 0; i < 20; i++ {\n   851→\t\tmanyComments = append(manyComments, github.Comment{\n   852→\t\t\tID:        fmt.Sprintf(\"comment%d\", i),\n   853→\t\t\tBody:      fmt.Sprintf(\"Comment %d body text\", i),\n   854→\t\t\tAuthor:    github.User{Login: fmt.Sprintf(\"user%d\", i)},\n   855→\t\t\tCreatedAt: fmt.Sprintf(\"2024-01-%02dT10:00:00Z\", i+1),\n   856→\t\t})\n   857→\t}\n   858→\tm.SetComments(manyComments)\n   859→\n   860→\t// Press Enter to open comments view\n   861→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   862→\tm = newModel.(Model)\n   863→\n   864→\t// Initial scroll should be 0\n   865→\tassert.Equal(t, 0, m.CommentsScrollOffset())\n   866→\n   867→\t// Press 'l' to scroll down\n   868→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n   869→\tm = newModel.(Model)\n   870→\n   871→\tassert.Greater(t, m.CommentsScrollOffset(), 0)\n   872→\n   873→\t// Press 'h' to scroll back up\n   874→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n   875→\tm = newModel.(Model)\n   876→\n   877→\tassert.Equal(t, 0, m.CommentsScrollOffset())\n   878→}\n   879→\n   880→func TestCommentsViewEscapeReturnsToIssueList(t *testing.T) {\n   881→\tissues := createDetailTestIssues()\n   882→\tm := NewModel(issues, nil)\n   883→\tm.SetWindowSize(120, 30)\n   884→\tm.SetComments(createTestComments())\n   885→\n   886→\t// Press Enter to open comments view\n   887→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   888→\tm = newModel.(Model)\n   889→\n   890→\tassert.True(t, m.InCommentsView())\n   891→\n   892→\t// Press Escape to return to issue list\n   893→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n   894→\tm = newModel.(Model)\n   895→\n   896→\tassert.False(t, m.InCommentsView())\n   897→}\n   898→\n   899→func TestCommentsViewQKeyReturnsToIssueList(t *testing.T) {\n   900→\tissues := createDetailTestIssues()\n   901→\tm := NewModel(issues, nil)\n   902→\tm.SetWindowSize(120, 30)\n   903→\tm.SetComments(createTestComments())\n   904→\n   905→\t// Press Enter to open comments view\n   906→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   907→\tm = newModel.(Model)\n   908→\n   909→\tassert.True(t, m.InCommentsView())\n   910→\n   911→\t// Press 'q' to return to issue list (not quit the app when in comments view)\n   912→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n   913→\tm = newModel.(Model)\n   914→\n   915→\tassert.False(t, m.InCommentsView())\n   916→}\n   917→\n   918→func TestCommentsViewEmptyState(t *testing.T) {\n   919→\tissues := createDetailTestIssues()\n   920→\tm := NewModel(issues, nil)\n   921→\tm.SetWindowSize(120, 30)\n   922→\t// No comments set\n   923→\n   924→\t// Press Enter to open comments view\n   925→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   926→\tm = newModel.(Model)\n   927→\n   928→\tview := m.View()\n   929→\n   930→\t// Should show a message when there are no comments\n   931→\tassert.Contains(t, view, \"No comments\")\n   932→}\n   933→\n   934→func TestCommentsViewReplacesMainInterface(t *testing.T) {\n   935→\tissues := createDetailTestIssues()\n   936→\tm := NewModel(issues, nil)\n   937→\tm.SetWindowSize(120, 30)\n   938→\tm.SetComments(createTestComments())\n   939→\n   940→\t// Before entering comments view, should see the issue list\n   941→\tview := m.View()\n   942→\tassert.Contains(t, view, \"#\") // Issue list column header\n   943→\n   944→\t// Press Enter to open comments view\n   945→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n   946→\tm = newModel.(Model)\n   947→\n   948→\tview = m.View()\n   949→\n   950→\t// Comments view should be a drill-down (full screen), not split panel\n   951→\t// The issue list should not be visible\n   952→\t// Check that the comments header is present\n   953→\tassert.Contains(t, view, \"Comments\")\n   954→}\n   955→\n   956→// Tests for Data Refresh functionality (US-009)\n   957→\n   958→func TestRefreshKeyRTriggersRefresh(t *testing.T) {\n   959→\tissues := createTestIssues()\n   960→\tm := NewModel(issues, nil)\n   961→\tm.SetWindowSize(120, 30)\n   962→\n   963→\t// Set a mock refresh function\n   964→\trefreshCalled := false\n   965→\tm.SetRefreshFunc(func() tea.Msg {\n   966→\t\trefreshCalled = true\n   967→\t\treturn RefreshDoneMsg{Issues: issues}\n   968→\t})\n   969→\n   970→\t// Initially not refreshing\n   971→\tassert.False(t, m.IsRefreshing())\n   972→\n   973→\t// Press 'r' to trigger refresh\n   974→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n   975→\tm = newModel.(Model)\n   976→\n   977→\t// Should set refreshing state\n   978→\tassert.True(t, m.IsRefreshing())\n   979→\t// Should return a command to start the refresh\n   980→\tassert.NotNil(t, cmd)\n   981→\t// Execute the command to verify it was called\n   982→\tcmd()\n   983→\tassert.True(t, refreshCalled)\n   984→}\n   985→\n   986→func TestRefreshKeyRUpperCaseTriggersRefresh(t *testing.T) {\n   987→\tissues := createTestIssues()\n   988→\tm := NewModel(issues, nil)\n   989→\tm.SetWindowSize(120, 30)\n   990→\n   991→\t// Set a mock refresh function\n   992→\tm.SetRefreshFunc(func() tea.Msg {\n   993→\t\treturn RefreshDoneMsg{Issues: issues}\n   994→\t})\n   995→\n   996→\t// Press 'R' (uppercase) to trigger refresh\n   997→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'R'}})\n   998→\tm = newModel.(Model)\n   999→\n  1000→\tassert.True(t, m.IsRefreshing())\n  1001→\tassert.NotNil(t, cmd)\n  1002→}\n  1003→\n  1004→func TestRefreshKeyIgnoredWhileRefreshing(t *testing.T) {\n  1005→\tissues := createTestIssues()\n  1006→\tm := NewModel(issues, nil)\n  1007→\tm.SetWindowSize(120, 30)\n  1008→\n  1009→\t// Set a mock refresh function\n  1010→\tm.SetRefreshFunc(func() tea.Msg {\n  1011→\t\treturn RefreshDoneMsg{Issues: issues}\n  1012→\t})\n  1013→\n  1014→\t// Start a refresh\n  1015→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1016→\tm = newModel.(Model)\n  1017→\n  1018→\t// Try to trigger another refresh while already refreshing\n  1019→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1020→\tm = newModel.(Model)\n  1021→\n  1022→\t// Should still be refreshing, but no new command\n  1023→\tassert.True(t, m.IsRefreshing())\n  1024→\tassert.Nil(t, cmd) // No additional command should be returned\n  1025→}\n  1026→\n  1027→func TestRefreshKeyIgnoredInCommentsView(t *testing.T) {\n  1028→\tissues := createTestIssues()\n  1029→\tm := NewModel(issues, nil)\n  1030→\tm.SetWindowSize(120, 30)\n  1031→\n  1032→\t// Enter comments view\n  1033→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n  1034→\tm = newModel.(Model)\n  1035→\n  1036→\tassert.True(t, m.InCommentsView())\n  1037→\n  1038→\t// Press 'r' - should not trigger refresh while in comments view\n  1039→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1040→\tm = newModel.(Model)\n  1041→\n  1042→\tassert.False(t, m.IsRefreshing())\n  1043→\tassert.Nil(t, cmd)\n  1044→}\n  1045→\n  1046→func TestRefreshProgressMsgUpdatesProgress(t *testing.T) {\n  1047→\tissues := createTestIssues()\n  1048→\tm := NewModel(issues, nil)\n  1049→\tm.SetWindowSize(120, 30)\n  1050→\n  1051→\t// Start refresh\n  1052→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1053→\tm = newModel.(Model)\n  1054→\n  1055→\t// Simulate progress message\n  1056→\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n  1057→\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n  1058→\tm = newModel.(Model)\n  1059→\n  1060→\t// Check progress is tracked\n  1061→\tcurrentProgress := m.GetRefreshProgress()\n  1062→\tassert.Equal(t, \"issues\", currentProgress.Phase)\n  1063→\tassert.Equal(t, 5, currentProgress.Current)\n  1064→\tassert.Equal(t, 10, currentProgress.Total)\n  1065→}\n  1066→\n  1067→func TestRefreshDoneMsgUpdatesIssues(t *testing.T) {\n  1068→\tissues := createTestIssues()\n  1069→\tm := NewModel(issues, nil)\n  1070→\tm.SetWindowSize(120, 30)\n  1071→\n  1072→\t// Start refresh\n  1073→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1074→\tm = newModel.(Model)\n  1075→\n  1076→\tassert.True(t, m.IsRefreshing())\n  1077→\n  1078→\t// New issues from refresh\n  1079→\tnewIssues := []github.Issue{\n  1080→\t\t{\n  1081→\t\t\tNumber:       100,\n  1082→\t\t\tTitle:        \"New issue\",\n  1083→\t\t\tAuthor:       github.User{Login: \"newuser\"},\n  1084→\t\t\tCreatedAt:    \"2024-02-01T12:00:00Z\",\n  1085→\t\t\tUpdatedAt:    \"2024-02-01T12:00:00Z\",\n  1086→\t\t\tCommentCount: 0,\n  1087→\t\t},\n  1088→\t}\n  1089→\n  1090→\t// Simulate refresh done message\n  1091→\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: newIssues})\n  1092→\tm = newModel.(Model)\n  1093→\n  1094→\t// Should no longer be refreshing\n  1095→\tassert.False(t, m.IsRefreshing())\n  1096→\t// Issues should be updated\n  1097→\tassert.Equal(t, 1, m.IssueCount())\n  1098→\tassert.Equal(t, 100, m.issues[0].Number)\n  1099→}\n  1100→\n  1101→func TestRefreshErrorMsgStopsRefreshing(t *testing.T) {\n  1102→\tissues := createTestIssues()\n  1103→\tm := NewModel(issues, nil)\n  1104→\tm.SetWindowSize(120, 30)\n  1105→\n  1106→\t// Start refresh\n  1107→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1108→\tm = newModel.(Model)\n  1109→\n  1110→\t// Simulate error message\n  1111→\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n  1112→\tm = newModel.(Model)\n  1113→\n  1114→\t// Should no longer be refreshing\n  1115→\tassert.False(t, m.IsRefreshing())\n  1116→\t// Error should be tracked\n  1117→\tassert.Equal(t, \"network error\", m.GetRefreshError())\n  1118→\t// Original issues should remain\n  1119→\tassert.Equal(t, 3, m.IssueCount())\n  1120→}\n  1121→\n  1122→func TestStatusBarShowsRefreshingIndicator(t *testing.T) {\n  1123→\tissues := createTestIssues()\n  1124→\tm := NewModel(issues, nil)\n  1125→\tm.SetWindowSize(120, 30)\n  1126→\n  1127→\t// Start refresh\n  1128→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1129→\tm = newModel.(Model)\n  1130→\n  1131→\tview := m.View()\n  1132→\n  1133→\t// Status bar should show refreshing indicator\n  1134→\tassert.Contains(t, view, \"Refreshing\")\n  1135→}\n  1136→\n  1137→func TestStatusBarShowsRefreshProgress(t *testing.T) {\n  1138→\tissues := createTestIssues()\n  1139→\tm := NewModel(issues, nil)\n  1140→\tm.SetWindowSize(120, 30)\n  1141→\n  1142→\t// Start refresh\n  1143→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1144→\tm = newModel.(Model)\n  1145→\n  1146→\t// Simulate progress message\n  1147→\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n  1148→\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n  1149→\tm = newModel.(Model)\n  1150→\n  1151→\tview := m.View()\n  1152→\n  1153→\t// Status bar should show progress\n  1154→\tassert.Contains(t, view, \"5/10\")\n  1155→}\n  1156→\n  1157→func TestRefreshClearsErrorOnNewRefresh(t *testing.T) {\n  1158→\tissues := createTestIssues()\n  1159→\tm := NewModel(issues, nil)\n  1160→\tm.SetWindowSize(120, 30)\n  1161→\n  1162→\t// Set a mock refresh function\n  1163→\tm.SetRefreshFunc(func() tea.Msg {\n  1164→\t\treturn RefreshDoneMsg{Issues: issues}\n  1165→\t})\n  1166→\n  1167→\t// Start and fail a refresh\n  1168→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1169→\tm = newModel.(Model)\n  1170→\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n  1171→\tm = newModel.(Model)\n  1172→\n  1173→\tassert.NotEmpty(t, m.GetRefreshError())\n  1174→\n  1175→\t// Start a new refresh\n  1176→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1177→\tm = newModel.(Model)\n  1178→\n  1179→\t// Error should be cleared\n  1180→\tassert.Empty(t, m.GetRefreshError())\n  1181→}\n  1182→\n  1183→func TestRefreshMaintainsCursorOnSameIssue(t *testing.T) {\n  1184→\tissues := createTestIssues()\n  1185→\tm := NewModel(issues, nil)\n  1186→\tm.SetWindowSize(120, 30)\n  1187→\n  1188→\t// Move cursor to issue #2 (second in sorted order after applying default sort)\n  1189→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n  1190→\tm = newModel.(Model)\n  1191→\n  1192→\tselectedBefore := m.SelectedIssue()\n  1193→\trequire.NotNil(t, selectedBefore)\n  1194→\tselectedNumber := selectedBefore.Number\n  1195→\n  1196→\t// Start refresh\n  1197→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1198→\tm = newModel.(Model)\n  1199→\n  1200→\t// Complete refresh with same issues\n  1201→\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues()})\n  1202→\tm = newModel.(Model)\n  1203→\n  1204→\t// Cursor should still be on the same issue\n  1205→\tselectedAfter := m.SelectedIssue()\n  1206→\trequire.NotNil(t, selectedAfter)\n  1207→\tassert.Equal(t, selectedNumber, selectedAfter.Number)\n  1208→}\n  1209→\n  1210→// Tests for Error Handling (US-013)\n  1211→\n  1212→func TestMinorErrorShownInStatusBar(t *testing.T) {\n  1213→\tissues := createTestIssues()\n  1214→\tm := NewModel(issues, nil)\n  1215→\tm.SetWindowSize(120, 30)\n  1216→\n  1217→\t// Simulate a minor error (network timeout)\n  1218→\tm.SetRefreshFunc(func() tea.Msg {\n  1219→\t\treturn RefreshDoneMsg{Issues: issues}\n  1220→\t})\n  1221→\n  1222→\t// Start refresh\n  1223→\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1224→\tm = newModel.(Model)\n  1225→\n  1226→\t// Simulate a network timeout error (minor)\n  1227→\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network timeout: connection timed out\")})\n  1228→\tm = newModel.(Model)\n  1229→\n  1230→\t// Error should be shown in status bar, not as modal\n  1231→\tassert.False(t, m.HasErrorModal())\n  1232→\tassert.NotEmpty(t, m.GetRefreshError())\n  1233→\n  1234→\tview := m.View()\n  1235→\t// Status bar should show error\n  1236→\tassert.Contains(t, view, \"timeout\")\n  1237→}\n  1238→\n  1239→func TestMinorErrorSuggestsRetry(t *testing.T) {\n  1240→\tissues := createTestIssues()\n  1241→\tm := NewModel(issues, nil)\n  1242→\tm.SetWindowSize(120, 30)\n  1243→\n  1244→\t// Simulate a network error\n  1245→\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error: dial tcp: no route to host\")})\n  1246→\tm = newModel.(Model)\n  1247→\n  1248→\tview := m.View()\n  1249→\n  1250→\t// Should show actionable guidance - suggest retry\n  1251→\tassert.Contains(t, view, \"r: retry\")\n  1252→}\n  1253→\n  1254→func TestRateLimitErrorShownInStatusBar(t *testing.T) {\n  1255→\tissues := createTestIssues()\n  1256→\tm := NewModel(issues, nil)\n  1257→\tm.SetWindowSize(120, 30)\n  1258→\n  1259→\t// Simulate a rate limit error (minor)\n  1260→\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"GitHub API error: 403 rate limit exceeded\")})\n  1261→\tm = newModel.(Model)\n  1262→\n  1263→\t// Should be shown in status bar, not modal\n  1264→\tassert.False(t, m.HasErrorModal())\n  1265→\tassert.Contains(t, m.GetRefreshError(), \"rate limit\")\n  1266→}\n  1267→\n  1268→func TestCriticalErrorShowsModal(t *testing.T) {\n  1269→\tissues := createTestIssues()\n  1270→\tm := NewModel(issues, nil)\n  1271→\tm.SetWindowSize(120, 30)\n  1272→\n  1273→\t// Simulate a critical error (invalid token)\n  1274→\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized)\")\n  1275→\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Authentication Error\"})\n  1276→\tm = newModel.(Model)\n  1277→\n  1278→\t// Should show modal\n  1279→\tassert.True(t, m.HasErrorModal())\n  1280→\tassert.Equal(t, \"Authentication Error\", m.GetErrorModalTitle())\n  1281→\tassert.Contains(t, m.GetErrorModalMessage(), \"invalid\")\n  1282→}\n  1283→\n  1284→func TestCriticalErrorModalRequiresAcknowledgment(t *testing.T) {\n  1285→\tissues := createTestIssues()\n  1286→\tm := NewModel(issues, nil)\n  1287→\tm.SetWindowSize(120, 30)\n  1288→\n  1289→\t// Show critical error modal\n  1290→\terr := fmt.Errorf(\"database corruption: file is not a database\")\n  1291→\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Database Error\"})\n  1292→\tm = newModel.(Model)\n  1293→\n  1294→\tassert.True(t, m.HasErrorModal())\n  1295→\n  1296→\t// Navigation keys should not work while modal is shown\n  1297→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n  1298→\tm = newModel.(Model)\n  1299→\tassert.True(t, m.HasErrorModal()) // Modal still shown\n  1300→\n  1301→\t// Press Enter to acknowledge\n  1302→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n  1303→\tm = newModel.(Model)\n  1304→\n  1305→\t// Modal should be dismissed\n  1306→\tassert.False(t, m.HasErrorModal())\n  1307→}\n  1308→\n  1309→func TestCriticalErrorModalDismissedWithEscape(t *testing.T) {\n  1310→\tissues := createTestIssues()\n  1311→\tm := NewModel(issues, nil)\n  1312→\tm.SetWindowSize(120, 30)\n  1313→\n  1314→\t// Show critical error modal\n  1315→\terr := fmt.Errorf(\"invalid token\")\n  1316→\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Auth Error\"})\n  1317→\tm = newModel.(Model)\n  1318→\n  1319→\tassert.True(t, m.HasErrorModal())\n  1320→\n  1321→\t// Press Escape to dismiss\n  1322→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n  1323→\tm = newModel.(Model)\n  1324→\n  1325→\tassert.False(t, m.HasErrorModal())\n  1326→}\n  1327→\n  1328→func TestErrorModalViewRendering(t *testing.T) {\n  1329→\tissues := createTestIssues()\n  1330→\tm := NewModel(issues, nil)\n  1331→\tm.SetWindowSize(120, 30)\n  1332→\n  1333→\t// Show critical error modal with actionable guidance\n  1334→\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized). Please check that your token is correct and has not expired\")\n  1335→\tnewModel, _ := m.Update(CriticalErrorMsg{\n  1336→\t\tErr:      err,\n  1337→\t\tTitle:    \"Authentication Error\",\n  1338→\t\tGuidance: \"Run 'ghissues config' to update your authentication settings.\",\n  1339→\t})\n  1340→\tm = newModel.(Model)\n  1341→\n  1342→\tview := m.View()\n  1343→\n  1344→\t// Modal should be visible\n  1345→\tassert.Contains(t, view, \"Authentication Error\")\n  1346→\tassert.Contains(t, view, \"Unauthorized\")\n  1347→\t// Should show actionable guidance\n  1348→\tassert.Contains(t, view, \"ghissues config\")\n  1349→\t// Should show dismissal instructions\n  1350→\tassert.Contains(t, view, \"Enter\")\n  1351→}\n  1352→\n  1353→func TestDatabaseErrorShowsModal(t *testing.T) {\n  1354→\tissues := createTestIssues()\n  1355→\tm := NewModel(issues, nil)\n  1356→\tm.SetWindowSize(120, 30)\n  1357→\n  1358→\t// Database corruption is a critical error\n  1359→\terr := fmt.Errorf(\"database error: file is not a database\")\n  1360→\tnewModel, _ := m.Update(CriticalErrorMsg{\n  1361→\t\tErr:      err,\n  1362→\t\tTitle:    \"Database Error\",\n  1363→\t\tGuidance: \"Try deleting the database file and running 'ghissues sync' to rebuild it.\",\n  1364→\t})\n  1365→\tm = newModel.(Model)\n  1366→\n  1367→\tassert.True(t, m.HasErrorModal())\n  1368→\tview := m.View()\n  1369→\tassert.Contains(t, view, \"Database Error\")\n  1370→\tassert.Contains(t, view, \"database\")\n  1371→}\n  1372→\n  1373→func TestNavigationBlockedDuringErrorModal(t *testing.T) {\n  1374→\tissues := createTestIssues()\n  1375→\tm := NewModel(issues, nil)\n  1376→\tm.SetWindowSize(120, 30)\n  1377→\n  1378→\t// Remember initial cursor position\n  1379→\tinitialCursor := m.cursor\n  1380→\n  1381→\t// Show critical error modal\n  1382→\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n  1383→\tm = newModel.(Model)\n  1384→\n  1385→\t// Try various navigation keys\n  1386→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n  1387→\tm = newModel.(Model)\n  1388→\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n  1389→\n  1390→\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n  1391→\tm = newModel.(Model)\n  1392→\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n  1393→\n  1394→\t// 'q' should dismiss modal, not quit\n  1395→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n  1396→\tm = newModel.(Model)\n  1397→\t// Modal should be dismissed\n  1398→\tassert.False(t, m.HasErrorModal())\n  1399→\t// Should not return quit command\n  1400→\tassert.Nil(t, cmd)\n  1401→}\n  1402→\n  1403→func TestRefreshBlockedDuringErrorModal(t *testing.T) {\n  1404→\tissues := createTestIssues()\n  1405→\tm := NewModel(issues, nil)\n  1406→\tm.SetWindowSize(120, 30)\n  1407→\n  1408→\t// Set refresh function\n  1409→\tm.SetRefreshFunc(func() tea.Msg {\n  1410→\t\treturn RefreshDoneMsg{Issues: issues}\n  1411→\t})\n  1412→\n  1413→\t// Show critical error modal\n  1414→\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n  1415→\tm = newModel.(Model)\n  1416→\n  1417→\t// Try to trigger refresh while modal is shown\n  1418→\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n  1419→\tm = newModel.(Model)\n  1420→\n  1421→\t// Should not start refreshing\n  1422→\tassert.False(t, m.IsRefreshing())\n  1423→\tassert.Nil(t, cmd)\n  1424→}\n  1425→\n  1426→func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n  1427→\tissues := createTestIssues()\n  1428→\tm := NewModel(issues, nil)\n  1429→\tm.SetWindowSize(140, 30) // Wider to see full message\n  1430→\n  1431→\t// Network error\n  1432→\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n  1433→\tm = newModel.(Model)\n  1434→\n  1435→\tview := m.View()\n  1436→\n  1437→\t// Should suggest checking connectivity (part of the standard error display)\n  1438→\t// The error message and retry option should be visible\n  1439→\tassert.Contains(t, view, \"dial tcp\")\n  1440→}\n  1441→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"468095c3-93c4-4874-9350-deeed0a440a4","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go","content":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc createTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"First issue\",\n\t\t\tAuthor:       github.User{Login: \"user1\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t\t{\n\t\t\tNumber:       2,\n\t\t\tTitle:        \"Second issue\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-02T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-16T12:00:00Z\",\n\t\t\tCommentCount: 3,\n\t\t},\n\t\t{\n\t\t\tNumber:       3,\n\t\t\tTitle:        \"Third issue\",\n\t\t\tAuthor:       github.User{Login: \"user3\"},\n\t\t\tCreatedAt:    \"2024-01-03T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-17T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n}\n\nfunc TestNewModel(t *testing.T) {\n\tissues := createTestIssues()\n\tcolumns := []string{\"number\", \"title\", \"author\"}\n\n\tm := NewModel(issues, columns)\n\n\t// Issues are sorted by updated date descending by default\n\t// createTestIssues has: 1 (Jan 15), 2 (Jan 16), 3 (Jan 17)\n\t// So sorted: 3, 2, 1\n\tassert.Equal(t, 3, m.issues[0].Number)\n\tassert.Equal(t, 2, m.issues[1].Number)\n\tassert.Equal(t, 1, m.issues[2].Number)\n\tassert.Equal(t, columns, m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestNewModelEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tassert.Empty(t, m.issues)\n\tassert.Equal(t, DefaultColumns(), m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 0, m.IssueCount())\n}\n\nfunc TestModelNavigationDown(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial cursor position\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Move down with j key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move down with down arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n\n\t// Should not go past last item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n}\n\nfunc TestModelNavigationUp(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.cursor = 2 // Start at bottom\n\n\t// Move up with k key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move up with up arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Should not go past first item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestModelQuitKeys(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// q should quit\n\t_, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\trequire.NotNil(t, cmd)\n\tmsg := cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n\n\t// Ctrl+C should quit\n\t_, cmd = m.Update(tea.KeyMsg{Type: tea.KeyCtrlC})\n\trequire.NotNil(t, cmd)\n\tmsg = cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n}\n\nfunc TestModelSelectedIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Get selected issue at cursor 0\n\t// Default sort is by updated date descending, so issue 3 is first (most recently updated)\n\tissue := m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 3, issue.Number)\n\tassert.Equal(t, \"Third issue\", issue.Title)\n\n\t// Move cursor and check again\n\tm.cursor = 1\n\tissue = m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 2, issue.Number) // Second most recently updated\n}\n\nfunc TestModelSelectedIssueEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tissue := m.SelectedIssue()\n\tassert.Nil(t, issue)\n}\n\nfunc TestModelIssueCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tissues   []github.Issue\n\t\texpected int\n\t}{\n\t\t{name: \"three issues\", issues: createTestIssues(), expected: 3},\n\t\t{name: \"empty\", issues: nil, expected: 0},\n\t\t{name: \"one issue\", issues: []github.Issue{{Number: 1}}, expected: 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tm := NewModel(tt.issues, nil)\n\t\t\tassert.Equal(t, tt.expected, m.IssueCount())\n\t\t})\n\t}\n}\n\nfunc TestModelSetWindowSize(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tm.SetWindowSize(100, 50)\n\n\tassert.Equal(t, 100, m.width)\n\tassert.Equal(t, 50, m.height)\n}\n\nfunc TestModelWindowSizeMsg(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tnewModel, _ := m.Update(tea.WindowSizeMsg{Width: 120, Height: 40})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 120, m.width)\n\tassert.Equal(t, 40, m.height)\n}\n\nfunc TestDefaultColumns(t *testing.T) {\n\tcols := DefaultColumns()\n\tassert.Equal(t, []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}, cols)\n}\n\nfunc TestModelViewContainsIssueCount(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Status area should show issue count\n\tassert.Contains(t, view, \"3 issues\")\n}\n\nfunc TestModelViewContainsSelectedHighlight(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Selected issue should be in the view\n\tassert.Contains(t, view, \"First issue\")\n}\n\nfunc TestModelViewEmptyState(t *testing.T) {\n\tm := NewModel(nil, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Should show no issues message\n\tassert.Contains(t, view, \"No issues\")\n\tassert.Contains(t, view, \"0 issues\")\n}\n\n// Helper to create test issues with varied dates and counts for sorting tests\nfunc createSortTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       10,\n\t\t\tTitle:        \"Issue ten\",\n\t\t\tAuthor:       github.User{Login: \"alice\"},\n\t\t\tCreatedAt:    \"2024-01-05T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T12:00:00Z\",\n\t\t\tCommentCount: 2,\n\t\t},\n\t\t{\n\t\t\tNumber:       5,\n\t\t\tTitle:        \"Issue five\",\n\t\t\tAuthor:       github.User{Login: \"bob\"},\n\t\t\tCreatedAt:    \"2024-01-10T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 10,\n\t\t},\n\t\t{\n\t\t\tNumber:       15,\n\t\t\tTitle:        \"Issue fifteen\",\n\t\t\tAuthor:       github.User{Login: \"charlie\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-25T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t}\n}\n\nfunc TestNewModelWithSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestDefaultSortIsUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default sort should be by updated date descending (most recently updated first)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// First issue should be the most recently updated (issue 15)\n\tselected := m.SelectedIssue()\n\trequire.NotNil(t, selected)\n\tassert.Equal(t, 15, selected.Number)\n}\n\nfunc TestSortByUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\tm.SetWindowSize(80, 24)\n\n\t// Most recently updated first: 15 (Jan 25), 10 (Jan 20), 5 (Jan 15)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByUpdatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortAsc)\n\n\t// Oldest updated first: 5 (Jan 15), 10 (Jan 20), 15 (Jan 25)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortDesc)\n\n\t// Most recently created first: 5 (Jan 10), 10 (Jan 5), 15 (Jan 1)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortAsc)\n\n\t// Oldest created first: 15 (Jan 1), 10 (Jan 5), 5 (Jan 10)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortDesc)\n\n\t// Highest number first: 15, 10, 5\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\n\t// Lowest number first: 5, 10, 15\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortDesc)\n\n\t// Most comments first: 5 (10 comments), 15 (5 comments), 10 (2 comments)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 10, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\t// Fewest comments first: 10 (2 comments), 15 (5 comments), 5 (10 comments)\n\tassert.Equal(t, 10, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestCycleSortFieldWithSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial sort: updated\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\n\t// Press 's' to cycle to created\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByCreated, m.sortField)\n\n\t// Press 's' to cycle to number\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByNumber, m.sortField)\n\n\t// Press 's' to cycle to comments\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByComments, m.sortField)\n\n\t// Press 's' to wrap back to updated\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n}\n\nfunc TestReverseSortOrderWithShiftSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial order: descending\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// Press 'S' to toggle to ascending\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortAsc, m.sortOrder)\n\n\t// Press 'S' to toggle back to descending\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n}\n\nfunc TestSortReordersIssuesAndResetsCursor(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Move cursor to second item\n\tm.cursor = 1\n\n\t// Press 's' to change sort\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\t// Cursor should reset to 0 after sort change\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestStatusBarShowsCurrentSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\t// Status bar should show current sort field and order\n\tassert.Contains(t, view, \"Updated\")\n\tassert.Contains(t, view, \"↓\") // Descending indicator\n}\n\nfunc TestStatusBarShowsAscendingIndicator(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\tassert.Contains(t, view, \"Number\")\n\tassert.Contains(t, view, \"↑\") // Ascending indicator\n}\n\nfunc TestGetSortConfig(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\tfield, order := m.GetSortConfig()\n\n\tassert.Equal(t, config.SortByComments, field)\n\tassert.Equal(t, config.SortAsc, order)\n}\n\nfunc TestSortChangedInitiallyFalse(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\tassert.False(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterCycleField(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 's' to cycle sort field\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterToggleOrder(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 'S' to toggle sort order\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\n// Helper to create test issues with body content for detail view tests\nfunc createDetailTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       42,\n\t\t\tTitle:        \"Test issue with markdown body\",\n\t\t\tBody:         \"## Description\\n\\nThis is a **bold** description with `code`.\\n\\n- Item 1\\n- Item 2\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 5,\n\t\t\tLabels:       []github.Label{{Name: \"bug\", Color: \"d73a4a\"}, {Name: \"priority\", Color: \"0052cc\"}},\n\t\t\tAssignees:    []github.User{{Login: \"assignee1\"}, {Login: \"assignee2\"}},\n\t\t},\n\t\t{\n\t\t\tNumber:       43,\n\t\t\tTitle:        \"Another issue\",\n\t\t\tBody:         \"Simple body text\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-16T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-21T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t\tLabels:       nil,\n\t\t\tAssignees:    nil,\n\t\t},\n\t}\n}\n\nfunc TestDetailPanelShowsSelectedIssue(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\tview := m.View()\n\n\t// Detail panel should show the selected issue info\n\t// Issue 43 is first because it has a more recent UpdatedAt date\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n\tassert.Contains(t, view, \"user2\")\n}\n\nfunc TestDetailPanelShowsHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Header should show: issue number, title, author, status indicators\n\tassert.Contains(t, view, \"#42\")\n\tassert.Contains(t, view, \"Test issue with markdown body\")\n\tassert.Contains(t, view, \"testuser\")\n}\n\nfunc TestDetailPanelShowsDates(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show created and updated dates\n\tassert.Contains(t, view, \"2024-01-15\")\n\tassert.Contains(t, view, \"2024-01-20\")\n}\n\nfunc TestDetailPanelShowsLabels(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show labels\n\tassert.Contains(t, view, \"bug\")\n\tassert.Contains(t, view, \"priority\")\n}\n\nfunc TestDetailPanelShowsAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show assignees\n\tassert.Contains(t, view, \"assignee1\")\n\tassert.Contains(t, view, \"assignee2\")\n}\n\nfunc TestDetailPanelShowsBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show body content (rendered markdown may have transformed text)\n\tassert.Contains(t, view, \"Description\")\n}\n\nfunc TestDetailPanelToggleRawMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\t// Initial state should be rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**bold**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back to rendered\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestDetailPanelScroll(t *testing.T) {\n\t// Create an issue with a long body\n\tissues := []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"Long issue\",\n\t\t\tBody:         \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\\nLine 11\\nLine 12\\nLine 13\\nLine 14\\nLine 15\\nLine 16\\nLine 17\\nLine 18\\nLine 19\\nLine 20\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to trigger scrolling\n\n\t// Initial scroll should be at 0\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n\n\t// Press 'l' to scroll down in the detail panel\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.DetailScrollOffset(), 0)\n\n\t// Press 'h' to scroll up in the detail panel\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n}\n\nfunc TestEnterKeyOpensCommentsView(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Initial state: not in comments view\n\tassert.False(t, m.InCommentsView())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to go back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestDetailPanelNoLabelsOrAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Issue 43 is first (more recent UpdatedAt) and has no labels or assignees\n\tview := m.View()\n\n\t// Should still render without crashing, just not show label/assignee sections\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n}\n\n// Helper to create test comments\nfunc createTestComments() []github.Comment {\n\treturn []github.Comment{\n\t\t{\n\t\t\tID:        \"comment1\",\n\t\t\tBody:      \"This is the **first** comment with `code`.\",\n\t\t\tAuthor:    github.User{Login: \"commenter1\"},\n\t\t\tCreatedAt: \"2024-01-10T10:00:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment2\",\n\t\t\tBody:      \"Second comment here.\",\n\t\t\tAuthor:    github.User{Login: \"commenter2\"},\n\t\t\tCreatedAt: \"2024-01-11T14:30:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment3\",\n\t\t\tBody:      \"Third comment with more details.\\n\\n- Point 1\\n- Point 2\",\n\t\t\tAuthor:    github.User{Login: \"commenter3\"},\n\t\t\tCreatedAt: \"2024-01-12T09:15:00Z\",\n\t\t},\n\t}\n}\n\nfunc TestSetComments(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\n\tcomments := createTestComments()\n\tm.SetComments(comments)\n\n\tassert.Equal(t, 3, len(m.GetComments()))\n}\n\nfunc TestCommentsViewShowsIssueHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments view should replace main interface (no issue list panel)\n\t// and show issue title/number as header\n\tassert.True(t, m.InCommentsView())\n\tassert.Contains(t, view, \"#43\") // Issue number\n\tassert.Contains(t, view, \"Another issue\") // Issue title\n}\n\nfunc TestCommentsViewShowsCommentsChronologically(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should be displayed chronologically\n\t// Check that all comment authors are visible\n\tassert.Contains(t, view, \"commenter1\")\n\tassert.Contains(t, view, \"commenter2\")\n\tassert.Contains(t, view, \"commenter3\")\n}\n\nfunc TestCommentsViewShowsCommentDate(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show dates\n\tassert.Contains(t, view, \"2024-01-10\")\n\tassert.Contains(t, view, \"2024-01-11\")\n\tassert.Contains(t, view, \"2024-01-12\")\n}\n\nfunc TestCommentsViewShowsCommentBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show body content\n\tassert.Contains(t, view, \"first\")\n\tassert.Contains(t, view, \"Second comment\")\n}\n\nfunc TestCommentsViewToggleMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Default is rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**first**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestCommentsViewScrollable(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to test scrolling\n\n\t// Create many comments to test scrolling\n\tmanyComments := []github.Comment{}\n\tfor i := 0; i < 20; i++ {\n\t\tmanyComments = append(manyComments, github.Comment{\n\t\t\tID:        fmt.Sprintf(\"comment%d\", i),\n\t\t\tBody:      fmt.Sprintf(\"Comment %d body text\", i),\n\t\t\tAuthor:    github.User{Login: fmt.Sprintf(\"user%d\", i)},\n\t\t\tCreatedAt: fmt.Sprintf(\"2024-01-%02dT10:00:00Z\", i+1),\n\t\t})\n\t}\n\tm.SetComments(manyComments)\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Initial scroll should be 0\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n\n\t// Press 'l' to scroll down\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.CommentsScrollOffset(), 0)\n\n\t// Press 'h' to scroll back up\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n}\n\nfunc TestCommentsViewEscapeReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to return to issue list\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewQKeyReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'q' to return to issue list (not quit the app when in comments view)\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewEmptyState(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\t// No comments set\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show a message when there are no comments\n\tassert.Contains(t, view, \"No comments\")\n}\n\nfunc TestCommentsViewReplacesMainInterface(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Before entering comments view, should see the issue list\n\tview := m.View()\n\tassert.Contains(t, view, \"#\") // Issue list column header\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview = m.View()\n\n\t// Comments view should be a drill-down (full screen), not split panel\n\t// The issue list should not be visible\n\t// Check that the comments header is present\n\tassert.Contains(t, view, \"Comments\")\n}\n\n// Tests for Data Refresh functionality (US-009)\n\nfunc TestRefreshKeyRTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\trefreshCalled := false\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\trefreshCalled = true\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Initially not refreshing\n\tassert.False(t, m.IsRefreshing())\n\n\t// Press 'r' to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should set refreshing state\n\tassert.True(t, m.IsRefreshing())\n\t// Should return a command to start the refresh\n\tassert.NotNil(t, cmd)\n\t// Execute the command to verify it was called\n\tcmd()\n\tassert.True(t, refreshCalled)\n}\n\nfunc TestRefreshKeyRUpperCaseTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Press 'R' (uppercase) to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'R'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\tassert.NotNil(t, cmd)\n}\n\nfunc TestRefreshKeyIgnoredWhileRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Try to trigger another refresh while already refreshing\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should still be refreshing, but no new command\n\tassert.True(t, m.IsRefreshing())\n\tassert.Nil(t, cmd) // No additional command should be returned\n}\n\nfunc TestRefreshKeyIgnoredInCommentsView(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Enter comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'r' - should not trigger refresh while in comments view\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshProgressMsgUpdatesProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\t// Check progress is tracked\n\tcurrentProgress := m.GetRefreshProgress()\n\tassert.Equal(t, \"issues\", currentProgress.Phase)\n\tassert.Equal(t, 5, currentProgress.Current)\n\tassert.Equal(t, 10, currentProgress.Total)\n}\n\nfunc TestRefreshDoneMsgUpdatesIssues(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\n\t// New issues from refresh\n\tnewIssues := []github.Issue{\n\t\t{\n\t\t\tNumber:       100,\n\t\t\tTitle:        \"New issue\",\n\t\t\tAuthor:       github.User{Login: \"newuser\"},\n\t\t\tCreatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\t// Simulate refresh done message\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: newIssues})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Issues should be updated\n\tassert.Equal(t, 1, m.IssueCount())\n\tassert.Equal(t, 100, m.issues[0].Number)\n}\n\nfunc TestRefreshErrorMsgStopsRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error message\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Error should be tracked\n\tassert.Equal(t, \"network error\", m.GetRefreshError())\n\t// Original issues should remain\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestStatusBarShowsRefreshingIndicator(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show refreshing indicator\n\tassert.Contains(t, view, \"Refreshing\")\n}\n\nfunc TestStatusBarShowsRefreshProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show progress\n\tassert.Contains(t, view, \"5/10\")\n}\n\nfunc TestRefreshClearsErrorOnNewRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start and fail a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\t// Start a new refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Error should be cleared\n\tassert.Empty(t, m.GetRefreshError())\n}\n\nfunc TestRefreshMaintainsCursorOnSameIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Move cursor to issue #2 (second in sorted order after applying default sort)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tselectedBefore := m.SelectedIssue()\n\trequire.NotNil(t, selectedBefore)\n\tselectedNumber := selectedBefore.Number\n\n\t// Start refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh with same issues\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues()})\n\tm = newModel.(Model)\n\n\t// Cursor should still be on the same issue\n\tselectedAfter := m.SelectedIssue()\n\trequire.NotNil(t, selectedAfter)\n\tassert.Equal(t, selectedNumber, selectedAfter.Number)\n}\n\n// Tests for Error Handling (US-013)\n\nfunc TestMinorErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a minor error (network timeout)\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate a network timeout error (minor)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network timeout: connection timed out\")})\n\tm = newModel.(Model)\n\n\t// Error should be shown in status bar, not as modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\tview := m.View()\n\t// Status bar should show error\n\tassert.Contains(t, view, \"timeout\")\n}\n\nfunc TestMinorErrorSuggestsRetry(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error: dial tcp: no route to host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show actionable guidance - suggest retry\n\tassert.Contains(t, view, \"r: retry\")\n}\n\nfunc TestRateLimitErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a rate limit error (minor)\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"GitHub API error: 403 rate limit exceeded\")})\n\tm = newModel.(Model)\n\n\t// Should be shown in status bar, not modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.Contains(t, m.GetRefreshError(), \"rate limit\")\n}\n\nfunc TestCriticalErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a critical error (invalid token)\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized)\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Authentication Error\"})\n\tm = newModel.(Model)\n\n\t// Should show modal\n\tassert.True(t, m.HasErrorModal())\n\tassert.Equal(t, \"Authentication Error\", m.GetErrorModalTitle())\n\tassert.Contains(t, m.GetErrorModalMessage(), \"invalid\")\n}\n\nfunc TestCriticalErrorModalRequiresAcknowledgment(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"database corruption: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Database Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Navigation keys should not work while modal is shown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.True(t, m.HasErrorModal()) // Modal still shown\n\n\t// Press Enter to acknowledge\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestCriticalErrorModalDismissedWithEscape(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"invalid token\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Auth Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Press Escape to dismiss\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestErrorModalViewRendering(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal with actionable guidance\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized). Please check that your token is correct and has not expired\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Authentication Error\",\n\t\tGuidance: \"Run 'ghissues config' to update your authentication settings.\",\n\t})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Modal should be visible\n\tassert.Contains(t, view, \"Authentication Error\")\n\tassert.Contains(t, view, \"Unauthorized\")\n\t// Should show actionable guidance\n\tassert.Contains(t, view, \"ghissues config\")\n\t// Should show dismissal instructions\n\tassert.Contains(t, view, \"Enter\")\n}\n\nfunc TestDatabaseErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Database corruption is a critical error\n\terr := fmt.Errorf(\"database error: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Database Error\",\n\t\tGuidance: \"Try deleting the database file and running 'ghissues sync' to rebuild it.\",\n\t})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\tview := m.View()\n\tassert.Contains(t, view, \"Database Error\")\n\tassert.Contains(t, view, \"database\")\n}\n\nfunc TestNavigationBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Remember initial cursor position\n\tinitialCursor := m.cursor\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try various navigation keys\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\t// 'q' should dismiss modal, not quit\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n\t// Should not return quit command\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try to trigger refresh while modal is shown\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should not start refreshing\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}\n","numLines":1441,"startLine":1,"totalLines":1441}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014AwTVXtiyrV56VCKHSmthg","type":"message","role":"assistant","content":[{"type":"text","text":"Now I have a good understanding of the codebase. Let me write tests for the last sync time display feature. Following TDD, I'll write tests first."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20546,"cache_read_input_tokens":56344,"cache_creation":{"ephemeral_5m_input_tokens":20546,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"3643cda7-d9c2-46dc-bf3f-e8d89ea44d53"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014AwTVXtiyrV56VCKHSmthg","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01YKB1ywvvLzTBMzKHCXyfRk","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go","old_string":"func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}","new_string":"func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}\n\n// Tests for Last Synced Indicator (US-010)\n\nfunc TestSetLastSyncTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\tsyncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)\n\tm.SetLastSyncTime(syncTime)\n\n\tassert.Equal(t, syncTime, m.GetLastSyncTime())\n}\n\nfunc TestLastSyncTimeDefaultIsZero(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default should be zero time (never synced)\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n}\n\nfunc TestStatusBarShowsLastSyncedTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30) // Wide enough to show full status bar\n\n\t// Set last sync time to a few minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Status bar should show \"Last synced:\" indicator\n\tassert.Contains(t, view, \"Last synced:\")\n}\n\nfunc TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 5 minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"5 minutes ago\")\n\tassert.Contains(t, view, \"5m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 30 seconds ago\n\tsyncTime := time.Now().Add(-30 * time.Second)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show \"just now\" or \"<1m ago\"\n\tassert.Contains(t, view, \"<1m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 2 hours ago\n\tsyncTime := time.Now().Add(-2 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"2h ago\")\n\tassert.Contains(t, view, \"2h ago\")\n}\n\nfunc TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 3 days ago\n\tsyncTime := time.Now().Add(-3 * 24 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"3d ago\")\n\tassert.Contains(t, view, \"3d ago\")\n}\n\nfunc TestLastSyncedNeverSynced(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Don't set last sync time (zero value = never synced)\n\tview := m.View()\n\n\t// Should show \"never\" or similar indicator\n\tassert.Contains(t, view, \"Last synced: never\")\n}\n\nfunc TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Initially never synced\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh - this should include the new sync time\n\tnewSyncTime := time.Now()\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})\n\tm = newModel.(Model)\n\n\t// Last sync time should be updated\n\tassert.False(t, m.GetLastSyncTime().IsZero())\n\t// Should be approximately now (within a second)\n\tassert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)\n}\n\nfunc TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set initial sync time\n\tinitialSyncTime := time.Now().Add(-10 * time.Minute)\n\tm.SetLastSyncTime(initialSyncTime)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Last sync time should remain unchanged\n\tassert.Equal(t, initialSyncTime, m.GetLastSyncTime())\n}\n\nfunc TestRelativeTimeFormat(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tduration time.Duration\n\t\texpected string\n\t}{\n\t\t{name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},\n\t\t{name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},\n\t\t{name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},\n\t\t{name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},\n\t\t{name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},\n\t\t{name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},\n\t\t{name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},\n\t\t{name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},\n\t\t{name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},\n\t\t{name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := formatRelativeTime(time.Now().Add(-tt.duration))\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestRelativeTimeFormatNeverSynced(t *testing.T) {\n\t// Zero time should return \"never\"\n\tresult := formatRelativeTime(time.Time{})\n\tassert.Equal(t, \"never\", result)\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":20546,"cache_read_input_tokens":56344,"cache_creation":{"ephemeral_5m_input_tokens":20546,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"e0042850-3976-409f-8218-9aadeec806dd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01YKB1ywvvLzTBMzKHCXyfRk","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model_test.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"47f68945-bc45-44f0-9a5b-bef2f126bbff","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go","oldString":"func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}","newString":"func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}\n\n// Tests for Last Synced Indicator (US-010)\n\nfunc TestSetLastSyncTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\tsyncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)\n\tm.SetLastSyncTime(syncTime)\n\n\tassert.Equal(t, syncTime, m.GetLastSyncTime())\n}\n\nfunc TestLastSyncTimeDefaultIsZero(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default should be zero time (never synced)\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n}\n\nfunc TestStatusBarShowsLastSyncedTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30) // Wide enough to show full status bar\n\n\t// Set last sync time to a few minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Status bar should show \"Last synced:\" indicator\n\tassert.Contains(t, view, \"Last synced:\")\n}\n\nfunc TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 5 minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"5 minutes ago\")\n\tassert.Contains(t, view, \"5m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 30 seconds ago\n\tsyncTime := time.Now().Add(-30 * time.Second)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show \"just now\" or \"<1m ago\"\n\tassert.Contains(t, view, \"<1m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 2 hours ago\n\tsyncTime := time.Now().Add(-2 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"2h ago\")\n\tassert.Contains(t, view, \"2h ago\")\n}\n\nfunc TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 3 days ago\n\tsyncTime := time.Now().Add(-3 * 24 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"3d ago\")\n\tassert.Contains(t, view, \"3d ago\")\n}\n\nfunc TestLastSyncedNeverSynced(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Don't set last sync time (zero value = never synced)\n\tview := m.View()\n\n\t// Should show \"never\" or similar indicator\n\tassert.Contains(t, view, \"Last synced: never\")\n}\n\nfunc TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Initially never synced\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh - this should include the new sync time\n\tnewSyncTime := time.Now()\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})\n\tm = newModel.(Model)\n\n\t// Last sync time should be updated\n\tassert.False(t, m.GetLastSyncTime().IsZero())\n\t// Should be approximately now (within a second)\n\tassert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)\n}\n\nfunc TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set initial sync time\n\tinitialSyncTime := time.Now().Add(-10 * time.Minute)\n\tm.SetLastSyncTime(initialSyncTime)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Last sync time should remain unchanged\n\tassert.Equal(t, initialSyncTime, m.GetLastSyncTime())\n}\n\nfunc TestRelativeTimeFormat(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tduration time.Duration\n\t\texpected string\n\t}{\n\t\t{name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},\n\t\t{name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},\n\t\t{name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},\n\t\t{name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},\n\t\t{name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},\n\t\t{name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},\n\t\t{name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},\n\t\t{name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},\n\t\t{name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},\n\t\t{name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := formatRelativeTime(time.Now().Add(-tt.duration))\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestRelativeTimeFormatNeverSynced(t *testing.T) {\n\t// Zero time should return \"never\"\n\tresult := formatRelativeTime(time.Time{})\n\tassert.Equal(t, \"never\", result)\n}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc createTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"First issue\",\n\t\t\tAuthor:       github.User{Login: \"user1\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t\t{\n\t\t\tNumber:       2,\n\t\t\tTitle:        \"Second issue\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-02T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-16T12:00:00Z\",\n\t\t\tCommentCount: 3,\n\t\t},\n\t\t{\n\t\t\tNumber:       3,\n\t\t\tTitle:        \"Third issue\",\n\t\t\tAuthor:       github.User{Login: \"user3\"},\n\t\t\tCreatedAt:    \"2024-01-03T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-17T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n}\n\nfunc TestNewModel(t *testing.T) {\n\tissues := createTestIssues()\n\tcolumns := []string{\"number\", \"title\", \"author\"}\n\n\tm := NewModel(issues, columns)\n\n\t// Issues are sorted by updated date descending by default\n\t// createTestIssues has: 1 (Jan 15), 2 (Jan 16), 3 (Jan 17)\n\t// So sorted: 3, 2, 1\n\tassert.Equal(t, 3, m.issues[0].Number)\n\tassert.Equal(t, 2, m.issues[1].Number)\n\tassert.Equal(t, 1, m.issues[2].Number)\n\tassert.Equal(t, columns, m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestNewModelEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tassert.Empty(t, m.issues)\n\tassert.Equal(t, DefaultColumns(), m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 0, m.IssueCount())\n}\n\nfunc TestModelNavigationDown(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial cursor position\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Move down with j key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move down with down arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n\n\t// Should not go past last item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n}\n\nfunc TestModelNavigationUp(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.cursor = 2 // Start at bottom\n\n\t// Move up with k key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move up with up arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Should not go past first item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestModelQuitKeys(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// q should quit\n\t_, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\trequire.NotNil(t, cmd)\n\tmsg := cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n\n\t// Ctrl+C should quit\n\t_, cmd = m.Update(tea.KeyMsg{Type: tea.KeyCtrlC})\n\trequire.NotNil(t, cmd)\n\tmsg = cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n}\n\nfunc TestModelSelectedIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Get selected issue at cursor 0\n\t// Default sort is by updated date descending, so issue 3 is first (most recently updated)\n\tissue := m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 3, issue.Number)\n\tassert.Equal(t, \"Third issue\", issue.Title)\n\n\t// Move cursor and check again\n\tm.cursor = 1\n\tissue = m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 2, issue.Number) // Second most recently updated\n}\n\nfunc TestModelSelectedIssueEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tissue := m.SelectedIssue()\n\tassert.Nil(t, issue)\n}\n\nfunc TestModelIssueCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tissues   []github.Issue\n\t\texpected int\n\t}{\n\t\t{name: \"three issues\", issues: createTestIssues(), expected: 3},\n\t\t{name: \"empty\", issues: nil, expected: 0},\n\t\t{name: \"one issue\", issues: []github.Issue{{Number: 1}}, expected: 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tm := NewModel(tt.issues, nil)\n\t\t\tassert.Equal(t, tt.expected, m.IssueCount())\n\t\t})\n\t}\n}\n\nfunc TestModelSetWindowSize(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tm.SetWindowSize(100, 50)\n\n\tassert.Equal(t, 100, m.width)\n\tassert.Equal(t, 50, m.height)\n}\n\nfunc TestModelWindowSizeMsg(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tnewModel, _ := m.Update(tea.WindowSizeMsg{Width: 120, Height: 40})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 120, m.width)\n\tassert.Equal(t, 40, m.height)\n}\n\nfunc TestDefaultColumns(t *testing.T) {\n\tcols := DefaultColumns()\n\tassert.Equal(t, []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}, cols)\n}\n\nfunc TestModelViewContainsIssueCount(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Status area should show issue count\n\tassert.Contains(t, view, \"3 issues\")\n}\n\nfunc TestModelViewContainsSelectedHighlight(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Selected issue should be in the view\n\tassert.Contains(t, view, \"First issue\")\n}\n\nfunc TestModelViewEmptyState(t *testing.T) {\n\tm := NewModel(nil, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Should show no issues message\n\tassert.Contains(t, view, \"No issues\")\n\tassert.Contains(t, view, \"0 issues\")\n}\n\n// Helper to create test issues with varied dates and counts for sorting tests\nfunc createSortTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       10,\n\t\t\tTitle:        \"Issue ten\",\n\t\t\tAuthor:       github.User{Login: \"alice\"},\n\t\t\tCreatedAt:    \"2024-01-05T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T12:00:00Z\",\n\t\t\tCommentCount: 2,\n\t\t},\n\t\t{\n\t\t\tNumber:       5,\n\t\t\tTitle:        \"Issue five\",\n\t\t\tAuthor:       github.User{Login: \"bob\"},\n\t\t\tCreatedAt:    \"2024-01-10T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 10,\n\t\t},\n\t\t{\n\t\t\tNumber:       15,\n\t\t\tTitle:        \"Issue fifteen\",\n\t\t\tAuthor:       github.User{Login: \"charlie\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-25T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t}\n}\n\nfunc TestNewModelWithSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestDefaultSortIsUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default sort should be by updated date descending (most recently updated first)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// First issue should be the most recently updated (issue 15)\n\tselected := m.SelectedIssue()\n\trequire.NotNil(t, selected)\n\tassert.Equal(t, 15, selected.Number)\n}\n\nfunc TestSortByUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\tm.SetWindowSize(80, 24)\n\n\t// Most recently updated first: 15 (Jan 25), 10 (Jan 20), 5 (Jan 15)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByUpdatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortAsc)\n\n\t// Oldest updated first: 5 (Jan 15), 10 (Jan 20), 15 (Jan 25)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortDesc)\n\n\t// Most recently created first: 5 (Jan 10), 10 (Jan 5), 15 (Jan 1)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortAsc)\n\n\t// Oldest created first: 15 (Jan 1), 10 (Jan 5), 5 (Jan 10)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortDesc)\n\n\t// Highest number first: 15, 10, 5\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\n\t// Lowest number first: 5, 10, 15\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortDesc)\n\n\t// Most comments first: 5 (10 comments), 15 (5 comments), 10 (2 comments)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 10, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\t// Fewest comments first: 10 (2 comments), 15 (5 comments), 5 (10 comments)\n\tassert.Equal(t, 10, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestCycleSortFieldWithSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial sort: updated\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\n\t// Press 's' to cycle to created\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByCreated, m.sortField)\n\n\t// Press 's' to cycle to number\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByNumber, m.sortField)\n\n\t// Press 's' to cycle to comments\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByComments, m.sortField)\n\n\t// Press 's' to wrap back to updated\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n}\n\nfunc TestReverseSortOrderWithShiftSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial order: descending\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// Press 'S' to toggle to ascending\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortAsc, m.sortOrder)\n\n\t// Press 'S' to toggle back to descending\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n}\n\nfunc TestSortReordersIssuesAndResetsCursor(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Move cursor to second item\n\tm.cursor = 1\n\n\t// Press 's' to change sort\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\t// Cursor should reset to 0 after sort change\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestStatusBarShowsCurrentSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\t// Status bar should show current sort field and order\n\tassert.Contains(t, view, \"Updated\")\n\tassert.Contains(t, view, \"↓\") // Descending indicator\n}\n\nfunc TestStatusBarShowsAscendingIndicator(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\tassert.Contains(t, view, \"Number\")\n\tassert.Contains(t, view, \"↑\") // Ascending indicator\n}\n\nfunc TestGetSortConfig(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\tfield, order := m.GetSortConfig()\n\n\tassert.Equal(t, config.SortByComments, field)\n\tassert.Equal(t, config.SortAsc, order)\n}\n\nfunc TestSortChangedInitiallyFalse(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\tassert.False(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterCycleField(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 's' to cycle sort field\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterToggleOrder(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 'S' to toggle sort order\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\n// Helper to create test issues with body content for detail view tests\nfunc createDetailTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       42,\n\t\t\tTitle:        \"Test issue with markdown body\",\n\t\t\tBody:         \"## Description\\n\\nThis is a **bold** description with `code`.\\n\\n- Item 1\\n- Item 2\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 5,\n\t\t\tLabels:       []github.Label{{Name: \"bug\", Color: \"d73a4a\"}, {Name: \"priority\", Color: \"0052cc\"}},\n\t\t\tAssignees:    []github.User{{Login: \"assignee1\"}, {Login: \"assignee2\"}},\n\t\t},\n\t\t{\n\t\t\tNumber:       43,\n\t\t\tTitle:        \"Another issue\",\n\t\t\tBody:         \"Simple body text\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-16T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-21T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t\tLabels:       nil,\n\t\t\tAssignees:    nil,\n\t\t},\n\t}\n}\n\nfunc TestDetailPanelShowsSelectedIssue(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\tview := m.View()\n\n\t// Detail panel should show the selected issue info\n\t// Issue 43 is first because it has a more recent UpdatedAt date\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n\tassert.Contains(t, view, \"user2\")\n}\n\nfunc TestDetailPanelShowsHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Header should show: issue number, title, author, status indicators\n\tassert.Contains(t, view, \"#42\")\n\tassert.Contains(t, view, \"Test issue with markdown body\")\n\tassert.Contains(t, view, \"testuser\")\n}\n\nfunc TestDetailPanelShowsDates(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show created and updated dates\n\tassert.Contains(t, view, \"2024-01-15\")\n\tassert.Contains(t, view, \"2024-01-20\")\n}\n\nfunc TestDetailPanelShowsLabels(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show labels\n\tassert.Contains(t, view, \"bug\")\n\tassert.Contains(t, view, \"priority\")\n}\n\nfunc TestDetailPanelShowsAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show assignees\n\tassert.Contains(t, view, \"assignee1\")\n\tassert.Contains(t, view, \"assignee2\")\n}\n\nfunc TestDetailPanelShowsBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show body content (rendered markdown may have transformed text)\n\tassert.Contains(t, view, \"Description\")\n}\n\nfunc TestDetailPanelToggleRawMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\t// Initial state should be rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**bold**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back to rendered\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestDetailPanelScroll(t *testing.T) {\n\t// Create an issue with a long body\n\tissues := []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"Long issue\",\n\t\t\tBody:         \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\\nLine 11\\nLine 12\\nLine 13\\nLine 14\\nLine 15\\nLine 16\\nLine 17\\nLine 18\\nLine 19\\nLine 20\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to trigger scrolling\n\n\t// Initial scroll should be at 0\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n\n\t// Press 'l' to scroll down in the detail panel\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.DetailScrollOffset(), 0)\n\n\t// Press 'h' to scroll up in the detail panel\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n}\n\nfunc TestEnterKeyOpensCommentsView(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Initial state: not in comments view\n\tassert.False(t, m.InCommentsView())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to go back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestDetailPanelNoLabelsOrAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Issue 43 is first (more recent UpdatedAt) and has no labels or assignees\n\tview := m.View()\n\n\t// Should still render without crashing, just not show label/assignee sections\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n}\n\n// Helper to create test comments\nfunc createTestComments() []github.Comment {\n\treturn []github.Comment{\n\t\t{\n\t\t\tID:        \"comment1\",\n\t\t\tBody:      \"This is the **first** comment with `code`.\",\n\t\t\tAuthor:    github.User{Login: \"commenter1\"},\n\t\t\tCreatedAt: \"2024-01-10T10:00:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment2\",\n\t\t\tBody:      \"Second comment here.\",\n\t\t\tAuthor:    github.User{Login: \"commenter2\"},\n\t\t\tCreatedAt: \"2024-01-11T14:30:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment3\",\n\t\t\tBody:      \"Third comment with more details.\\n\\n- Point 1\\n- Point 2\",\n\t\t\tAuthor:    github.User{Login: \"commenter3\"},\n\t\t\tCreatedAt: \"2024-01-12T09:15:00Z\",\n\t\t},\n\t}\n}\n\nfunc TestSetComments(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\n\tcomments := createTestComments()\n\tm.SetComments(comments)\n\n\tassert.Equal(t, 3, len(m.GetComments()))\n}\n\nfunc TestCommentsViewShowsIssueHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments view should replace main interface (no issue list panel)\n\t// and show issue title/number as header\n\tassert.True(t, m.InCommentsView())\n\tassert.Contains(t, view, \"#43\") // Issue number\n\tassert.Contains(t, view, \"Another issue\") // Issue title\n}\n\nfunc TestCommentsViewShowsCommentsChronologically(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should be displayed chronologically\n\t// Check that all comment authors are visible\n\tassert.Contains(t, view, \"commenter1\")\n\tassert.Contains(t, view, \"commenter2\")\n\tassert.Contains(t, view, \"commenter3\")\n}\n\nfunc TestCommentsViewShowsCommentDate(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show dates\n\tassert.Contains(t, view, \"2024-01-10\")\n\tassert.Contains(t, view, \"2024-01-11\")\n\tassert.Contains(t, view, \"2024-01-12\")\n}\n\nfunc TestCommentsViewShowsCommentBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show body content\n\tassert.Contains(t, view, \"first\")\n\tassert.Contains(t, view, \"Second comment\")\n}\n\nfunc TestCommentsViewToggleMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Default is rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**first**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestCommentsViewScrollable(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to test scrolling\n\n\t// Create many comments to test scrolling\n\tmanyComments := []github.Comment{}\n\tfor i := 0; i < 20; i++ {\n\t\tmanyComments = append(manyComments, github.Comment{\n\t\t\tID:        fmt.Sprintf(\"comment%d\", i),\n\t\t\tBody:      fmt.Sprintf(\"Comment %d body text\", i),\n\t\t\tAuthor:    github.User{Login: fmt.Sprintf(\"user%d\", i)},\n\t\t\tCreatedAt: fmt.Sprintf(\"2024-01-%02dT10:00:00Z\", i+1),\n\t\t})\n\t}\n\tm.SetComments(manyComments)\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Initial scroll should be 0\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n\n\t// Press 'l' to scroll down\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.CommentsScrollOffset(), 0)\n\n\t// Press 'h' to scroll back up\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n}\n\nfunc TestCommentsViewEscapeReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to return to issue list\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewQKeyReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'q' to return to issue list (not quit the app when in comments view)\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewEmptyState(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\t// No comments set\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show a message when there are no comments\n\tassert.Contains(t, view, \"No comments\")\n}\n\nfunc TestCommentsViewReplacesMainInterface(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Before entering comments view, should see the issue list\n\tview := m.View()\n\tassert.Contains(t, view, \"#\") // Issue list column header\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview = m.View()\n\n\t// Comments view should be a drill-down (full screen), not split panel\n\t// The issue list should not be visible\n\t// Check that the comments header is present\n\tassert.Contains(t, view, \"Comments\")\n}\n\n// Tests for Data Refresh functionality (US-009)\n\nfunc TestRefreshKeyRTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\trefreshCalled := false\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\trefreshCalled = true\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Initially not refreshing\n\tassert.False(t, m.IsRefreshing())\n\n\t// Press 'r' to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should set refreshing state\n\tassert.True(t, m.IsRefreshing())\n\t// Should return a command to start the refresh\n\tassert.NotNil(t, cmd)\n\t// Execute the command to verify it was called\n\tcmd()\n\tassert.True(t, refreshCalled)\n}\n\nfunc TestRefreshKeyRUpperCaseTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Press 'R' (uppercase) to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'R'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\tassert.NotNil(t, cmd)\n}\n\nfunc TestRefreshKeyIgnoredWhileRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Try to trigger another refresh while already refreshing\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should still be refreshing, but no new command\n\tassert.True(t, m.IsRefreshing())\n\tassert.Nil(t, cmd) // No additional command should be returned\n}\n\nfunc TestRefreshKeyIgnoredInCommentsView(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Enter comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'r' - should not trigger refresh while in comments view\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshProgressMsgUpdatesProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\t// Check progress is tracked\n\tcurrentProgress := m.GetRefreshProgress()\n\tassert.Equal(t, \"issues\", currentProgress.Phase)\n\tassert.Equal(t, 5, currentProgress.Current)\n\tassert.Equal(t, 10, currentProgress.Total)\n}\n\nfunc TestRefreshDoneMsgUpdatesIssues(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\n\t// New issues from refresh\n\tnewIssues := []github.Issue{\n\t\t{\n\t\t\tNumber:       100,\n\t\t\tTitle:        \"New issue\",\n\t\t\tAuthor:       github.User{Login: \"newuser\"},\n\t\t\tCreatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\t// Simulate refresh done message\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: newIssues})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Issues should be updated\n\tassert.Equal(t, 1, m.IssueCount())\n\tassert.Equal(t, 100, m.issues[0].Number)\n}\n\nfunc TestRefreshErrorMsgStopsRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error message\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Error should be tracked\n\tassert.Equal(t, \"network error\", m.GetRefreshError())\n\t// Original issues should remain\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestStatusBarShowsRefreshingIndicator(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show refreshing indicator\n\tassert.Contains(t, view, \"Refreshing\")\n}\n\nfunc TestStatusBarShowsRefreshProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show progress\n\tassert.Contains(t, view, \"5/10\")\n}\n\nfunc TestRefreshClearsErrorOnNewRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start and fail a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\t// Start a new refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Error should be cleared\n\tassert.Empty(t, m.GetRefreshError())\n}\n\nfunc TestRefreshMaintainsCursorOnSameIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Move cursor to issue #2 (second in sorted order after applying default sort)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tselectedBefore := m.SelectedIssue()\n\trequire.NotNil(t, selectedBefore)\n\tselectedNumber := selectedBefore.Number\n\n\t// Start refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh with same issues\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues()})\n\tm = newModel.(Model)\n\n\t// Cursor should still be on the same issue\n\tselectedAfter := m.SelectedIssue()\n\trequire.NotNil(t, selectedAfter)\n\tassert.Equal(t, selectedNumber, selectedAfter.Number)\n}\n\n// Tests for Error Handling (US-013)\n\nfunc TestMinorErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a minor error (network timeout)\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate a network timeout error (minor)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network timeout: connection timed out\")})\n\tm = newModel.(Model)\n\n\t// Error should be shown in status bar, not as modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\tview := m.View()\n\t// Status bar should show error\n\tassert.Contains(t, view, \"timeout\")\n}\n\nfunc TestMinorErrorSuggestsRetry(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error: dial tcp: no route to host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show actionable guidance - suggest retry\n\tassert.Contains(t, view, \"r: retry\")\n}\n\nfunc TestRateLimitErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a rate limit error (minor)\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"GitHub API error: 403 rate limit exceeded\")})\n\tm = newModel.(Model)\n\n\t// Should be shown in status bar, not modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.Contains(t, m.GetRefreshError(), \"rate limit\")\n}\n\nfunc TestCriticalErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a critical error (invalid token)\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized)\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Authentication Error\"})\n\tm = newModel.(Model)\n\n\t// Should show modal\n\tassert.True(t, m.HasErrorModal())\n\tassert.Equal(t, \"Authentication Error\", m.GetErrorModalTitle())\n\tassert.Contains(t, m.GetErrorModalMessage(), \"invalid\")\n}\n\nfunc TestCriticalErrorModalRequiresAcknowledgment(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"database corruption: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Database Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Navigation keys should not work while modal is shown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.True(t, m.HasErrorModal()) // Modal still shown\n\n\t// Press Enter to acknowledge\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestCriticalErrorModalDismissedWithEscape(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"invalid token\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Auth Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Press Escape to dismiss\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestErrorModalViewRendering(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal with actionable guidance\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized). Please check that your token is correct and has not expired\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Authentication Error\",\n\t\tGuidance: \"Run 'ghissues config' to update your authentication settings.\",\n\t})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Modal should be visible\n\tassert.Contains(t, view, \"Authentication Error\")\n\tassert.Contains(t, view, \"Unauthorized\")\n\t// Should show actionable guidance\n\tassert.Contains(t, view, \"ghissues config\")\n\t// Should show dismissal instructions\n\tassert.Contains(t, view, \"Enter\")\n}\n\nfunc TestDatabaseErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Database corruption is a critical error\n\terr := fmt.Errorf(\"database error: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Database Error\",\n\t\tGuidance: \"Try deleting the database file and running 'ghissues sync' to rebuild it.\",\n\t})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\tview := m.View()\n\tassert.Contains(t, view, \"Database Error\")\n\tassert.Contains(t, view, \"database\")\n}\n\nfunc TestNavigationBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Remember initial cursor position\n\tinitialCursor := m.cursor\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try various navigation keys\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\t// 'q' should dismiss modal, not quit\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n\t// Should not return quit command\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try to trigger refresh while modal is shown\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should not start refreshing\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}\n","structuredPatch":[{"oldStart":1438,"oldLines":3,"newStart":1438,"newLines":186,"lines":["   // The error message and retry option should be visible","   assert.Contains(t, view, \"dial tcp\")"," }","+","+// Tests for Last Synced Indicator (US-010)","+","+func TestSetLastSyncTime(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+","+  syncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)","+  m.SetLastSyncTime(syncTime)","+","+  assert.Equal(t, syncTime, m.GetLastSyncTime())","+}","+","+func TestLastSyncTimeDefaultIsZero(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+","+  // Default should be zero time (never synced)","+  assert.True(t, m.GetLastSyncTime().IsZero())","+}","+","+func TestStatusBarShowsLastSyncedTime(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30) // Wide enough to show full status bar","+","+  // Set last sync time to a few minutes ago","+  syncTime := time.Now().Add(-5 * time.Minute)","+  m.SetLastSyncTime(syncTime)","+","+  view := m.View()","+","+  // Status bar should show \"Last synced:\" indicator","+  assert.Contains(t, view, \"Last synced:\")","+}","+","+func TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Set last sync time to 5 minutes ago","+  syncTime := time.Now().Add(-5 * time.Minute)","+  m.SetLastSyncTime(syncTime)","+","+  view := m.View()","+","+  // Should show relative time (e.g., \"5 minutes ago\")","+  assert.Contains(t, view, \"5m ago\")","+}","+","+func TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Set last sync time to 30 seconds ago","+  syncTime := time.Now().Add(-30 * time.Second)","+  m.SetLastSyncTime(syncTime)","+","+  view := m.View()","+","+  // Should show \"just now\" or \"<1m ago\"","+  assert.Contains(t, view, \"<1m ago\")","+}","+","+func TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Set last sync time to 2 hours ago","+  syncTime := time.Now().Add(-2 * time.Hour)","+  m.SetLastSyncTime(syncTime)","+","+  view := m.View()","+","+  // Should show relative time (e.g., \"2h ago\")","+  assert.Contains(t, view, \"2h ago\")","+}","+","+func TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Set last sync time to 3 days ago","+  syncTime := time.Now().Add(-3 * 24 * time.Hour)","+  m.SetLastSyncTime(syncTime)","+","+  view := m.View()","+","+  // Should show relative time (e.g., \"3d ago\")","+  assert.Contains(t, view, \"3d ago\")","+}","+","+func TestLastSyncedNeverSynced(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Don't set last sync time (zero value = never synced)","+  view := m.View()","+","+  // Should show \"never\" or similar indicator","+  assert.Contains(t, view, \"Last synced: never\")","+}","+","+func TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Initially never synced","+  assert.True(t, m.GetLastSyncTime().IsZero())","+","+  // Start refresh","+  newModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})","+  m = newModel.(Model)","+","+  // Complete refresh - this should include the new sync time","+  newSyncTime := time.Now()","+  newModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})","+  m = newModel.(Model)","+","+  // Last sync time should be updated","+  assert.False(t, m.GetLastSyncTime().IsZero())","+  // Should be approximately now (within a second)","+  assert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)","+}","+","+func TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {","+  issues := createTestIssues()","+  m := NewModel(issues, nil)","+  m.SetWindowSize(160, 30)","+","+  // Set initial sync time","+  initialSyncTime := time.Now().Add(-10 * time.Minute)","+  m.SetLastSyncTime(initialSyncTime)","+","+  // Start refresh","+  newModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})","+  m = newModel.(Model)","+","+  // Simulate error","+  newModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})","+  m = newModel.(Model)","+","+  // Last sync time should remain unchanged","+  assert.Equal(t, initialSyncTime, m.GetLastSyncTime())","+}","+","+func TestRelativeTimeFormat(t *testing.T) {","+  tests := []struct {","+    name     string","+    duration time.Duration","+    expected string","+  }{","+    {name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},","+    {name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},","+    {name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},","+    {name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},","+    {name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},","+    {name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},","+    {name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},","+    {name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},","+    {name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},","+    {name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},","+  }","+","+  for _, tt := range tests {","+    t.Run(tt.name, func(t *testing.T) {","+      result := formatRelativeTime(time.Now().Add(-tt.duration))","+      assert.Equal(t, tt.expected, result)","+    })","+  }","+}","+","+func TestRelativeTimeFormatNeverSynced(t *testing.T) {","+  // Zero time should return \"never\"","+  result := formatRelativeTime(time.Time{})","+  assert.Equal(t, \"never\", result)","+}"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MkevkSVSArtVVRupmBUBeN","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the `time` import and update the `RefreshDoneMsg` struct to include `LastSyncTime`. Let me run the tests first to see them fail (as expected in TDD)."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2510,"cache_read_input_tokens":76890,"cache_creation":{"ephemeral_5m_input_tokens":2510,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"d7ba84fe-bbad-4c8c-a063-feff79c75551"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MkevkSVSArtVVRupmBUBeN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016GVGVQzQQJGbKqsVnBZu1o","name":"Bash","input":{"command":"go test ./internal/tui/... -v -run \"TestSetLastSyncTime|TestLastSyncTime|TestStatusBarShowsLastSyncedTime|TestRelativeTime|TestLastSyncedRelative|TestLastSyncedNever\" 2>&1 | head -100"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":2510,"cache_read_input_tokens":76890,"cache_creation":{"ephemeral_5m_input_tokens":2510,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"3673e85b-4f4f-4c99-a3ad-e7126d9c3dc9"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016GVGVQzQQJGbKqsVnBZu1o","type":"tool_result","content":"# github.com/shepbook/ghissues/internal/tui [github.com/shepbook/ghissues/internal/tui.test]\ninternal/tui/model_test.go:1448:14: undefined: time\ninternal/tui/model_test.go:1449:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1451:30: m.GetLastSyncTime undefined (type Model has no field or method GetLastSyncTime)\ninternal/tui/model_test.go:1459:19: m.GetLastSyncTime undefined (type Model has no field or method GetLastSyncTime)\ninternal/tui/model_test.go:1468:14: undefined: time\ninternal/tui/model_test.go:1469:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1483:14: undefined: time\ninternal/tui/model_test.go:1484:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1498:14: undefined: time\ninternal/tui/model_test.go:1499:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1499:4: too many errors\nFAIL\tgithub.com/shepbook/ghissues/internal/tui [build failed]\nFAIL","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"e44780ad-d9bc-436f-b596-8c577d9a7689","tool_use_result":{"stdout":"# github.com/shepbook/ghissues/internal/tui [github.com/shepbook/ghissues/internal/tui.test]\ninternal/tui/model_test.go:1448:14: undefined: time\ninternal/tui/model_test.go:1449:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1451:30: m.GetLastSyncTime undefined (type Model has no field or method GetLastSyncTime)\ninternal/tui/model_test.go:1459:19: m.GetLastSyncTime undefined (type Model has no field or method GetLastSyncTime)\ninternal/tui/model_test.go:1468:14: undefined: time\ninternal/tui/model_test.go:1469:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1483:14: undefined: time\ninternal/tui/model_test.go:1484:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1498:14: undefined: time\ninternal/tui/model_test.go:1499:4: m.SetLastSyncTime undefined (type Model has no field or method SetLastSyncTime)\ninternal/tui/model_test.go:1499:4: too many errors\nFAIL\tgithub.com/shepbook/ghissues/internal/tui [build failed]\nFAIL","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011qSjKPopiJcR3KcDPmeqFe","type":"message","role":"assistant","content":[{"type":"text","text":"The tests are failing because the methods and types don't exist yet. Let me update the todo list and implement the functionality."}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":960,"cache_read_input_tokens":79400,"cache_creation":{"ephemeral_5m_input_tokens":960,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"cf7580f5-6752-4717-a018-5c5814e1cbdd"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011qSjKPopiJcR3KcDPmeqFe","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_012phVyfj8EFfPSeNMPKDKpD","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"in_progress","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":960,"cache_read_input_tokens":79400,"cache_creation":{"ephemeral_5m_input_tokens":960,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"25de3555-d6b6-43f9-933b-cd54687703fc"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_012phVyfj8EFfPSeNMPKDKpD","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"5f6a479f-6b82-4ecc-9f8a-13272e6c0d3a","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"in_progress","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"pending","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"in_progress","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FXbVMQpbAZsz18tfYZAqU5","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me implement the required changes. First, I need to:\n1. Add `lastSyncTime` field to the Model\n2. Add `LastSyncTime` to `RefreshDoneMsg`\n3. Add `SetLastSyncTime` and `GetLastSyncTime` methods\n4. Implement `formatRelativeTime` function\n5. Update the status bar in `View()` to show last synced time"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":80360,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"78b4cacf-9e84-4031-b6cd-69cb9aadee9c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01FXbVMQpbAZsz18tfYZAqU5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RRcJugKNmb75KSRc6DkNYN","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","old_string":"// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues []github.Issue\n}","new_string":"// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":355,"cache_read_input_tokens":80360,"cache_creation":{"ephemeral_5m_input_tokens":355,"ephemeral_1h_input_tokens":0},"output_tokens":6,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"eceac868-4d72-4229-9971-f12ea582f8b1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RRcJugKNmb75KSRc6DkNYN","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"f7ac9de2-5a29-48d9-84ba-b1780cba25b6","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","oldString":"// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues []github.Issue\n}","newString":"// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues []github.Issue\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal    bool   // Whether the error modal is visible\n\terrorModalTitle   string // Title of the error modal\n\terrorModalMessage string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","structuredPatch":[{"oldStart":32,"oldLines":7,"newStart":32,"newLines":8,"lines":[" "," // RefreshDoneMsg is sent when refresh completes successfully"," type RefreshDoneMsg struct {","-  Issues []github.Issue","+  Issues       []github.Issue","+  LastSyncTime time.Time"," }"," "," // RefreshErrorMsg is sent when refresh fails"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019WcG15dbmfLzRdjCR1Ytys","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_016hmaw5bYBimXLV1vuaGz8f","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","old_string":"\t// Error modal state (for critical errors)\n\tshowErrorModal    bool   // Whether the error modal is visible\n\terrorModalTitle   string // Title of the error modal\n\terrorModalMessage string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n}","new_string":"\t// Error modal state (for critical errors)\n\tshowErrorModal     bool   // Whether the error modal is visible\n\terrorModalTitle    string // Title of the error modal\n\terrorModalMessage  string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n\n\t// Last sync time\n\tlastSyncTime time.Time // When data was last synced (zero = never)\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":338,"cache_read_input_tokens":80715,"cache_creation":{"ephemeral_5m_input_tokens":338,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"102b7e14-6995-4611-8158-2cd7e1de43bb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_016hmaw5bYBimXLV1vuaGz8f","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"59e6b803-9faf-4fa7-bc46-0c433c735552","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","oldString":"\t// Error modal state (for critical errors)\n\tshowErrorModal    bool   // Whether the error modal is visible\n\terrorModalTitle   string // Title of the error modal\n\terrorModalMessage string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n}","newString":"\t// Error modal state (for critical errors)\n\tshowErrorModal     bool   // Whether the error modal is visible\n\terrorModalTitle    string // Title of the error modal\n\terrorModalMessage  string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n\n\t// Last sync time\n\tlastSyncTime time.Time // When data was last synced (zero = never)\n}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal    bool   // Whether the error modal is visible\n\terrorModalTitle   string // Title of the error modal\n\terrorModalMessage string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","structuredPatch":[{"oldStart":75,"oldLines":10,"newStart":75,"newLines":13,"lines":["   refreshFunc     func() tea.Msg  // Function to call to perform refresh"," ","   // Error modal state (for critical errors)","-  showErrorModal    bool   // Whether the error modal is visible","-  errorModalTitle   string // Title of the error modal","-  errorModalMessage string // Error message to display","+  showErrorModal     bool   // Whether the error modal is visible","+  errorModalTitle    string // Title of the error modal","+  errorModalMessage  string // Error message to display","   errorModalGuidance string // Optional actionable guidance","+","+  // Last sync time","+  lastSyncTime time.Time // When data was last synced (zero = never)"," }"," "," // NewModel creates a new TUI model with the given issues and columns"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014zu8QetJs5UnENMVPyBGPo","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the `Update` function to handle `LastSyncTime` in `RefreshDoneMsg`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":714,"cache_read_input_tokens":81053,"cache_creation":{"ephemeral_5m_input_tokens":714,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"7da03928-5894-43ea-a761-9a9875ae4636"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_014zu8QetJs5UnENMVPyBGPo","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KDPze3EBssZ4juyJzJ2mUU","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","old_string":"\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}","new_string":"\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Update last sync time\n\t\tif !msg.LastSyncTime.IsZero() {\n\t\t\tm.lastSyncTime = msg.LastSyncTime\n\t\t}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":714,"cache_read_input_tokens":81053,"cache_creation":{"ephemeral_5m_input_tokens":714,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"3bb0eb68-a813-4059-b1db-2b595e22d750"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KDPze3EBssZ4juyJzJ2mUU","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"d80917c7-469c-47d9-a4d6-9dcbcab6df8b","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","oldString":"\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}","newString":"\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Update last sync time\n\t\tif !msg.LastSyncTime.IsZero() {\n\t\t\tm.lastSyncTime = msg.LastSyncTime\n\t\t}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal     bool   // Whether the error modal is visible\n\terrorModalTitle    string // Title of the error modal\n\terrorModalMessage  string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n\n\t// Last sync time\n\tlastSyncTime time.Time // When data was last synced (zero = never)\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","structuredPatch":[{"oldStart":265,"oldLines":6,"newStart":265,"newLines":10,"lines":["         break","       }","     }","+    // Update last sync time","+    if !msg.LastSyncTime.IsZero() {","+      m.lastSyncTime = msg.LastSyncTime","+    }","   case RefreshErrorMsg:","     m.isRefreshing = false","     m.refreshProgress = RefreshProgress{}"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UGEN45CdrRCafP4NNbe1JT","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me add the getter, setter, and the relative time formatting function. I'll add them near the other getter/setter methods:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":590,"cache_read_input_tokens":81767,"cache_creation":{"ephemeral_5m_input_tokens":590,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"47f45f44-d5ec-422b-97d9-aec0f5d42b3e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01UGEN45CdrRCafP4NNbe1JT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01U1KRSfJyqANkHGHzJVYvh8","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","old_string":"// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}","new_string":"// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// SetLastSyncTime sets the last sync time\nfunc (m *Model) SetLastSyncTime(t time.Time) {\n\tm.lastSyncTime = t\n}\n\n// GetLastSyncTime returns the last sync time (zero value if never synced)\nfunc (m Model) GetLastSyncTime() time.Time {\n\treturn m.lastSyncTime\n}\n\n// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")\nfunc formatRelativeTime(t time.Time) string {\n\tif t.IsZero() {\n\t\treturn \"never\"\n\t}\n\n\tdiff := time.Since(t)\n\n\tif diff < time.Minute {\n\t\treturn \"<1m ago\"\n\t}\n\tif diff < time.Hour {\n\t\tminutes := int(diff.Minutes())\n\t\treturn fmt.Sprintf(\"%dm ago\", minutes)\n\t}\n\tif diff < 24*time.Hour {\n\t\thours := int(diff.Hours())\n\t\treturn fmt.Sprintf(\"%dh ago\", hours)\n\t}\n\tdays := int(diff.Hours() / 24)\n\treturn fmt.Sprintf(\"%dd ago\", days)\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":590,"cache_read_input_tokens":81767,"cache_creation":{"ephemeral_5m_input_tokens":590,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"b4da7414-1de2-4aa9-bf31-b2d9600e3740"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01U1KRSfJyqANkHGHzJVYvh8","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"a0d11b12-4c75-4f46-8d43-ac2c31e32d4b","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","oldString":"// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}","newString":"// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// SetLastSyncTime sets the last sync time\nfunc (m *Model) SetLastSyncTime(t time.Time) {\n\tm.lastSyncTime = t\n}\n\n// GetLastSyncTime returns the last sync time (zero value if never synced)\nfunc (m Model) GetLastSyncTime() time.Time {\n\treturn m.lastSyncTime\n}\n\n// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")\nfunc formatRelativeTime(t time.Time) string {\n\tif t.IsZero() {\n\t\treturn \"never\"\n\t}\n\n\tdiff := time.Since(t)\n\n\tif diff < time.Minute {\n\t\treturn \"<1m ago\"\n\t}\n\tif diff < time.Hour {\n\t\tminutes := int(diff.Minutes())\n\t\treturn fmt.Sprintf(\"%dm ago\", minutes)\n\t}\n\tif diff < 24*time.Hour {\n\t\thours := int(diff.Hours())\n\t\treturn fmt.Sprintf(\"%dh ago\", hours)\n\t}\n\tdays := int(diff.Hours() / 24)\n\treturn fmt.Sprintf(\"%dd ago\", days)\n}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal     bool   // Whether the error modal is visible\n\terrorModalTitle    string // Title of the error modal\n\terrorModalMessage  string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n\n\t// Last sync time\n\tlastSyncTime time.Time // When data was last synced (zero = never)\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Update last sync time\n\t\tif !msg.LastSyncTime.IsZero() {\n\t\t\tm.lastSyncTime = msg.LastSyncTime\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","structuredPatch":[{"oldStart":865,"oldLines":6,"newStart":865,"newLines":39,"lines":["   return m.errorModalGuidance"," }"," ","+// SetLastSyncTime sets the last sync time","+func (m *Model) SetLastSyncTime(t time.Time) {","+  m.lastSyncTime = t","+}","+","+// GetLastSyncTime returns the last sync time (zero value if never synced)","+func (m Model) GetLastSyncTime() time.Time {","+  return m.lastSyncTime","+}","+","+// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")","+func formatRelativeTime(t time.Time) string {","+  if t.IsZero() {","+    return \"never\"","+  }","+","+  diff := time.Since(t)","+","+  if diff < time.Minute {","+    return \"<1m ago\"","+  }","+  if diff < time.Hour {","+    minutes := int(diff.Minutes())","+    return fmt.Sprintf(\"%dm ago\", minutes)","+  }","+  if diff < 24*time.Hour {","+    hours := int(diff.Hours())","+    return fmt.Sprintf(\"%dh ago\", hours)","+  }","+  days := int(diff.Hours() / 24)","+  return fmt.Sprintf(\"%dd ago\", days)","+}","+"," // sortIssues sorts the issues based on the current sort field and order"," func (m *Model) sortIssues() {","   if len(m.issues) == 0 {"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SxA6LsfTgr2Jdxh5BnTG6y","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_019TFE3bVezBsHBCPtc8FA3C","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"in_progress","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":562,"cache_read_input_tokens":82357,"cache_creation":{"ephemeral_5m_input_tokens":562,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"ef9d5301-bbef-4d4d-a320-5ff69a4b75b6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_019TFE3bVezBsHBCPtc8FA3C","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"e6e48c58-c49b-4fb0-a2e6-e25f37c3f1bc","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"in_progress","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"pending","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"pending","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"pending","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"in_progress","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011bGfEZgQyJ53Y1WazVQEfJ","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the status bar in `View()` to include the last synced indicator. Let me find and update that section:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":637,"cache_read_input_tokens":82919,"cache_creation":{"ephemeral_5m_input_tokens":637,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"4a219a38-cf54-425c-85ea-b76cc930916c"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_011bGfEZgQyJ53Y1WazVQEfJ","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01VyBYE5fN2nG6GBBGZncoac","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","old_string":"\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}","new_string":"\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Format last sync time\n\tlastSyncedStr := formatRelativeTime(m.lastSyncTime)\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"Last synced: %s | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\tlastSyncedStr, len(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":637,"cache_read_input_tokens":82919,"cache_creation":{"ephemeral_5m_input_tokens":637,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"8cb82d99-47e9-4ec2-a308-dd0ae8dfe58c"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01VyBYE5fN2nG6GBBGZncoac","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"fc171f56-4c5e-4c09-899b-f6cdadbfca62","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model.go","oldString":"\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}","newString":"\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Format last sync time\n\tlastSyncedStr := formatRelativeTime(m.lastSyncTime)\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"Last synced: %s | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\tlastSyncedStr, len(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/charmbracelet/glamour\"\n\t\"github.com/charmbracelet/lipgloss\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n)\n\n// DefaultColumns returns the default columns to display\nfunc DefaultColumns() []string {\n\treturn []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}\n}\n\n// RefreshProgress contains progress information during a refresh operation\ntype RefreshProgress struct {\n\tPhase   string // \"issues\" or \"comments\"\n\tCurrent int\n\tTotal   int\n}\n\n// RefreshProgressMsg is sent when refresh progress updates\ntype RefreshProgressMsg struct {\n\tProgress RefreshProgress\n}\n\n// RefreshDoneMsg is sent when refresh completes successfully\ntype RefreshDoneMsg struct {\n\tIssues       []github.Issue\n\tLastSyncTime time.Time\n}\n\n// RefreshErrorMsg is sent when refresh fails\ntype RefreshErrorMsg struct {\n\tErr error\n}\n\n// RefreshStartMsg is sent to initiate a refresh (used by Init for auto-refresh)\ntype RefreshStartMsg struct{}\n\n// CriticalErrorMsg is sent when a critical error occurs that requires user acknowledgment\ntype CriticalErrorMsg struct {\n\tErr      error  // The underlying error\n\tTitle    string // Title for the error modal (e.g., \"Authentication Error\")\n\tGuidance string // Optional actionable guidance for resolving the error\n}\n\n// Model represents the TUI application state\ntype Model struct {\n\tissues           []github.Issue\n\tcomments         []github.Comment\n\tcolumns          []string\n\tcursor           int\n\twidth            int\n\theight           int\n\tsortField        config.SortField\n\tsortOrder        config.SortOrder\n\tsortChanged      bool // Track if sort was changed during session\n\trawMarkdown      bool // Toggle between raw and rendered markdown\n\tdetailScrollY    int  // Scroll offset for detail panel\n\tcommentsScrollY  int  // Scroll offset for comments view\n\tinCommentsView   bool // Whether we're in the comments view\n\tglamourRenderer  *glamour.TermRenderer\n\n\t// Refresh state\n\tisRefreshing    bool            // Whether a refresh is in progress\n\trefreshProgress RefreshProgress // Current refresh progress\n\trefreshError    string          // Last refresh error message\n\trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n\n\t// Error modal state (for critical errors)\n\tshowErrorModal     bool   // Whether the error modal is visible\n\terrorModalTitle    string // Title of the error modal\n\terrorModalMessage  string // Error message to display\n\terrorModalGuidance string // Optional actionable guidance\n\n\t// Last sync time\n\tlastSyncTime time.Time // When data was last synced (zero = never)\n}\n\n// NewModel creates a new TUI model with the given issues and columns\n// Uses default sort: most recently updated first (updated descending)\nfunc NewModel(issues []github.Issue, columns []string) Model {\n\tsortField, sortOrder := config.DefaultSortConfig()\n\treturn NewModelWithSort(issues, columns, sortField, sortOrder)\n}\n\n// NewModelWithSort creates a new TUI model with the given issues, columns, and sort options\nfunc NewModelWithSort(issues []github.Issue, columns []string, sortField config.SortField, sortOrder config.SortOrder) Model {\n\tif columns == nil {\n\t\tcolumns = DefaultColumns()\n\t}\n\tif sortField == \"\" {\n\t\tsortField, _ = config.DefaultSortConfig()\n\t}\n\tif sortOrder == \"\" {\n\t\t_, sortOrder = config.DefaultSortConfig()\n\t}\n\n\t// Create a glamour renderer for markdown rendering\n\trenderer, _ := glamour.NewTermRenderer(\n\t\tglamour.WithAutoStyle(),\n\t\tglamour.WithWordWrap(60),\n\t)\n\n\tm := Model{\n\t\tissues:          make([]github.Issue, len(issues)),\n\t\tcolumns:         columns,\n\t\tcursor:          0,\n\t\tsortField:       sortField,\n\t\tsortOrder:       sortOrder,\n\t\tglamourRenderer: renderer,\n\t}\n\n\t// Copy issues to avoid modifying the original slice\n\tcopy(m.issues, issues)\n\n\t// Apply initial sort\n\tm.sortIssues()\n\n\treturn m\n}\n\n// Init initializes the model\nfunc (m Model) Init() tea.Cmd {\n\treturn nil\n}\n\n// Update handles messages and updates the model\nfunc (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n\tswitch msg := msg.(type) {\n\tcase tea.KeyMsg:\n\t\t// Handle error modal first - block most keys when modal is shown\n\t\tif m.showErrorModal {\n\t\t\tswitch {\n\t\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\t\treturn m, tea.Quit\n\t\t\tcase msg.Type == tea.KeyEscape, msg.Type == tea.KeyEnter:\n\t\t\t\t// Dismiss the error modal\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t\t// Dismiss modal with 'q' as well\n\t\t\t\tm.showErrorModal = false\n\t\t\t\tm.errorModalTitle = \"\"\n\t\t\t\tm.errorModalMessage = \"\"\n\t\t\t\tm.errorModalGuidance = \"\"\n\t\t\t}\n\t\t\t// Block all other keys while modal is shown\n\t\t\treturn m, nil\n\t\t}\n\n\t\tswitch {\n\t\tcase msg.Type == tea.KeyCtrlC:\n\t\t\treturn m, tea.Quit\n\t\tcase msg.Type == tea.KeyEscape:\n\t\t\t// Exit comments view if in it\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyEnter:\n\t\t\t// Open comments view for selected issue\n\t\t\tif len(m.issues) > 0 && !m.inCommentsView {\n\t\t\t\tm.inCommentsView = true\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t}\n\t\tcase msg.Type == tea.KeyDown || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'j'):\n\t\t\tif !m.inCommentsView && m.cursor < len(m.issues)-1 {\n\t\t\t\tm.cursor++\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyUp || (msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'k'):\n\t\t\tif !m.inCommentsView && m.cursor > 0 {\n\t\t\t\tm.cursor--\n\t\t\t\tm.detailScrollY = 0 // Reset detail scroll when changing issue\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'q':\n\t\t\t// In comments view, 'q' returns to issue list; otherwise, quit\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.inCommentsView = false\n\t\t\t\tm.commentsScrollY = 0\n\t\t\t} else {\n\t\t\t\treturn m, tea.Quit\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 's':\n\t\t\t// Cycle sort field (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortField = config.NextSortField(m.sortField)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'S':\n\t\t\t// Toggle sort order (only in issue list view)\n\t\t\tif !m.inCommentsView {\n\t\t\t\tm.sortOrder = config.ToggleSortOrder(m.sortOrder)\n\t\t\t\tm.sortIssues()\n\t\t\t\tm.cursor = 0 // Reset cursor after sort change\n\t\t\t\tm.sortChanged = true\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'm':\n\t\t\t// Toggle raw/rendered markdown\n\t\t\tm.rawMarkdown = !m.rawMarkdown\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'l':\n\t\t\t// Scroll down - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tm.commentsScrollY++\n\t\t\t} else {\n\t\t\t\tm.detailScrollY++\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && msg.Runes[0] == 'h':\n\t\t\t// Scroll up - either detail panel or comments view\n\t\t\tif m.inCommentsView {\n\t\t\t\tif m.commentsScrollY > 0 {\n\t\t\t\t\tm.commentsScrollY--\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif m.detailScrollY > 0 {\n\t\t\t\t\tm.detailScrollY--\n\t\t\t\t}\n\t\t\t}\n\t\tcase msg.Type == tea.KeyRunes && len(msg.Runes) > 0 && (msg.Runes[0] == 'r' || msg.Runes[0] == 'R'):\n\t\t\t// Trigger refresh (only in issue list view, not while already refreshing)\n\t\t\tif !m.inCommentsView && !m.isRefreshing {\n\t\t\t\tm.isRefreshing = true\n\t\t\t\tm.refreshError = \"\" // Clear previous error\n\t\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\t\tif m.refreshFunc != nil {\n\t\t\t\t\treturn m, m.refreshFunc\n\t\t\t\t}\n\t\t\t\treturn m, nil\n\t\t\t}\n\t\t}\n\tcase tea.WindowSizeMsg:\n\t\tm.width = msg.Width\n\t\tm.height = msg.Height\n\tcase RefreshProgressMsg:\n\t\tm.refreshProgress = msg.Progress\n\tcase RefreshDoneMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\t// Remember the currently selected issue number\n\t\tvar selectedNumber int\n\t\tif m.cursor < len(m.issues) {\n\t\t\tselectedNumber = m.issues[m.cursor].Number\n\t\t}\n\t\t// Update issues\n\t\tm.issues = make([]github.Issue, len(msg.Issues))\n\t\tcopy(m.issues, msg.Issues)\n\t\tm.sortIssues()\n\t\t// Try to restore cursor to the same issue\n\t\tm.cursor = 0\n\t\tfor i, issue := range m.issues {\n\t\t\tif issue.Number == selectedNumber {\n\t\t\t\tm.cursor = i\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Update last sync time\n\t\tif !msg.LastSyncTime.IsZero() {\n\t\t\tm.lastSyncTime = msg.LastSyncTime\n\t\t}\n\tcase RefreshErrorMsg:\n\t\tm.isRefreshing = false\n\t\tm.refreshProgress = RefreshProgress{}\n\t\tif msg.Err != nil {\n\t\t\tm.refreshError = msg.Err.Error()\n\t\t}\n\tcase CriticalErrorMsg:\n\t\t// Show error modal for critical errors\n\t\tm.showErrorModal = true\n\t\tm.errorModalTitle = msg.Title\n\t\tif msg.Err != nil {\n\t\t\tm.errorModalMessage = msg.Err.Error()\n\t\t}\n\t\tm.errorModalGuidance = msg.Guidance\n\tcase RefreshStartMsg:\n\t\t// Auto-refresh trigger from Init\n\t\tif !m.isRefreshing {\n\t\t\tm.isRefreshing = true\n\t\t\tm.refreshError = \"\"\n\t\t\tm.refreshProgress = RefreshProgress{}\n\t\t\tif m.refreshFunc != nil {\n\t\t\t\treturn m, m.refreshFunc\n\t\t\t}\n\t\t}\n\t}\n\treturn m, nil\n}\n\n// View renders the TUI\nfunc (m Model) View() string {\n\tif m.width == 0 {\n\t\treturn \"\"\n\t}\n\n\t// If error modal is shown, render it over everything\n\tif m.showErrorModal {\n\t\treturn m.renderErrorModal()\n\t}\n\n\t// If in comments view, render the drill-down view instead\n\tif m.inCommentsView {\n\t\treturn m.renderCommentsView()\n\t}\n\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\terrorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\n\t// Title\n\ttitle := titleStyle.Render(\"GitHub Issues\")\n\tb.WriteString(title)\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty state\n\tif len(m.issues) == 0 {\n\t\tb.WriteString(\"No issues found. Run 'ghissues sync' to fetch issues.\\n\")\n\t} else {\n\t\t// Calculate the panel widths (50/50 split, or use available space)\n\t\tlistWidth := m.width / 2\n\t\tdetailWidth := m.width - listWidth - 3 // 3 for separator\n\n\t\t// Render issue list panel\n\t\tlistPanel := m.renderIssueListPanel(listWidth)\n\n\t\t// Render detail panel\n\t\tdetailPanel := m.renderDetailPanel(detailWidth)\n\n\t\t// Combine panels side by side\n\t\tlistLines := strings.Split(listPanel, \"\\n\")\n\t\tdetailLines := strings.Split(detailPanel, \"\\n\")\n\n\t\t// Get the max lines to display\n\t\tmaxLines := max(len(listLines), len(detailLines))\n\t\tcontentHeight := m.height - 6 // Account for title, status\n\t\tif contentHeight < 5 {\n\t\t\tcontentHeight = 15\n\t\t}\n\t\tmaxLines = min(maxLines, contentHeight)\n\n\t\tfor i := 0; i < maxLines; i++ {\n\t\t\tlistLine := \"\"\n\t\t\tif i < len(listLines) {\n\t\t\t\tlistLine = listLines[i]\n\t\t\t}\n\t\t\t// Pad list line to width\n\t\t\tlistLine = padToWidth(listLine, listWidth)\n\n\t\t\tdetailLine := \"\"\n\t\t\tif i < len(detailLines) {\n\t\t\t\tdetailLine = detailLines[i]\n\t\t\t}\n\n\t\t\tb.WriteString(listLine)\n\t\t\tb.WriteString(\" │ \")\n\t\t\tb.WriteString(detailLine)\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tsortIndicator := \"↓\"\n\tif m.sortOrder == config.SortAsc {\n\t\tsortIndicator = \"↑\"\n\t}\n\n\t// Build status line with refresh indicator or error\n\tvar status string\n\tif m.isRefreshing {\n\t\tif m.refreshProgress.Total > 0 {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing %s: %d/%d | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tm.refreshProgress.Phase, m.refreshProgress.Current, m.refreshProgress.Total,\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t} else {\n\t\t\tstatus = fmt.Sprintf(\"Refreshing... | %d issues | %s %s | r: refresh | q: quit\",\n\t\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\t}\n\t\tb.WriteString(statusStyle.Render(status))\n\t} else if m.refreshError != \"\" {\n\t\t// Show minor error in status bar with retry hint\n\t\terrMsg := m.refreshError\n\t\t// Truncate if too long for status bar\n\t\tmaxErrLen := m.width - 30\n\t\tif maxErrLen < 20 {\n\t\t\tmaxErrLen = 40\n\t\t}\n\t\tif len(errMsg) > maxErrLen {\n\t\t\terrMsg = errMsg[:maxErrLen-3] + \"...\"\n\t\t}\n\t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n\t\tb.WriteString(errorStyle.Render(status))\n\t} else {\n\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n\t\tb.WriteString(statusStyle.Render(status))\n\t}\n\n\treturn b.String()\n}\n\n// renderIssueListPanel renders the left panel with the issue list\nfunc (m Model) renderIssueListPanel(width int) string {\n\tvar b strings.Builder\n\n\tselectedStyle := lipgloss.NewStyle().Bold(true).Background(lipgloss.Color(\"238\"))\n\tnormalStyle := lipgloss.NewStyle()\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\n\t// Render header\n\theader := fmt.Sprintf(\"  %-6s %-*s\", \"#\", width-10, \"Title\")\n\tb.WriteString(headerStyle.Render(header))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"─\", width))\n\tb.WriteString(\"\\n\")\n\n\t// Calculate visible height\n\tvisibleHeight := m.height - 8\n\tif visibleHeight < 1 {\n\t\tvisibleHeight = 10\n\t}\n\n\tstartIdx := 0\n\tif m.cursor >= visibleHeight {\n\t\tstartIdx = m.cursor - visibleHeight + 1\n\t}\n\n\tendIdx := min(startIdx+visibleHeight, len(m.issues))\n\n\tfor i := startIdx; i < endIdx; i++ {\n\t\tissue := m.issues[i]\n\t\ttitleWidth := width - 12\n\t\ttitle := issue.Title\n\t\tif len(title) > titleWidth {\n\t\t\ttitle = title[:titleWidth-3] + \"...\"\n\t\t}\n\t\trow := fmt.Sprintf(\"#%-5d %-*s\", issue.Number, titleWidth, title)\n\n\t\tif i == m.cursor {\n\t\t\tb.WriteString(selectedStyle.Render(\"> \" + row))\n\t\t} else {\n\t\t\tb.WriteString(normalStyle.Render(\"  \" + row))\n\t\t}\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\treturn b.String()\n}\n\n// renderDetailPanel renders the right panel with issue details\nfunc (m Model) renderDetailPanel(width int) string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tlabelStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"86\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Issue header: number and title\n\tb.WriteString(headerStyle.Render(fmt.Sprintf(\"#%d\", issue.Number)))\n\tb.WriteString(\" \")\n\ttitle := issue.Title\n\tif len(title) > width-10 {\n\t\ttitle = title[:width-13] + \"...\"\n\t}\n\tb.WriteString(headerStyle.Render(title))\n\tb.WriteString(\"\\n\")\n\n\t// Author\n\tb.WriteString(dimStyle.Render(\"Author: \"))\n\tb.WriteString(issue.Author.Login)\n\tb.WriteString(\"\\n\")\n\n\t// Dates\n\tcreatedAt, _ := time.Parse(time.RFC3339, issue.CreatedAt)\n\tupdatedAt, _ := time.Parse(time.RFC3339, issue.UpdatedAt)\n\tb.WriteString(dimStyle.Render(\"Created: \"))\n\tb.WriteString(createdAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"  \")\n\tb.WriteString(dimStyle.Render(\"Updated: \"))\n\tb.WriteString(updatedAt.Format(\"2006-01-02\"))\n\tb.WriteString(\"\\n\")\n\n\t// Labels\n\tif len(issue.Labels) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Labels: \"))\n\t\tvar labels []string\n\t\tfor _, label := range issue.Labels {\n\t\t\tlabels = append(labels, labelStyle.Render(label.Name))\n\t\t}\n\t\tb.WriteString(strings.Join(labels, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Assignees\n\tif len(issue.Assignees) > 0 {\n\t\tb.WriteString(dimStyle.Render(\"Assignees: \"))\n\t\tvar assignees []string\n\t\tfor _, a := range issue.Assignees {\n\t\t\tassignees = append(assignees, a.Login)\n\t\t}\n\t\tb.WriteString(strings.Join(assignees, \", \"))\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Separator\n\tb.WriteString(strings.Repeat(\"─\", min(width, 60)))\n\tb.WriteString(\"\\n\")\n\n\t// Body\n\tif issue.Body != \"\" {\n\t\tbodyContent := m.renderBody(issue.Body)\n\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\n\t\t// Apply scroll offset\n\t\tstartLine := m.detailScrollY\n\t\tif startLine >= len(bodyLines) {\n\t\t\tstartLine = max(0, len(bodyLines)-1)\n\t\t}\n\n\t\t// Calculate visible body height\n\t\tvisibleHeight := m.height - 15\n\t\tif visibleHeight < 3 {\n\t\t\tvisibleHeight = 5\n\t\t}\n\n\t\tendLine := min(startLine+visibleHeight, len(bodyLines))\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(bodyLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\treturn b.String()\n}\n\n// renderBody renders the issue body, either raw or with glamour\nfunc (m Model) renderBody(body string) string {\n\tif m.rawMarkdown {\n\t\treturn body\n\t}\n\n\t// Render markdown with glamour\n\tif m.glamourRenderer != nil {\n\t\trendered, err := m.glamourRenderer.Render(body)\n\t\tif err == nil {\n\t\t\treturn strings.TrimSpace(rendered)\n\t\t}\n\t}\n\n\t// Fallback to raw if rendering fails\n\treturn body\n}\n\n// renderCommentsView renders the full-screen comments drill-down view\nfunc (m Model) renderCommentsView() string {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn \"No issue selected\"\n\t}\n\n\tissue := m.issues[m.cursor]\n\tvar b strings.Builder\n\n\t// Styles\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"86\"))\n\theaderStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"39\"))\n\tauthorStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"208\"))\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\tstatusStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Title: Issue number and title\n\tb.WriteString(titleStyle.Render(fmt.Sprintf(\"Comments for #%d: %s\", issue.Number, issue.Title)))\n\tb.WriteString(\"\\n\")\n\tb.WriteString(strings.Repeat(\"═\", min(m.width, 80)))\n\tb.WriteString(\"\\n\\n\")\n\n\t// Handle empty comments\n\tif len(m.comments) == 0 {\n\t\tb.WriteString(dimStyle.Render(\"No comments on this issue.\"))\n\t\tb.WriteString(\"\\n\")\n\t} else {\n\t\t// Render comments\n\t\tvar allCommentLines []string\n\n\t\tfor i, comment := range m.comments {\n\t\t\t// Comment header: author and date\n\t\t\tcreatedAt, _ := time.Parse(time.RFC3339, comment.CreatedAt)\n\t\t\theader := fmt.Sprintf(\"%s  %s\",\n\t\t\t\tauthorStyle.Render(comment.Author.Login),\n\t\t\t\tdimStyle.Render(createdAt.Format(\"2006-01-02 15:04\")))\n\t\t\tallCommentLines = append(allCommentLines, header)\n\n\t\t\t// Comment body\n\t\t\tbodyContent := m.renderBody(comment.Body)\n\t\t\tbodyLines := strings.Split(bodyContent, \"\\n\")\n\t\t\tallCommentLines = append(allCommentLines, bodyLines...)\n\n\t\t\t// Add separator between comments (except after last one)\n\t\t\tif i < len(m.comments)-1 {\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t\tallCommentLines = append(allCommentLines, headerStyle.Render(strings.Repeat(\"─\", min(m.width-4, 60))))\n\t\t\t\tallCommentLines = append(allCommentLines, \"\")\n\t\t\t}\n\t\t}\n\n\t\t// Apply scroll offset\n\t\tvisibleHeight := m.height - 8 // Account for header and status bar\n\t\tif visibleHeight < 5 {\n\t\t\tvisibleHeight = 10\n\t\t}\n\n\t\tstartLine := m.commentsScrollY\n\t\tif startLine >= len(allCommentLines) {\n\t\t\tstartLine = max(0, len(allCommentLines)-1)\n\t\t}\n\t\tendLine := min(startLine+visibleHeight, len(allCommentLines))\n\n\t\tfor i := startLine; i < endLine; i++ {\n\t\t\tb.WriteString(allCommentLines[i])\n\t\t\tb.WriteString(\"\\n\")\n\t\t}\n\t}\n\n\t// Status bar\n\tb.WriteString(\"\\n\")\n\tstatus := fmt.Sprintf(\"%d comments | m: toggle markdown | h/l: scroll | Esc/q: back\",\n\t\tlen(m.comments))\n\tb.WriteString(statusStyle.Render(status))\n\n\treturn b.String()\n}\n\n// renderErrorModal renders a modal dialog for critical errors\nfunc (m Model) renderErrorModal() string {\n\tvar b strings.Builder\n\n\t// Styles for the error modal\n\ttitleStyle := lipgloss.NewStyle().Bold(true).Foreground(lipgloss.Color(\"196\"))\n\tborderStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"196\"))\n\tmessageStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"255\"))\n\tguidanceStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"226\")).Italic(true)\n\tdimStyle := lipgloss.NewStyle().Foreground(lipgloss.Color(\"241\"))\n\n\t// Calculate modal dimensions\n\tmodalWidth := min(m.width-4, 70)\n\tif modalWidth < 40 {\n\t\tmodalWidth = 40\n\t}\n\n\t// Calculate padding for centering\n\tleftPadding := (m.width - modalWidth) / 2\n\tif leftPadding < 0 {\n\t\tleftPadding = 0\n\t}\n\tpad := strings.Repeat(\" \", leftPadding)\n\n\t// Top spacing for vertical centering\n\ttopPadding := (m.height - 12) / 2\n\tif topPadding < 2 {\n\t\ttopPadding = 2\n\t}\n\tfor i := 0; i < topPadding; i++ {\n\t\tb.WriteString(\"\\n\")\n\t}\n\n\t// Top border\n\ttopBorder := \"╔\" + strings.Repeat(\"═\", modalWidth-2) + \"╗\"\n\tb.WriteString(pad + borderStyle.Render(topBorder) + \"\\n\")\n\n\t// Title line\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + titleStyle.Render(m.errorModalTitle) + strings.Repeat(\" \", max(0, modalWidth-4-len(m.errorModalTitle))) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Separator line\n\tsepLine := \"║\" + strings.Repeat(\"─\", modalWidth-2) + \"║\"\n\tb.WriteString(pad + borderStyle.Render(sepLine) + \"\\n\")\n\n\t// Message - wrap to fit modal width\n\tmsgWidth := modalWidth - 4\n\tmsgLines := wrapText(m.errorModalMessage, msgWidth)\n\tfor _, line := range msgLines {\n\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + messageStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Empty line before guidance\n\temptyLine := strings.Repeat(\" \", modalWidth-2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Guidance if present\n\tif m.errorModalGuidance != \"\" {\n\t\tguidanceLines := wrapText(m.errorModalGuidance, msgWidth)\n\t\tfor _, line := range guidanceLines {\n\t\t\tpaddedLine := line + strings.Repeat(\" \", max(0, msgWidth-len(line)))\n\t\t\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + guidanceStyle.Render(paddedLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\t\t}\n\t\tb.WriteString(pad + borderStyle.Render(\"║\") + emptyLine + borderStyle.Render(\"║\") + \"\\n\")\n\t}\n\n\t// Instructions line\n\tinstructions := \"Press Enter or Esc to dismiss\"\n\tinstrPadLen := modalWidth - 4 - len(instructions)\n\tif instrPadLen < 0 {\n\t\tinstrPadLen = 0\n\t}\n\tinstrLine := strings.Repeat(\" \", instrPadLen/2) + instructions + strings.Repeat(\" \", instrPadLen-instrPadLen/2)\n\tb.WriteString(pad + borderStyle.Render(\"║\") + \" \" + dimStyle.Render(instrLine) + \" \" + borderStyle.Render(\"║\") + \"\\n\")\n\n\t// Bottom border\n\tbottomBorder := \"╚\" + strings.Repeat(\"═\", modalWidth-2) + \"╝\"\n\tb.WriteString(pad + borderStyle.Render(bottomBorder) + \"\\n\")\n\n\treturn b.String()\n}\n\n// wrapText wraps text to fit within a specified width\nfunc wrapText(text string, width int) []string {\n\tif width <= 0 {\n\t\treturn []string{text}\n\t}\n\n\tvar lines []string\n\twords := strings.Fields(text)\n\tif len(words) == 0 {\n\t\treturn []string{}\n\t}\n\n\tcurrentLine := words[0]\n\tfor _, word := range words[1:] {\n\t\tif len(currentLine)+1+len(word) <= width {\n\t\t\tcurrentLine += \" \" + word\n\t\t} else {\n\t\t\tlines = append(lines, currentLine)\n\t\t\tcurrentLine = word\n\t\t}\n\t}\n\tlines = append(lines, currentLine)\n\treturn lines\n}\n\n// padToWidth pads a string to a specific width, accounting for ANSI codes\nfunc padToWidth(s string, width int) string {\n\t// Get visual width (lipgloss handles ANSI codes)\n\tvisualWidth := lipgloss.Width(s)\n\tif visualWidth >= width {\n\t\treturn s\n\t}\n\treturn s + strings.Repeat(\" \", width-visualWidth)\n}\n\n// SelectedIssue returns the currently selected issue, or nil if no issues\nfunc (m Model) SelectedIssue() *github.Issue {\n\tif len(m.issues) == 0 || m.cursor >= len(m.issues) {\n\t\treturn nil\n\t}\n\treturn &m.issues[m.cursor]\n}\n\n// IssueCount returns the total number of issues\nfunc (m Model) IssueCount() int {\n\treturn len(m.issues)\n}\n\n// SetWindowSize sets the terminal window size\nfunc (m *Model) SetWindowSize(width, height int) {\n\tm.width = width\n\tm.height = height\n}\n\n// GetSortConfig returns the current sort field and order\nfunc (m Model) GetSortConfig() (config.SortField, config.SortOrder) {\n\treturn m.sortField, m.sortOrder\n}\n\n// SortChanged returns true if the sort settings were changed during the session\nfunc (m Model) SortChanged() bool {\n\treturn m.sortChanged\n}\n\n// IsRawMarkdown returns whether the detail panel is showing raw markdown\nfunc (m Model) IsRawMarkdown() bool {\n\treturn m.rawMarkdown\n}\n\n// DetailScrollOffset returns the current scroll offset for the detail panel\nfunc (m Model) DetailScrollOffset() int {\n\treturn m.detailScrollY\n}\n\n// InCommentsView returns whether the comments view is active\nfunc (m Model) InCommentsView() bool {\n\treturn m.inCommentsView\n}\n\n// SetComments sets the comments for the currently selected issue\nfunc (m *Model) SetComments(comments []github.Comment) {\n\tm.comments = comments\n\tm.commentsScrollY = 0 // Reset scroll when setting new comments\n}\n\n// GetComments returns the current comments\nfunc (m Model) GetComments() []github.Comment {\n\treturn m.comments\n}\n\n// CommentsScrollOffset returns the current scroll offset for the comments view\nfunc (m Model) CommentsScrollOffset() int {\n\treturn m.commentsScrollY\n}\n\n// IsRefreshing returns whether a refresh is in progress\nfunc (m Model) IsRefreshing() bool {\n\treturn m.isRefreshing\n}\n\n// GetRefreshProgress returns the current refresh progress\nfunc (m Model) GetRefreshProgress() RefreshProgress {\n\treturn m.refreshProgress\n}\n\n// GetRefreshError returns the last refresh error message\nfunc (m Model) GetRefreshError() string {\n\treturn m.refreshError\n}\n\n// SetRefreshFunc sets the function to be called when refresh is triggered\nfunc (m *Model) SetRefreshFunc(fn func() tea.Msg) {\n\tm.refreshFunc = fn\n}\n\n// HasErrorModal returns whether the error modal is visible\nfunc (m Model) HasErrorModal() bool {\n\treturn m.showErrorModal\n}\n\n// GetErrorModalTitle returns the title of the error modal\nfunc (m Model) GetErrorModalTitle() string {\n\treturn m.errorModalTitle\n}\n\n// GetErrorModalMessage returns the error message in the modal\nfunc (m Model) GetErrorModalMessage() string {\n\treturn m.errorModalMessage\n}\n\n// GetErrorModalGuidance returns the guidance text for the error modal\nfunc (m Model) GetErrorModalGuidance() string {\n\treturn m.errorModalGuidance\n}\n\n// SetLastSyncTime sets the last sync time\nfunc (m *Model) SetLastSyncTime(t time.Time) {\n\tm.lastSyncTime = t\n}\n\n// GetLastSyncTime returns the last sync time (zero value if never synced)\nfunc (m Model) GetLastSyncTime() time.Time {\n\treturn m.lastSyncTime\n}\n\n// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")\nfunc formatRelativeTime(t time.Time) string {\n\tif t.IsZero() {\n\t\treturn \"never\"\n\t}\n\n\tdiff := time.Since(t)\n\n\tif diff < time.Minute {\n\t\treturn \"<1m ago\"\n\t}\n\tif diff < time.Hour {\n\t\tminutes := int(diff.Minutes())\n\t\treturn fmt.Sprintf(\"%dm ago\", minutes)\n\t}\n\tif diff < 24*time.Hour {\n\t\thours := int(diff.Hours())\n\t\treturn fmt.Sprintf(\"%dh ago\", hours)\n\t}\n\tdays := int(diff.Hours() / 24)\n\treturn fmt.Sprintf(\"%dd ago\", days)\n}\n\n// sortIssues sorts the issues based on the current sort field and order\nfunc (m *Model) sortIssues() {\n\tif len(m.issues) == 0 {\n\t\treturn\n\t}\n\n\tsort.Slice(m.issues, func(i, j int) bool {\n\t\tvar less bool\n\n\t\tswitch m.sortField {\n\t\tcase config.SortByUpdated:\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByCreated:\n\t\t\tti, _ := m.issues[i].CreatedAtTime()\n\t\t\ttj, _ := m.issues[j].CreatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\tcase config.SortByNumber:\n\t\t\tless = m.issues[i].Number < m.issues[j].Number\n\t\tcase config.SortByComments:\n\t\t\tless = m.issues[i].CommentCount < m.issues[j].CommentCount\n\t\tdefault:\n\t\t\t// Default to updated date\n\t\t\tti, _ := m.issues[i].UpdatedAtTime()\n\t\t\ttj, _ := m.issues[j].UpdatedAtTime()\n\t\t\tless = ti.Before(tj)\n\t\t}\n\n\t\t// Descending order reverses the comparison\n\t\tif m.sortOrder == config.SortDesc {\n\t\t\treturn !less\n\t\t}\n\t\treturn less\n\t})\n}\n","structuredPatch":[{"oldStart":378,"oldLines":6,"newStart":378,"newLines":9,"lines":["     sortIndicator = \"↑\"","   }"," ","+  // Format last sync time","+  lastSyncedStr := formatRelativeTime(m.lastSyncTime)","+","   // Build status line with refresh indicator or error","   var status string","   if m.isRefreshing {"]},{"oldStart":404,"oldLines":8,"newStart":407,"newLines":8,"lines":["     status = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)","     b.WriteString(errorStyle.Render(status))","   } else {","-    status = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",","-      len(m.issues), m.sortField.DisplayName(), sortIndicator)","+    status = fmt.Sprintf(\"Last synced: %s | %d issues | %s %s | r: refresh | q: quit\",","+      lastSyncedStr, len(m.issues), m.sortField.DisplayName(), sortIndicator)","     b.WriteString(statusStyle.Render(status))","   }"," "]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J8RHZebdXDwgqb4RtvXXDw","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to add the `time` import to the test file:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1208,"cache_read_input_tokens":83556,"cache_creation":{"ephemeral_5m_input_tokens":1208,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"d00cd452-eb4f-409c-80b0-7d62dfd5765d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01J8RHZebdXDwgqb4RtvXXDw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01WyUfiZHRfsrk3tDD3MTj4F","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go","old_string":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)","new_string":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1208,"cache_read_input_tokens":83556,"cache_creation":{"ephemeral_5m_input_tokens":1208,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"539dbc7e-e837-4f42-86b6-8e517a85abfd"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01WyUfiZHRfsrk3tDD3MTj4F","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/tui/model_test.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"50eb0a99-3ab9-4c48-88d5-857ee62f2e37","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/tui/model_test.go","oldString":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)","newString":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)","originalFile":"package tui\n\nimport (\n\t\"fmt\"\n\t\"testing\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n)\n\nfunc createTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"First issue\",\n\t\t\tAuthor:       github.User{Login: \"user1\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t\t{\n\t\t\tNumber:       2,\n\t\t\tTitle:        \"Second issue\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-02T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-16T12:00:00Z\",\n\t\t\tCommentCount: 3,\n\t\t},\n\t\t{\n\t\t\tNumber:       3,\n\t\t\tTitle:        \"Third issue\",\n\t\t\tAuthor:       github.User{Login: \"user3\"},\n\t\t\tCreatedAt:    \"2024-01-03T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-17T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n}\n\nfunc TestNewModel(t *testing.T) {\n\tissues := createTestIssues()\n\tcolumns := []string{\"number\", \"title\", \"author\"}\n\n\tm := NewModel(issues, columns)\n\n\t// Issues are sorted by updated date descending by default\n\t// createTestIssues has: 1 (Jan 15), 2 (Jan 16), 3 (Jan 17)\n\t// So sorted: 3, 2, 1\n\tassert.Equal(t, 3, m.issues[0].Number)\n\tassert.Equal(t, 2, m.issues[1].Number)\n\tassert.Equal(t, 1, m.issues[2].Number)\n\tassert.Equal(t, columns, m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestNewModelEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tassert.Empty(t, m.issues)\n\tassert.Equal(t, DefaultColumns(), m.columns)\n\tassert.Equal(t, 0, m.cursor)\n\tassert.Equal(t, 0, m.IssueCount())\n}\n\nfunc TestModelNavigationDown(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial cursor position\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Move down with j key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move down with down arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n\n\t// Should not go past last item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.Equal(t, 2, m.cursor)\n}\n\nfunc TestModelNavigationUp(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.cursor = 2 // Start at bottom\n\n\t// Move up with k key\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, 1, m.cursor)\n\n\t// Move up with up arrow\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n\n\t// Should not go past first item\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyUp})\n\tm = newModel.(Model)\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestModelQuitKeys(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// q should quit\n\t_, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\trequire.NotNil(t, cmd)\n\tmsg := cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n\n\t// Ctrl+C should quit\n\t_, cmd = m.Update(tea.KeyMsg{Type: tea.KeyCtrlC})\n\trequire.NotNil(t, cmd)\n\tmsg = cmd()\n\tassert.IsType(t, tea.QuitMsg{}, msg)\n}\n\nfunc TestModelSelectedIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Get selected issue at cursor 0\n\t// Default sort is by updated date descending, so issue 3 is first (most recently updated)\n\tissue := m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 3, issue.Number)\n\tassert.Equal(t, \"Third issue\", issue.Title)\n\n\t// Move cursor and check again\n\tm.cursor = 1\n\tissue = m.SelectedIssue()\n\trequire.NotNil(t, issue)\n\tassert.Equal(t, 2, issue.Number) // Second most recently updated\n}\n\nfunc TestModelSelectedIssueEmpty(t *testing.T) {\n\tm := NewModel(nil, nil)\n\n\tissue := m.SelectedIssue()\n\tassert.Nil(t, issue)\n}\n\nfunc TestModelIssueCount(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tissues   []github.Issue\n\t\texpected int\n\t}{\n\t\t{name: \"three issues\", issues: createTestIssues(), expected: 3},\n\t\t{name: \"empty\", issues: nil, expected: 0},\n\t\t{name: \"one issue\", issues: []github.Issue{{Number: 1}}, expected: 1},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tm := NewModel(tt.issues, nil)\n\t\t\tassert.Equal(t, tt.expected, m.IssueCount())\n\t\t})\n\t}\n}\n\nfunc TestModelSetWindowSize(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tm.SetWindowSize(100, 50)\n\n\tassert.Equal(t, 100, m.width)\n\tassert.Equal(t, 50, m.height)\n}\n\nfunc TestModelWindowSizeMsg(t *testing.T) {\n\tm := NewModel(createTestIssues(), nil)\n\n\tnewModel, _ := m.Update(tea.WindowSizeMsg{Width: 120, Height: 40})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 120, m.width)\n\tassert.Equal(t, 40, m.height)\n}\n\nfunc TestDefaultColumns(t *testing.T) {\n\tcols := DefaultColumns()\n\tassert.Equal(t, []string{\"number\", \"title\", \"author\", \"date\", \"comments\"}, cols)\n}\n\nfunc TestModelViewContainsIssueCount(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Status area should show issue count\n\tassert.Contains(t, view, \"3 issues\")\n}\n\nfunc TestModelViewContainsSelectedHighlight(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Selected issue should be in the view\n\tassert.Contains(t, view, \"First issue\")\n}\n\nfunc TestModelViewEmptyState(t *testing.T) {\n\tm := NewModel(nil, nil)\n\tm.SetWindowSize(80, 24)\n\n\tview := m.View()\n\n\t// Should show no issues message\n\tassert.Contains(t, view, \"No issues\")\n\tassert.Contains(t, view, \"0 issues\")\n}\n\n// Helper to create test issues with varied dates and counts for sorting tests\nfunc createSortTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       10,\n\t\t\tTitle:        \"Issue ten\",\n\t\t\tAuthor:       github.User{Login: \"alice\"},\n\t\t\tCreatedAt:    \"2024-01-05T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T12:00:00Z\",\n\t\t\tCommentCount: 2,\n\t\t},\n\t\t{\n\t\t\tNumber:       5,\n\t\t\tTitle:        \"Issue five\",\n\t\t\tAuthor:       github.User{Login: \"bob\"},\n\t\t\tCreatedAt:    \"2024-01-10T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-15T12:00:00Z\",\n\t\t\tCommentCount: 10,\n\t\t},\n\t\t{\n\t\t\tNumber:       15,\n\t\t\tTitle:        \"Issue fifteen\",\n\t\t\tAuthor:       github.User{Login: \"charlie\"},\n\t\t\tCreatedAt:    \"2024-01-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-25T12:00:00Z\",\n\t\t\tCommentCount: 5,\n\t\t},\n\t}\n}\n\nfunc TestNewModelWithSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestDefaultSortIsUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default sort should be by updated date descending (most recently updated first)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// First issue should be the most recently updated (issue 15)\n\tselected := m.SelectedIssue()\n\trequire.NotNil(t, selected)\n\tassert.Equal(t, 15, selected.Number)\n}\n\nfunc TestSortByUpdatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortDesc)\n\tm.SetWindowSize(80, 24)\n\n\t// Most recently updated first: 15 (Jan 25), 10 (Jan 20), 5 (Jan 15)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByUpdatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByUpdated, config.SortAsc)\n\n\t// Oldest updated first: 5 (Jan 15), 10 (Jan 20), 15 (Jan 25)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortDesc)\n\n\t// Most recently created first: 5 (Jan 10), 10 (Jan 5), 15 (Jan 1)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCreatedAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByCreated, config.SortAsc)\n\n\t// Oldest created first: 15 (Jan 1), 10 (Jan 5), 5 (Jan 10)\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortDesc)\n\n\t// Highest number first: 15, 10, 5\n\tassert.Equal(t, 15, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestSortByNumberAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\n\t// Lowest number first: 5, 10, 15\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 10, m.issues[1].Number)\n\tassert.Equal(t, 15, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsDescending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortDesc)\n\n\t// Most comments first: 5 (10 comments), 15 (5 comments), 10 (2 comments)\n\tassert.Equal(t, 5, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 10, m.issues[2].Number)\n}\n\nfunc TestSortByCommentsAscending(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\t// Fewest comments first: 10 (2 comments), 15 (5 comments), 5 (10 comments)\n\tassert.Equal(t, 10, m.issues[0].Number)\n\tassert.Equal(t, 15, m.issues[1].Number)\n\tassert.Equal(t, 5, m.issues[2].Number)\n}\n\nfunc TestCycleSortFieldWithSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial sort: updated\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n\n\t// Press 's' to cycle to created\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByCreated, m.sortField)\n\n\t// Press 's' to cycle to number\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByNumber, m.sortField)\n\n\t// Press 's' to cycle to comments\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByComments, m.sortField)\n\n\t// Press 's' to wrap back to updated\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortByUpdated, m.sortField)\n}\n\nfunc TestReverseSortOrderWithShiftSKey(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Initial order: descending\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n\n\t// Press 'S' to toggle to ascending\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortAsc, m.sortOrder)\n\n\t// Press 'S' to toggle back to descending\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, config.SortDesc, m.sortOrder)\n}\n\nfunc TestSortReordersIssuesAndResetsCursor(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Move cursor to second item\n\tm.cursor = 1\n\n\t// Press 's' to change sort\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\t// Cursor should reset to 0 after sort change\n\tassert.Equal(t, 0, m.cursor)\n}\n\nfunc TestStatusBarShowsCurrentSort(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\t// Status bar should show current sort field and order\n\tassert.Contains(t, view, \"Updated\")\n\tassert.Contains(t, view, \"↓\") // Descending indicator\n}\n\nfunc TestStatusBarShowsAscendingIndicator(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByNumber, config.SortAsc)\n\tm.SetWindowSize(120, 24)\n\n\tview := m.View()\n\n\tassert.Contains(t, view, \"Number\")\n\tassert.Contains(t, view, \"↑\") // Ascending indicator\n}\n\nfunc TestGetSortConfig(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModelWithSort(issues, nil, config.SortByComments, config.SortAsc)\n\n\tfield, order := m.GetSortConfig()\n\n\tassert.Equal(t, config.SortByComments, field)\n\tassert.Equal(t, config.SortAsc, order)\n}\n\nfunc TestSortChangedInitiallyFalse(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\tassert.False(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterCycleField(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 's' to cycle sort field\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'s'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\nfunc TestSortChangedAfterToggleOrder(t *testing.T) {\n\tissues := createSortTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Press 'S' to toggle sort order\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'S'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.SortChanged())\n}\n\n// Helper to create test issues with body content for detail view tests\nfunc createDetailTestIssues() []github.Issue {\n\treturn []github.Issue{\n\t\t{\n\t\t\tNumber:       42,\n\t\t\tTitle:        \"Test issue with markdown body\",\n\t\t\tBody:         \"## Description\\n\\nThis is a **bold** description with `code`.\\n\\n- Item 1\\n- Item 2\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 5,\n\t\t\tLabels:       []github.Label{{Name: \"bug\", Color: \"d73a4a\"}, {Name: \"priority\", Color: \"0052cc\"}},\n\t\t\tAssignees:    []github.User{{Login: \"assignee1\"}, {Login: \"assignee2\"}},\n\t\t},\n\t\t{\n\t\t\tNumber:       43,\n\t\t\tTitle:        \"Another issue\",\n\t\t\tBody:         \"Simple body text\",\n\t\t\tAuthor:       github.User{Login: \"user2\"},\n\t\t\tCreatedAt:    \"2024-01-16T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-21T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t\tLabels:       nil,\n\t\t\tAssignees:    nil,\n\t\t},\n\t}\n}\n\nfunc TestDetailPanelShowsSelectedIssue(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\tview := m.View()\n\n\t// Detail panel should show the selected issue info\n\t// Issue 43 is first because it has a more recent UpdatedAt date\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n\tassert.Contains(t, view, \"user2\")\n}\n\nfunc TestDetailPanelShowsHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Header should show: issue number, title, author, status indicators\n\tassert.Contains(t, view, \"#42\")\n\tassert.Contains(t, view, \"Test issue with markdown body\")\n\tassert.Contains(t, view, \"testuser\")\n}\n\nfunc TestDetailPanelShowsDates(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show created and updated dates\n\tassert.Contains(t, view, \"2024-01-15\")\n\tassert.Contains(t, view, \"2024-01-20\")\n}\n\nfunc TestDetailPanelShowsLabels(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show labels\n\tassert.Contains(t, view, \"bug\")\n\tassert.Contains(t, view, \"priority\")\n}\n\nfunc TestDetailPanelShowsAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show assignees\n\tassert.Contains(t, view, \"assignee1\")\n\tassert.Contains(t, view, \"assignee2\")\n}\n\nfunc TestDetailPanelShowsBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show body content (rendered markdown may have transformed text)\n\tassert.Contains(t, view, \"Description\")\n}\n\nfunc TestDetailPanelToggleRawMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Select issue 42 (second in sorted order)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\t// Initial state should be rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**bold**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back to rendered\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestDetailPanelScroll(t *testing.T) {\n\t// Create an issue with a long body\n\tissues := []github.Issue{\n\t\t{\n\t\t\tNumber:       1,\n\t\t\tTitle:        \"Long issue\",\n\t\t\tBody:         \"Line 1\\nLine 2\\nLine 3\\nLine 4\\nLine 5\\nLine 6\\nLine 7\\nLine 8\\nLine 9\\nLine 10\\nLine 11\\nLine 12\\nLine 13\\nLine 14\\nLine 15\\nLine 16\\nLine 17\\nLine 18\\nLine 19\\nLine 20\",\n\t\t\tAuthor:       github.User{Login: \"testuser\"},\n\t\t\tCreatedAt:    \"2024-01-15T10:30:00Z\",\n\t\t\tUpdatedAt:    \"2024-01-20T14:45:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to trigger scrolling\n\n\t// Initial scroll should be at 0\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n\n\t// Press 'l' to scroll down in the detail panel\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.DetailScrollOffset(), 0)\n\n\t// Press 'h' to scroll up in the detail panel\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.DetailScrollOffset())\n}\n\nfunc TestEnterKeyOpensCommentsView(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Initial state: not in comments view\n\tassert.False(t, m.InCommentsView())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to go back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestDetailPanelNoLabelsOrAssignees(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Issue 43 is first (more recent UpdatedAt) and has no labels or assignees\n\tview := m.View()\n\n\t// Should still render without crashing, just not show label/assignee sections\n\tassert.Contains(t, view, \"#43\")\n\tassert.Contains(t, view, \"Another issue\")\n}\n\n// Helper to create test comments\nfunc createTestComments() []github.Comment {\n\treturn []github.Comment{\n\t\t{\n\t\t\tID:        \"comment1\",\n\t\t\tBody:      \"This is the **first** comment with `code`.\",\n\t\t\tAuthor:    github.User{Login: \"commenter1\"},\n\t\t\tCreatedAt: \"2024-01-10T10:00:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment2\",\n\t\t\tBody:      \"Second comment here.\",\n\t\t\tAuthor:    github.User{Login: \"commenter2\"},\n\t\t\tCreatedAt: \"2024-01-11T14:30:00Z\",\n\t\t},\n\t\t{\n\t\t\tID:        \"comment3\",\n\t\t\tBody:      \"Third comment with more details.\\n\\n- Point 1\\n- Point 2\",\n\t\t\tAuthor:    github.User{Login: \"commenter3\"},\n\t\t\tCreatedAt: \"2024-01-12T09:15:00Z\",\n\t\t},\n\t}\n}\n\nfunc TestSetComments(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\n\tcomments := createTestComments()\n\tm.SetComments(comments)\n\n\tassert.Equal(t, 3, len(m.GetComments()))\n}\n\nfunc TestCommentsViewShowsIssueHeader(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments view should replace main interface (no issue list panel)\n\t// and show issue title/number as header\n\tassert.True(t, m.InCommentsView())\n\tassert.Contains(t, view, \"#43\") // Issue number\n\tassert.Contains(t, view, \"Another issue\") // Issue title\n}\n\nfunc TestCommentsViewShowsCommentsChronologically(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should be displayed chronologically\n\t// Check that all comment authors are visible\n\tassert.Contains(t, view, \"commenter1\")\n\tassert.Contains(t, view, \"commenter2\")\n\tassert.Contains(t, view, \"commenter3\")\n}\n\nfunc TestCommentsViewShowsCommentDate(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show dates\n\tassert.Contains(t, view, \"2024-01-10\")\n\tassert.Contains(t, view, \"2024-01-11\")\n\tassert.Contains(t, view, \"2024-01-12\")\n}\n\nfunc TestCommentsViewShowsCommentBody(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Comments should show body content\n\tassert.Contains(t, view, \"first\")\n\tassert.Contains(t, view, \"Second comment\")\n}\n\nfunc TestCommentsViewToggleMarkdown(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 40)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Default is rendered markdown\n\tassert.False(t, m.IsRawMarkdown())\n\n\t// Press 'm' to toggle to raw markdown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRawMarkdown())\n\tview := m.View()\n\t// Raw view should contain markdown syntax\n\tassert.Contains(t, view, \"**first**\")\n\tassert.Contains(t, view, \"`code`\")\n\n\t// Press 'm' again to toggle back\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'m'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRawMarkdown())\n}\n\nfunc TestCommentsViewScrollable(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 15) // Small height to test scrolling\n\n\t// Create many comments to test scrolling\n\tmanyComments := []github.Comment{}\n\tfor i := 0; i < 20; i++ {\n\t\tmanyComments = append(manyComments, github.Comment{\n\t\t\tID:        fmt.Sprintf(\"comment%d\", i),\n\t\t\tBody:      fmt.Sprintf(\"Comment %d body text\", i),\n\t\t\tAuthor:    github.User{Login: fmt.Sprintf(\"user%d\", i)},\n\t\t\tCreatedAt: fmt.Sprintf(\"2024-01-%02dT10:00:00Z\", i+1),\n\t\t})\n\t}\n\tm.SetComments(manyComments)\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Initial scroll should be 0\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n\n\t// Press 'l' to scroll down\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'l'}})\n\tm = newModel.(Model)\n\n\tassert.Greater(t, m.CommentsScrollOffset(), 0)\n\n\t// Press 'h' to scroll back up\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'h'}})\n\tm = newModel.(Model)\n\n\tassert.Equal(t, 0, m.CommentsScrollOffset())\n}\n\nfunc TestCommentsViewEscapeReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press Escape to return to issue list\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewQKeyReturnsToIssueList(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'q' to return to issue list (not quit the app when in comments view)\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.InCommentsView())\n}\n\nfunc TestCommentsViewEmptyState(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\t// No comments set\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show a message when there are no comments\n\tassert.Contains(t, view, \"No comments\")\n}\n\nfunc TestCommentsViewReplacesMainInterface(t *testing.T) {\n\tissues := createDetailTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\tm.SetComments(createTestComments())\n\n\t// Before entering comments view, should see the issue list\n\tview := m.View()\n\tassert.Contains(t, view, \"#\") // Issue list column header\n\n\t// Press Enter to open comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tview = m.View()\n\n\t// Comments view should be a drill-down (full screen), not split panel\n\t// The issue list should not be visible\n\t// Check that the comments header is present\n\tassert.Contains(t, view, \"Comments\")\n}\n\n// Tests for Data Refresh functionality (US-009)\n\nfunc TestRefreshKeyRTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\trefreshCalled := false\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\trefreshCalled = true\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Initially not refreshing\n\tassert.False(t, m.IsRefreshing())\n\n\t// Press 'r' to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should set refreshing state\n\tassert.True(t, m.IsRefreshing())\n\t// Should return a command to start the refresh\n\tassert.NotNil(t, cmd)\n\t// Execute the command to verify it was called\n\tcmd()\n\tassert.True(t, refreshCalled)\n}\n\nfunc TestRefreshKeyRUpperCaseTriggersRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Press 'R' (uppercase) to trigger refresh\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'R'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\tassert.NotNil(t, cmd)\n}\n\nfunc TestRefreshKeyIgnoredWhileRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Try to trigger another refresh while already refreshing\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should still be refreshing, but no new command\n\tassert.True(t, m.IsRefreshing())\n\tassert.Nil(t, cmd) // No additional command should be returned\n}\n\nfunc TestRefreshKeyIgnoredInCommentsView(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Enter comments view\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.InCommentsView())\n\n\t// Press 'r' - should not trigger refresh while in comments view\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshProgressMsgUpdatesProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\t// Check progress is tracked\n\tcurrentProgress := m.GetRefreshProgress()\n\tassert.Equal(t, \"issues\", currentProgress.Phase)\n\tassert.Equal(t, 5, currentProgress.Current)\n\tassert.Equal(t, 10, currentProgress.Total)\n}\n\nfunc TestRefreshDoneMsgUpdatesIssues(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.IsRefreshing())\n\n\t// New issues from refresh\n\tnewIssues := []github.Issue{\n\t\t{\n\t\t\tNumber:       100,\n\t\t\tTitle:        \"New issue\",\n\t\t\tAuthor:       github.User{Login: \"newuser\"},\n\t\t\tCreatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tUpdatedAt:    \"2024-02-01T12:00:00Z\",\n\t\t\tCommentCount: 0,\n\t\t},\n\t}\n\n\t// Simulate refresh done message\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: newIssues})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Issues should be updated\n\tassert.Equal(t, 1, m.IssueCount())\n\tassert.Equal(t, 100, m.issues[0].Number)\n}\n\nfunc TestRefreshErrorMsgStopsRefreshing(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error message\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Should no longer be refreshing\n\tassert.False(t, m.IsRefreshing())\n\t// Error should be tracked\n\tassert.Equal(t, \"network error\", m.GetRefreshError())\n\t// Original issues should remain\n\tassert.Equal(t, 3, m.IssueCount())\n}\n\nfunc TestStatusBarShowsRefreshingIndicator(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show refreshing indicator\n\tassert.Contains(t, view, \"Refreshing\")\n}\n\nfunc TestStatusBarShowsRefreshProgress(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate progress message\n\tprogress := RefreshProgress{Phase: \"issues\", Current: 5, Total: 10}\n\tnewModel, _ = m.Update(RefreshProgressMsg{Progress: progress})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Status bar should show progress\n\tassert.Contains(t, view, \"5/10\")\n}\n\nfunc TestRefreshClearsErrorOnNewRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set a mock refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start and fail a refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\t// Start a new refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Error should be cleared\n\tassert.Empty(t, m.GetRefreshError())\n}\n\nfunc TestRefreshMaintainsCursorOnSameIssue(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Move cursor to issue #2 (second in sorted order after applying default sort)\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\n\tselectedBefore := m.SelectedIssue()\n\trequire.NotNil(t, selectedBefore)\n\tselectedNumber := selectedBefore.Number\n\n\t// Start refresh\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh with same issues\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues()})\n\tm = newModel.(Model)\n\n\t// Cursor should still be on the same issue\n\tselectedAfter := m.SelectedIssue()\n\trequire.NotNil(t, selectedAfter)\n\tassert.Equal(t, selectedNumber, selectedAfter.Number)\n}\n\n// Tests for Error Handling (US-013)\n\nfunc TestMinorErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a minor error (network timeout)\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate a network timeout error (minor)\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network timeout: connection timed out\")})\n\tm = newModel.(Model)\n\n\t// Error should be shown in status bar, not as modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.NotEmpty(t, m.GetRefreshError())\n\n\tview := m.View()\n\t// Status bar should show error\n\tassert.Contains(t, view, \"timeout\")\n}\n\nfunc TestMinorErrorSuggestsRetry(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error: dial tcp: no route to host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should show actionable guidance - suggest retry\n\tassert.Contains(t, view, \"r: retry\")\n}\n\nfunc TestRateLimitErrorShownInStatusBar(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a rate limit error (minor)\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"GitHub API error: 403 rate limit exceeded\")})\n\tm = newModel.(Model)\n\n\t// Should be shown in status bar, not modal\n\tassert.False(t, m.HasErrorModal())\n\tassert.Contains(t, m.GetRefreshError(), \"rate limit\")\n}\n\nfunc TestCriticalErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Simulate a critical error (invalid token)\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized)\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Authentication Error\"})\n\tm = newModel.(Model)\n\n\t// Should show modal\n\tassert.True(t, m.HasErrorModal())\n\tassert.Equal(t, \"Authentication Error\", m.GetErrorModalTitle())\n\tassert.Contains(t, m.GetErrorModalMessage(), \"invalid\")\n}\n\nfunc TestCriticalErrorModalRequiresAcknowledgment(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"database corruption: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Database Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Navigation keys should not work while modal is shown\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyDown})\n\tm = newModel.(Model)\n\tassert.True(t, m.HasErrorModal()) // Modal still shown\n\n\t// Press Enter to acknowledge\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEnter})\n\tm = newModel.(Model)\n\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestCriticalErrorModalDismissedWithEscape(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal\n\terr := fmt.Errorf(\"invalid token\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: err, Title: \"Auth Error\"})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\n\t// Press Escape to dismiss\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyEscape})\n\tm = newModel.(Model)\n\n\tassert.False(t, m.HasErrorModal())\n}\n\nfunc TestErrorModalViewRendering(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Show critical error modal with actionable guidance\n\terr := fmt.Errorf(\"invalid GitHub token: authentication failed (401 Unauthorized). Please check that your token is correct and has not expired\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Authentication Error\",\n\t\tGuidance: \"Run 'ghissues config' to update your authentication settings.\",\n\t})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Modal should be visible\n\tassert.Contains(t, view, \"Authentication Error\")\n\tassert.Contains(t, view, \"Unauthorized\")\n\t// Should show actionable guidance\n\tassert.Contains(t, view, \"ghissues config\")\n\t// Should show dismissal instructions\n\tassert.Contains(t, view, \"Enter\")\n}\n\nfunc TestDatabaseErrorShowsModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Database corruption is a critical error\n\terr := fmt.Errorf(\"database error: file is not a database\")\n\tnewModel, _ := m.Update(CriticalErrorMsg{\n\t\tErr:      err,\n\t\tTitle:    \"Database Error\",\n\t\tGuidance: \"Try deleting the database file and running 'ghissues sync' to rebuild it.\",\n\t})\n\tm = newModel.(Model)\n\n\tassert.True(t, m.HasErrorModal())\n\tview := m.View()\n\tassert.Contains(t, view, \"Database Error\")\n\tassert.Contains(t, view, \"database\")\n}\n\nfunc TestNavigationBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Remember initial cursor position\n\tinitialCursor := m.cursor\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try various navigation keys\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'j'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\tnewModel, _ = m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'k'}})\n\tm = newModel.(Model)\n\tassert.Equal(t, initialCursor, m.cursor) // Cursor unchanged\n\n\t// 'q' should dismiss modal, not quit\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'q'}})\n\tm = newModel.(Model)\n\t// Modal should be dismissed\n\tassert.False(t, m.HasErrorModal())\n\t// Should not return quit command\n\tassert.Nil(t, cmd)\n}\n\nfunc TestRefreshBlockedDuringErrorModal(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(120, 30)\n\n\t// Set refresh function\n\tm.SetRefreshFunc(func() tea.Msg {\n\t\treturn RefreshDoneMsg{Issues: issues}\n\t})\n\n\t// Show critical error modal\n\tnewModel, _ := m.Update(CriticalErrorMsg{Err: fmt.Errorf(\"error\"), Title: \"Error\"})\n\tm = newModel.(Model)\n\n\t// Try to trigger refresh while modal is shown\n\tnewModel, cmd := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Should not start refreshing\n\tassert.False(t, m.IsRefreshing())\n\tassert.Nil(t, cmd)\n}\n\nfunc TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(140, 30) // Wider to see full message\n\n\t// Network error\n\tnewModel, _ := m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"failed to execute request: dial tcp: no such host\")})\n\tm = newModel.(Model)\n\n\tview := m.View()\n\n\t// Should suggest checking connectivity (part of the standard error display)\n\t// The error message and retry option should be visible\n\tassert.Contains(t, view, \"dial tcp\")\n}\n\n// Tests for Last Synced Indicator (US-010)\n\nfunc TestSetLastSyncTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\tsyncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)\n\tm.SetLastSyncTime(syncTime)\n\n\tassert.Equal(t, syncTime, m.GetLastSyncTime())\n}\n\nfunc TestLastSyncTimeDefaultIsZero(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\n\t// Default should be zero time (never synced)\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n}\n\nfunc TestStatusBarShowsLastSyncedTime(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30) // Wide enough to show full status bar\n\n\t// Set last sync time to a few minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Status bar should show \"Last synced:\" indicator\n\tassert.Contains(t, view, \"Last synced:\")\n}\n\nfunc TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 5 minutes ago\n\tsyncTime := time.Now().Add(-5 * time.Minute)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"5 minutes ago\")\n\tassert.Contains(t, view, \"5m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 30 seconds ago\n\tsyncTime := time.Now().Add(-30 * time.Second)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show \"just now\" or \"<1m ago\"\n\tassert.Contains(t, view, \"<1m ago\")\n}\n\nfunc TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 2 hours ago\n\tsyncTime := time.Now().Add(-2 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"2h ago\")\n\tassert.Contains(t, view, \"2h ago\")\n}\n\nfunc TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set last sync time to 3 days ago\n\tsyncTime := time.Now().Add(-3 * 24 * time.Hour)\n\tm.SetLastSyncTime(syncTime)\n\n\tview := m.View()\n\n\t// Should show relative time (e.g., \"3d ago\")\n\tassert.Contains(t, view, \"3d ago\")\n}\n\nfunc TestLastSyncedNeverSynced(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Don't set last sync time (zero value = never synced)\n\tview := m.View()\n\n\t// Should show \"never\" or similar indicator\n\tassert.Contains(t, view, \"Last synced: never\")\n}\n\nfunc TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Initially never synced\n\tassert.True(t, m.GetLastSyncTime().IsZero())\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Complete refresh - this should include the new sync time\n\tnewSyncTime := time.Now()\n\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})\n\tm = newModel.(Model)\n\n\t// Last sync time should be updated\n\tassert.False(t, m.GetLastSyncTime().IsZero())\n\t// Should be approximately now (within a second)\n\tassert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)\n}\n\nfunc TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {\n\tissues := createTestIssues()\n\tm := NewModel(issues, nil)\n\tm.SetWindowSize(160, 30)\n\n\t// Set initial sync time\n\tinitialSyncTime := time.Now().Add(-10 * time.Minute)\n\tm.SetLastSyncTime(initialSyncTime)\n\n\t// Start refresh\n\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n\tm = newModel.(Model)\n\n\t// Simulate error\n\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n\tm = newModel.(Model)\n\n\t// Last sync time should remain unchanged\n\tassert.Equal(t, initialSyncTime, m.GetLastSyncTime())\n}\n\nfunc TestRelativeTimeFormat(t *testing.T) {\n\ttests := []struct {\n\t\tname     string\n\t\tduration time.Duration\n\t\texpected string\n\t}{\n\t\t{name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},\n\t\t{name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},\n\t\t{name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},\n\t\t{name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},\n\t\t{name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},\n\t\t{name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},\n\t\t{name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},\n\t\t{name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},\n\t\t{name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},\n\t\t{name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},\n\t}\n\n\tfor _, tt := range tests {\n\t\tt.Run(tt.name, func(t *testing.T) {\n\t\t\tresult := formatRelativeTime(time.Now().Add(-tt.duration))\n\t\t\tassert.Equal(t, tt.expected, result)\n\t\t})\n\t}\n}\n\nfunc TestRelativeTimeFormatNeverSynced(t *testing.T) {\n\t// Zero time should return \"never\"\n\tresult := formatRelativeTime(time.Time{})\n\tassert.Equal(t, \"never\", result)\n}\n","structuredPatch":[{"oldStart":3,"oldLines":6,"newStart":3,"newLines":7,"lines":[" import (","   \"fmt\"","   \"testing\"","+  \"time\""," ","   tea \"github.com/charmbracelet/bubbletea\"","   \"github.com/shepbook/ghissues/internal/config\""]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RBiYvbw6GrGgvXYcfrFU6M","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run the tests to see if they pass:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":402,"cache_read_input_tokens":84764,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"4729fc0d-8bca-4371-a5d9-b14397be0c8d"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01RBiYvbw6GrGgvXYcfrFU6M","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01LMWWKJPvWzk2dj5qiKPFsj","name":"Bash","input":{"command":"go test ./internal/tui/... -v -run \"TestSetLastSyncTime|TestLastSyncTime|TestStatusBarShowsLastSyncedTime|TestRelativeTime|TestLastSyncedRelative|TestLastSyncedNever\" 2>&1"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":402,"cache_read_input_tokens":84764,"cache_creation":{"ephemeral_5m_input_tokens":402,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"d00cc87d-095b-499c-8295-d1ab58930752"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01LMWWKJPvWzk2dj5qiKPFsj","type":"tool_result","content":"=== RUN   TestSetLastSyncTime\n--- PASS: TestSetLastSyncTime (0.00s)\n=== RUN   TestLastSyncTimeDefaultIsZero\n--- PASS: TestLastSyncTimeDefaultIsZero (0.00s)\n=== RUN   TestStatusBarShowsLastSyncedTime\n--- PASS: TestStatusBarShowsLastSyncedTime (0.00s)\n=== RUN   TestLastSyncedRelativeTimeMinutesAgo\n--- PASS: TestLastSyncedRelativeTimeMinutesAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeSecondsAgo\n--- PASS: TestLastSyncedRelativeTimeSecondsAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeHoursAgo\n--- PASS: TestLastSyncedRelativeTimeHoursAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeDaysAgo\n--- PASS: TestLastSyncedRelativeTimeDaysAgo (0.00s)\n=== RUN   TestLastSyncedNeverSynced\n--- PASS: TestLastSyncedNeverSynced (0.00s)\n=== RUN   TestLastSyncTimeUpdatedAfterRefresh\n--- PASS: TestLastSyncTimeUpdatedAfterRefresh (0.00s)\n=== RUN   TestLastSyncTimeNotChangedOnRefreshError\n--- PASS: TestLastSyncTimeNotChangedOnRefreshError (0.00s)\n=== RUN   TestRelativeTimeFormat\n=== RUN   TestRelativeTimeFormat/30_seconds\n=== RUN   TestRelativeTimeFormat/1_minute\n=== RUN   TestRelativeTimeFormat/5_minutes\n=== RUN   TestRelativeTimeFormat/59_minutes\n=== RUN   TestRelativeTimeFormat/1_hour\n=== RUN   TestRelativeTimeFormat/2_hours\n=== RUN   TestRelativeTimeFormat/23_hours\n=== RUN   TestRelativeTimeFormat/1_day\n=== RUN   TestRelativeTimeFormat/3_days\n=== RUN   TestRelativeTimeFormat/7_days\n--- PASS: TestRelativeTimeFormat (0.00s)\n    --- PASS: TestRelativeTimeFormat/30_seconds (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_minute (0.00s)\n    --- PASS: TestRelativeTimeFormat/5_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/59_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_hour (0.00s)\n    --- PASS: TestRelativeTimeFormat/2_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/23_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_day (0.00s)\n    --- PASS: TestRelativeTimeFormat/3_days (0.00s)\n    --- PASS: TestRelativeTimeFormat/7_days (0.00s)\n=== RUN   TestRelativeTimeFormatNeverSynced\n--- PASS: TestRelativeTimeFormatNeverSynced (0.00s)\nPASS\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.488s","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"c94fff90-b20a-44df-bedc-23a3a9870a80","tool_use_result":{"stdout":"=== RUN   TestSetLastSyncTime\n--- PASS: TestSetLastSyncTime (0.00s)\n=== RUN   TestLastSyncTimeDefaultIsZero\n--- PASS: TestLastSyncTimeDefaultIsZero (0.00s)\n=== RUN   TestStatusBarShowsLastSyncedTime\n--- PASS: TestStatusBarShowsLastSyncedTime (0.00s)\n=== RUN   TestLastSyncedRelativeTimeMinutesAgo\n--- PASS: TestLastSyncedRelativeTimeMinutesAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeSecondsAgo\n--- PASS: TestLastSyncedRelativeTimeSecondsAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeHoursAgo\n--- PASS: TestLastSyncedRelativeTimeHoursAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeDaysAgo\n--- PASS: TestLastSyncedRelativeTimeDaysAgo (0.00s)\n=== RUN   TestLastSyncedNeverSynced\n--- PASS: TestLastSyncedNeverSynced (0.00s)\n=== RUN   TestLastSyncTimeUpdatedAfterRefresh\n--- PASS: TestLastSyncTimeUpdatedAfterRefresh (0.00s)\n=== RUN   TestLastSyncTimeNotChangedOnRefreshError\n--- PASS: TestLastSyncTimeNotChangedOnRefreshError (0.00s)\n=== RUN   TestRelativeTimeFormat\n=== RUN   TestRelativeTimeFormat/30_seconds\n=== RUN   TestRelativeTimeFormat/1_minute\n=== RUN   TestRelativeTimeFormat/5_minutes\n=== RUN   TestRelativeTimeFormat/59_minutes\n=== RUN   TestRelativeTimeFormat/1_hour\n=== RUN   TestRelativeTimeFormat/2_hours\n=== RUN   TestRelativeTimeFormat/23_hours\n=== RUN   TestRelativeTimeFormat/1_day\n=== RUN   TestRelativeTimeFormat/3_days\n=== RUN   TestRelativeTimeFormat/7_days\n--- PASS: TestRelativeTimeFormat (0.00s)\n    --- PASS: TestRelativeTimeFormat/30_seconds (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_minute (0.00s)\n    --- PASS: TestRelativeTimeFormat/5_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/59_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_hour (0.00s)\n    --- PASS: TestRelativeTimeFormat/2_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/23_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_day (0.00s)\n    --- PASS: TestRelativeTimeFormat/3_days (0.00s)\n    --- PASS: TestRelativeTimeFormat/7_days (0.00s)\n=== RUN   TestRelativeTimeFormatNeverSynced\n--- PASS: TestRelativeTimeFormatNeverSynced (0.00s)\nPASS\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.488s","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ALKtTCHHk6UcVcMkkhBttB","type":"message","role":"assistant","content":[{"type":"text","text":"All new tests pass. Now I need to update the root command to:\n1. Load the last sync time from the database\n2. Pass it to the TUI model\n3. Update `createRefreshFunc` to include the last sync time in `RefreshDoneMsg`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1159,"cache_read_input_tokens":85166,"cache_creation":{"ephemeral_5m_input_tokens":1159,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"92f3bd55-b5ab-47cd-9db7-0d3ae147894f"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01ALKtTCHHk6UcVcMkkhBttB","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01RGeu7UE92opNzNXMnAZfUK","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"in_progress","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1159,"cache_read_input_tokens":85166,"cache_creation":{"ephemeral_5m_input_tokens":1159,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"e9d19a51-2b0f-4b36-8c8d-0fb8c5007989"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01RGeu7UE92opNzNXMnAZfUK","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"fe37dd59-d177-474e-b895-9a2eef421a0d","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"in_progress","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Run tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"in_progress","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017achJXAt4wgahYJBsYXDTh","type":"message","role":"assistant","content":[{"type":"text","text":"Let me update the root.go to:\n1. Load last sync time from database on startup\n2. Pass it to the model\n3. Update `createRefreshFunc` to include the sync time in the `RefreshDoneMsg`"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":430,"cache_read_input_tokens":86325,"cache_creation":{"ephemeral_5m_input_tokens":430,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"a06b5f5c-66ca-4c78-81c3-314a90d37ce7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017achJXAt4wgahYJBsYXDTh","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01EMkYFnZQ8NSPJc19X9rH1r","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","old_string":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)","new_string":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":430,"cache_read_input_tokens":86325,"cache_creation":{"ephemeral_5m_input_tokens":430,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"67890fdb-aca0-44f7-83a3-fefaacb729e5"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01EMkYFnZQ8NSPJc19X9rH1r","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/cmd/root.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"f7d7b59b-b319-4f68-8f9e-6a8941f5d761","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","oldString":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)","newString":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)","originalFile":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar configPath string\nvar dbPath string\nvar disableTUI bool // For testing - skips TUI startup\n\n// SetDisableTUI sets whether to skip TUI startup (for testing)\nfunc SetDisableTUI(disable bool) {\n\tdisableTUI = disable\n}\n\n// SetConfigPath sets a custom config path (mainly for testing)\nfunc SetConfigPath(path string) {\n\tconfigPath = path\n}\n\n// GetConfigPath returns the current config path, defaulting to the standard location\nfunc GetConfigPath() string {\n\tif configPath == \"\" {\n\t\treturn config.DefaultConfigPath()\n\t}\n\treturn configPath\n}\n\n// SetDBPath sets a custom database path (mainly for testing)\nfunc SetDBPath(path string) {\n\tdbPath = path\n}\n\n// GetDBPath returns the current database path (empty string means use default)\nfunc GetDBPath() string {\n\treturn dbPath\n}\n\n// ShouldRunSetup returns true if the interactive setup should be run\n// (i.e., when config file doesn't exist)\nfunc ShouldRunSetup(path string) bool {\n\treturn !config.Exists(path)\n}\n\n// NewRootCmd creates the root command for ghissues\nfunc NewRootCmd() *cobra.Command {\n\tvar dbFlagPath string\n\n\trootCmd := &cobra.Command{\n\t\tUse:   \"ghissues\",\n\t\tShort: \"GitHub Issues TUI - Browse and review GitHub issues offline\",\n\t\tLong: `ghissues is a terminal user interface for browsing GitHub issues.\nIt syncs issues from a GitHub repository to a local database for offline access.\n\nOn first run, you'll be prompted to configure your repository and authentication.\nYou can also run 'ghissues config' to reconfigure at any time.`,\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// Set the dbPath global if flag was provided\n\t\t\tif dbFlagPath != \"\" {\n\t\t\t\tSetDBPath(dbFlagPath)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// Check if first-time setup is needed\n\t\t\tif ShouldRunSetup(path) {\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Welcome to ghissues! Let's set up your configuration.\")\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Configuration saved! You can reconfigure anytime with 'ghissues config'\")\n\t\t\t}\n\n\t\t\t// Load config and start TUI (placeholder for now)\n\t\t\tcfg, err := config.Load(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n\t\t\t}\n\n\t\t\t// Resolve and validate database path\n\t\t\tresolvedDBPath, err := db.ResolveDBPath(GetDBPath(), cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to resolve database path: %w\", err)\n\t\t\t}\n\n\t\t\tif err := db.EnsureDBPath(resolvedDBPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Open database and load issues\n\t\t\tstore, err := db.NewStore(resolvedDBPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to open database: %w\", err)\n\t\t\t}\n\t\t\tdefer store.Close()\n\n\t\t\tissues, err := store.GetAllIssues(context.Background())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load issues: %w\", err)\n\t\t\t}\n\n\t\t\t// Get display columns (from config or defaults)\n\t\t\tcolumns := cfg.Display.Columns\n\t\t\tif len(columns) == 0 {\n\t\t\t\tcolumns = config.DefaultDisplayColumns()\n\t\t\t}\n\n\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\n\t\t\t// Set up refresh function for manual refresh (r key)\n\t\t\t// This creates a closure that captures the necessary context\n\t\t\tmodel.SetRefreshFunc(createRefreshFunc(cfg, store, owner, repo))\n\n\t\t\tp := tea.NewProgram(model, tea.WithAltScreen())\n\n\t\t\t// Trigger auto-refresh on launch by sending RefreshStartMsg\n\t\t\tgo func() {\n\t\t\t\tp.Send(tui.RefreshStartMsg{})\n\t\t\t}()\n\n\t\t\tfinalModel, err := p.Run()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"TUI error: %w\", err)\n\t\t\t}\n\n\t\t\t// Save sort preferences if they changed\n\t\t\tif m, ok := finalModel.(tui.Model); ok && m.SortChanged() {\n\t\t\t\tnewSortField, newSortOrder := m.GetSortConfig()\n\t\t\t\tcfg.Display.SortField = newSortField\n\t\t\t\tcfg.Display.SortOrder = newSortOrder\n\t\t\t\tif err := config.Save(cfg, path); err != nil {\n\t\t\t\t\t// Don't fail, just warn - the main operation succeeded\n\t\t\t\t\tfmt.Fprintf(cmd.ErrOrStderr(), \"Warning: failed to save sort preferences: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t// Add persistent flags (available to all subcommands)\n\trootCmd.PersistentFlags().StringVar(&dbFlagPath, \"db\", \"\", \"Path to local database file (default: .ghissues.db)\")\n\n\t// Add subcommands\n\trootCmd.AddCommand(newConfigCmd())\n\trootCmd.AddCommand(newSyncCmd())\n\n\treturn rootCmd\n}\n\n// newConfigCmd creates the config subcommand\nfunc newConfigCmd() *cobra.Command {\n\tvar repo string\n\tvar authMethod string\n\tvar token string\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"config\",\n\t\tShort: \"Configure ghissues settings (run interactive configuration)\",\n\t\tLong: `Configure ghissues settings including repository and authentication method.\n\nWhen run without flags, starts an interactive setup wizard.\nYou can also provide flags to configure non-interactively.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// If flags provided, use non-interactive mode\n\t\t\tif repo != \"\" && authMethod != \"\" {\n\t\t\t\t_, err := setup.RunSetupWithValues(repo, authMethod, token, path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Configuration saved successfully!\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise, run interactive setup\n\t\t\tfmt.Println(\"Let's configure ghissues!\")\n\t\t\tfmt.Println()\n\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t}\n\t\t\tfmt.Println()\n\t\t\tfmt.Println(\"Configuration saved!\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd.Flags().StringVar(&repo, \"repo\", \"\", \"GitHub repository in owner/repo format\")\n\tcmd.Flags().StringVar(&authMethod, \"auth-method\", \"\", \"Authentication method: env, token, or gh\")\n\tcmd.Flags().StringVar(&token, \"token\", \"\", \"GitHub personal access token (required when auth-method is 'token')\")\n\n\treturn cmd\n}\n\n// Execute runs the root command\nfunc Execute() error {\n\treturn NewRootCmd().Execute()\n}\n\n// parseRepo parses a repository string in the format \"owner/repo\"\nfunc parseRepo(repoStr string) (owner, repo string, err error) {\n\tparts := strings.Split(repoStr, \"/\")\n\tif len(parts) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid repository format: %s (expected owner/repo)\", repoStr)\n\t}\n\treturn parts[0], parts[1], nil\n}\n\n// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}\n","structuredPatch":[{"oldStart":4,"oldLines":6,"newStart":4,"newLines":7,"lines":["   \"context\"","   \"fmt\"","   \"strings\"","+  \"time\""," ","   tea \"github.com/charmbracelet/bubbletea\"","   \"github.com/shepbook/ghissues/internal/auth\""]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019ZFANjayTtcK6aZAg5arPq","type":"message","role":"assistant","content":[{"type":"text","text":"Now I need to update the root command to load last sync time and pass it to the model:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":585,"cache_read_input_tokens":86755,"cache_creation":{"ephemeral_5m_input_tokens":585,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"c45caa66-fd04-44a6-a27e-d6dae3bfd89a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_019ZFANjayTtcK6aZAg5arPq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Q1g89dAHatERAe6X7BXooS","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","old_string":"\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)","new_string":"\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Load last sync time from database\n\t\t\tlastSyncTime, err := store.GetLastSyncTime(context.Background())\n\t\t\tif err != nil {\n\t\t\t\t// Non-fatal error - just log and continue with zero time\n\t\t\t\tlastSyncTime = time.Time{}\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\t\t\tmodel.SetLastSyncTime(lastSyncTime)"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":585,"cache_read_input_tokens":86755,"cache_creation":{"ephemeral_5m_input_tokens":585,"ephemeral_1h_input_tokens":0},"output_tokens":8,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"1f4698ce-3dc8-45f1-ae8b-f4c72e91b5c1"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Q1g89dAHatERAe6X7BXooS","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/cmd/root.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2b2d248a-3161-4a11-ab14-54ba439af50c","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","oldString":"\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)","newString":"\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Load last sync time from database\n\t\t\tlastSyncTime, err := store.GetLastSyncTime(context.Background())\n\t\t\tif err != nil {\n\t\t\t\t// Non-fatal error - just log and continue with zero time\n\t\t\t\tlastSyncTime = time.Time{}\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\t\t\tmodel.SetLastSyncTime(lastSyncTime)","originalFile":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar configPath string\nvar dbPath string\nvar disableTUI bool // For testing - skips TUI startup\n\n// SetDisableTUI sets whether to skip TUI startup (for testing)\nfunc SetDisableTUI(disable bool) {\n\tdisableTUI = disable\n}\n\n// SetConfigPath sets a custom config path (mainly for testing)\nfunc SetConfigPath(path string) {\n\tconfigPath = path\n}\n\n// GetConfigPath returns the current config path, defaulting to the standard location\nfunc GetConfigPath() string {\n\tif configPath == \"\" {\n\t\treturn config.DefaultConfigPath()\n\t}\n\treturn configPath\n}\n\n// SetDBPath sets a custom database path (mainly for testing)\nfunc SetDBPath(path string) {\n\tdbPath = path\n}\n\n// GetDBPath returns the current database path (empty string means use default)\nfunc GetDBPath() string {\n\treturn dbPath\n}\n\n// ShouldRunSetup returns true if the interactive setup should be run\n// (i.e., when config file doesn't exist)\nfunc ShouldRunSetup(path string) bool {\n\treturn !config.Exists(path)\n}\n\n// NewRootCmd creates the root command for ghissues\nfunc NewRootCmd() *cobra.Command {\n\tvar dbFlagPath string\n\n\trootCmd := &cobra.Command{\n\t\tUse:   \"ghissues\",\n\t\tShort: \"GitHub Issues TUI - Browse and review GitHub issues offline\",\n\t\tLong: `ghissues is a terminal user interface for browsing GitHub issues.\nIt syncs issues from a GitHub repository to a local database for offline access.\n\nOn first run, you'll be prompted to configure your repository and authentication.\nYou can also run 'ghissues config' to reconfigure at any time.`,\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// Set the dbPath global if flag was provided\n\t\t\tif dbFlagPath != \"\" {\n\t\t\t\tSetDBPath(dbFlagPath)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// Check if first-time setup is needed\n\t\t\tif ShouldRunSetup(path) {\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Welcome to ghissues! Let's set up your configuration.\")\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Configuration saved! You can reconfigure anytime with 'ghissues config'\")\n\t\t\t}\n\n\t\t\t// Load config and start TUI (placeholder for now)\n\t\t\tcfg, err := config.Load(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n\t\t\t}\n\n\t\t\t// Resolve and validate database path\n\t\t\tresolvedDBPath, err := db.ResolveDBPath(GetDBPath(), cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to resolve database path: %w\", err)\n\t\t\t}\n\n\t\t\tif err := db.EnsureDBPath(resolvedDBPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Open database and load issues\n\t\t\tstore, err := db.NewStore(resolvedDBPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to open database: %w\", err)\n\t\t\t}\n\t\t\tdefer store.Close()\n\n\t\t\tissues, err := store.GetAllIssues(context.Background())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load issues: %w\", err)\n\t\t\t}\n\n\t\t\t// Get display columns (from config or defaults)\n\t\t\tcolumns := cfg.Display.Columns\n\t\t\tif len(columns) == 0 {\n\t\t\t\tcolumns = config.DefaultDisplayColumns()\n\t\t\t}\n\n\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\n\t\t\t// Set up refresh function for manual refresh (r key)\n\t\t\t// This creates a closure that captures the necessary context\n\t\t\tmodel.SetRefreshFunc(createRefreshFunc(cfg, store, owner, repo))\n\n\t\t\tp := tea.NewProgram(model, tea.WithAltScreen())\n\n\t\t\t// Trigger auto-refresh on launch by sending RefreshStartMsg\n\t\t\tgo func() {\n\t\t\t\tp.Send(tui.RefreshStartMsg{})\n\t\t\t}()\n\n\t\t\tfinalModel, err := p.Run()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"TUI error: %w\", err)\n\t\t\t}\n\n\t\t\t// Save sort preferences if they changed\n\t\t\tif m, ok := finalModel.(tui.Model); ok && m.SortChanged() {\n\t\t\t\tnewSortField, newSortOrder := m.GetSortConfig()\n\t\t\t\tcfg.Display.SortField = newSortField\n\t\t\t\tcfg.Display.SortOrder = newSortOrder\n\t\t\t\tif err := config.Save(cfg, path); err != nil {\n\t\t\t\t\t// Don't fail, just warn - the main operation succeeded\n\t\t\t\t\tfmt.Fprintf(cmd.ErrOrStderr(), \"Warning: failed to save sort preferences: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t// Add persistent flags (available to all subcommands)\n\trootCmd.PersistentFlags().StringVar(&dbFlagPath, \"db\", \"\", \"Path to local database file (default: .ghissues.db)\")\n\n\t// Add subcommands\n\trootCmd.AddCommand(newConfigCmd())\n\trootCmd.AddCommand(newSyncCmd())\n\n\treturn rootCmd\n}\n\n// newConfigCmd creates the config subcommand\nfunc newConfigCmd() *cobra.Command {\n\tvar repo string\n\tvar authMethod string\n\tvar token string\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"config\",\n\t\tShort: \"Configure ghissues settings (run interactive configuration)\",\n\t\tLong: `Configure ghissues settings including repository and authentication method.\n\nWhen run without flags, starts an interactive setup wizard.\nYou can also provide flags to configure non-interactively.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// If flags provided, use non-interactive mode\n\t\t\tif repo != \"\" && authMethod != \"\" {\n\t\t\t\t_, err := setup.RunSetupWithValues(repo, authMethod, token, path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Configuration saved successfully!\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise, run interactive setup\n\t\t\tfmt.Println(\"Let's configure ghissues!\")\n\t\t\tfmt.Println()\n\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t}\n\t\t\tfmt.Println()\n\t\t\tfmt.Println(\"Configuration saved!\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd.Flags().StringVar(&repo, \"repo\", \"\", \"GitHub repository in owner/repo format\")\n\tcmd.Flags().StringVar(&authMethod, \"auth-method\", \"\", \"Authentication method: env, token, or gh\")\n\tcmd.Flags().StringVar(&token, \"token\", \"\", \"GitHub personal access token (required when auth-method is 'token')\")\n\n\treturn cmd\n}\n\n// Execute runs the root command\nfunc Execute() error {\n\treturn NewRootCmd().Execute()\n}\n\n// parseRepo parses a repository string in the format \"owner/repo\"\nfunc parseRepo(repoStr string) (owner, repo string, err error) {\n\tparts := strings.Split(repoStr, \"/\")\n\tif len(parts) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid repository format: %s (expected owner/repo)\", repoStr)\n\t}\n\treturn parts[0], parts[1], nil\n}\n\n// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}\n","structuredPatch":[{"oldStart":133,"oldLines":6,"newStart":133,"newLines":13,"lines":["         _, sortOrder = config.DefaultSortConfig()","       }"," ","+      // Load last sync time from database","+      lastSyncTime, err := store.GetLastSyncTime(context.Background())","+      if err != nil {","+        // Non-fatal error - just log and continue with zero time","+        lastSyncTime = time.Time{}","+      }","+","       // Skip TUI if disabled (for testing)","       if disableTUI {","         fmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))"]},{"oldStart":147,"oldLines":6,"newStart":154,"newLines":7,"lines":[" ","       // Create and run TUI","       model := tui.NewModelWithSort(issues, columns, sortField, sortOrder)","+      model.SetLastSyncTime(lastSyncTime)"," ","       // Set up refresh function for manual refresh (r key)","       // This creates a closure that captures the necessary context"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BK5qHmrEoqQYCEtgjvgLYd","type":"message","role":"assistant","content":[{"type":"text","text":"Good, now let me update the `createRefreshFunc` to include the last sync time when returning `RefreshDoneMsg`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":794,"cache_read_input_tokens":87340,"cache_creation":{"ephemeral_5m_input_tokens":794,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"afe63570-e202-42c3-af6c-bd0d6bbba82e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01BK5qHmrEoqQYCEtgjvgLYd","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01KhbDextDzqpUm7ZU9gtYW1","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","old_string":"// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}","new_string":"// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\t// Get the updated last sync time from the database\n\t\tlastSyncTime, err := store.GetLastSyncTime(ctx)\n\t\tif err != nil {\n\t\t\t// Non-fatal - use current time as fallback\n\t\t\tlastSyncTime = time.Now()\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues, LastSyncTime: lastSyncTime}\n\t}\n}"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":794,"cache_read_input_tokens":87340,"cache_creation":{"ephemeral_5m_input_tokens":794,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"81d0c8c7-2848-4cda-abce-b9a53b7bb7e7"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01KhbDextDzqpUm7ZU9gtYW1","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/internal/cmd/root.go has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"7e1e387c-4494-4728-a900-922a08cb9c73","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/internal/cmd/root.go","oldString":"// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}","newString":"// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\t// Get the updated last sync time from the database\n\t\tlastSyncTime, err := store.GetLastSyncTime(ctx)\n\t\tif err != nil {\n\t\t\t// Non-fatal - use current time as fallback\n\t\t\tlastSyncTime = time.Now()\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues, LastSyncTime: lastSyncTime}\n\t}\n}","originalFile":"package cmd\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"strings\"\n\t\"time\"\n\n\ttea \"github.com/charmbracelet/bubbletea\"\n\t\"github.com/shepbook/ghissues/internal/auth\"\n\t\"github.com/shepbook/ghissues/internal/config\"\n\t\"github.com/shepbook/ghissues/internal/db\"\n\t\"github.com/shepbook/ghissues/internal/github\"\n\t\"github.com/shepbook/ghissues/internal/setup\"\n\t\"github.com/shepbook/ghissues/internal/sync\"\n\t\"github.com/shepbook/ghissues/internal/tui\"\n\t\"github.com/spf13/cobra\"\n)\n\nvar configPath string\nvar dbPath string\nvar disableTUI bool // For testing - skips TUI startup\n\n// SetDisableTUI sets whether to skip TUI startup (for testing)\nfunc SetDisableTUI(disable bool) {\n\tdisableTUI = disable\n}\n\n// SetConfigPath sets a custom config path (mainly for testing)\nfunc SetConfigPath(path string) {\n\tconfigPath = path\n}\n\n// GetConfigPath returns the current config path, defaulting to the standard location\nfunc GetConfigPath() string {\n\tif configPath == \"\" {\n\t\treturn config.DefaultConfigPath()\n\t}\n\treturn configPath\n}\n\n// SetDBPath sets a custom database path (mainly for testing)\nfunc SetDBPath(path string) {\n\tdbPath = path\n}\n\n// GetDBPath returns the current database path (empty string means use default)\nfunc GetDBPath() string {\n\treturn dbPath\n}\n\n// ShouldRunSetup returns true if the interactive setup should be run\n// (i.e., when config file doesn't exist)\nfunc ShouldRunSetup(path string) bool {\n\treturn !config.Exists(path)\n}\n\n// NewRootCmd creates the root command for ghissues\nfunc NewRootCmd() *cobra.Command {\n\tvar dbFlagPath string\n\n\trootCmd := &cobra.Command{\n\t\tUse:   \"ghissues\",\n\t\tShort: \"GitHub Issues TUI - Browse and review GitHub issues offline\",\n\t\tLong: `ghissues is a terminal user interface for browsing GitHub issues.\nIt syncs issues from a GitHub repository to a local database for offline access.\n\nOn first run, you'll be prompted to configure your repository and authentication.\nYou can also run 'ghissues config' to reconfigure at any time.`,\n\t\tPersistentPreRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\t// Set the dbPath global if flag was provided\n\t\t\tif dbFlagPath != \"\" {\n\t\t\t\tSetDBPath(dbFlagPath)\n\t\t\t}\n\t\t\treturn nil\n\t\t},\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// Check if first-time setup is needed\n\t\t\tif ShouldRunSetup(path) {\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Welcome to ghissues! Let's set up your configuration.\")\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t\t}\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout())\n\t\t\t\tfmt.Fprintln(cmd.OutOrStdout(), \"Configuration saved! You can reconfigure anytime with 'ghissues config'\")\n\t\t\t}\n\n\t\t\t// Load config and start TUI (placeholder for now)\n\t\t\tcfg, err := config.Load(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load config: %w\", err)\n\t\t\t}\n\n\t\t\t// Resolve and validate database path\n\t\t\tresolvedDBPath, err := db.ResolveDBPath(GetDBPath(), cfg)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to resolve database path: %w\", err)\n\t\t\t}\n\n\t\t\tif err := db.EnsureDBPath(resolvedDBPath); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\t// Open database and load issues\n\t\t\tstore, err := db.NewStore(resolvedDBPath)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to open database: %w\", err)\n\t\t\t}\n\t\t\tdefer store.Close()\n\n\t\t\tissues, err := store.GetAllIssues(context.Background())\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"failed to load issues: %w\", err)\n\t\t\t}\n\n\t\t\t// Get display columns (from config or defaults)\n\t\t\tcolumns := cfg.Display.Columns\n\t\t\tif len(columns) == 0 {\n\t\t\t\tcolumns = config.DefaultDisplayColumns()\n\t\t\t}\n\n\t\t\t// Get sort settings (from config or defaults)\n\t\t\tsortField := cfg.Display.SortField\n\t\t\tsortOrder := cfg.Display.SortOrder\n\t\t\tif sortField == \"\" {\n\t\t\t\tsortField, _ = config.DefaultSortConfig()\n\t\t\t}\n\t\t\tif sortOrder == \"\" {\n\t\t\t\t_, sortOrder = config.DefaultSortConfig()\n\t\t\t}\n\n\t\t\t// Load last sync time from database\n\t\t\tlastSyncTime, err := store.GetLastSyncTime(context.Background())\n\t\t\tif err != nil {\n\t\t\t\t// Non-fatal error - just log and continue with zero time\n\t\t\t\tlastSyncTime = time.Time{}\n\t\t\t}\n\n\t\t\t// Skip TUI if disabled (for testing)\n\t\t\tif disableTUI {\n\t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Parse repository for sync\n\t\t\towner, repo, err := parseRepo(cfg.Repository)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"invalid repository format: %w\", err)\n\t\t\t}\n\n\t\t\t// Create and run TUI\n\t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n\t\t\tmodel.SetLastSyncTime(lastSyncTime)\n\n\t\t\t// Set up refresh function for manual refresh (r key)\n\t\t\t// This creates a closure that captures the necessary context\n\t\t\tmodel.SetRefreshFunc(createRefreshFunc(cfg, store, owner, repo))\n\n\t\t\tp := tea.NewProgram(model, tea.WithAltScreen())\n\n\t\t\t// Trigger auto-refresh on launch by sending RefreshStartMsg\n\t\t\tgo func() {\n\t\t\t\tp.Send(tui.RefreshStartMsg{})\n\t\t\t}()\n\n\t\t\tfinalModel, err := p.Run()\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"TUI error: %w\", err)\n\t\t\t}\n\n\t\t\t// Save sort preferences if they changed\n\t\t\tif m, ok := finalModel.(tui.Model); ok && m.SortChanged() {\n\t\t\t\tnewSortField, newSortOrder := m.GetSortConfig()\n\t\t\t\tcfg.Display.SortField = newSortField\n\t\t\t\tcfg.Display.SortOrder = newSortOrder\n\t\t\t\tif err := config.Save(cfg, path); err != nil {\n\t\t\t\t\t// Don't fail, just warn - the main operation succeeded\n\t\t\t\t\tfmt.Fprintf(cmd.ErrOrStderr(), \"Warning: failed to save sort preferences: %v\\n\", err)\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn nil\n\t\t},\n\t}\n\n\t// Add persistent flags (available to all subcommands)\n\trootCmd.PersistentFlags().StringVar(&dbFlagPath, \"db\", \"\", \"Path to local database file (default: .ghissues.db)\")\n\n\t// Add subcommands\n\trootCmd.AddCommand(newConfigCmd())\n\trootCmd.AddCommand(newSyncCmd())\n\n\treturn rootCmd\n}\n\n// newConfigCmd creates the config subcommand\nfunc newConfigCmd() *cobra.Command {\n\tvar repo string\n\tvar authMethod string\n\tvar token string\n\n\tcmd := &cobra.Command{\n\t\tUse:   \"config\",\n\t\tShort: \"Configure ghissues settings (run interactive configuration)\",\n\t\tLong: `Configure ghissues settings including repository and authentication method.\n\nWhen run without flags, starts an interactive setup wizard.\nYou can also provide flags to configure non-interactively.`,\n\t\tRunE: func(cmd *cobra.Command, args []string) error {\n\t\t\tpath := GetConfigPath()\n\n\t\t\t// If flags provided, use non-interactive mode\n\t\t\tif repo != \"\" && authMethod != \"\" {\n\t\t\t\t_, err := setup.RunSetupWithValues(repo, authMethod, token, path)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tfmt.Println(\"Configuration saved successfully!\")\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t// Otherwise, run interactive setup\n\t\t\tfmt.Println(\"Let's configure ghissues!\")\n\t\t\tfmt.Println()\n\t\t\t_, err := setup.RunInteractiveSetup(path)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"setup failed: %w\", err)\n\t\t\t}\n\t\t\tfmt.Println()\n\t\t\tfmt.Println(\"Configuration saved!\")\n\t\t\treturn nil\n\t\t},\n\t}\n\n\tcmd.Flags().StringVar(&repo, \"repo\", \"\", \"GitHub repository in owner/repo format\")\n\tcmd.Flags().StringVar(&authMethod, \"auth-method\", \"\", \"Authentication method: env, token, or gh\")\n\tcmd.Flags().StringVar(&token, \"token\", \"\", \"GitHub personal access token (required when auth-method is 'token')\")\n\n\treturn cmd\n}\n\n// Execute runs the root command\nfunc Execute() error {\n\treturn NewRootCmd().Execute()\n}\n\n// parseRepo parses a repository string in the format \"owner/repo\"\nfunc parseRepo(repoStr string) (owner, repo string, err error) {\n\tparts := strings.Split(repoStr, \"/\")\n\tif len(parts) != 2 {\n\t\treturn \"\", \"\", fmt.Errorf(\"invalid repository format: %s (expected owner/repo)\", repoStr)\n\t}\n\treturn parts[0], parts[1], nil\n}\n\n// createRefreshFunc creates a function that performs a sync operation\n// This function is called as a tea.Cmd and returns a tea.Msg\nfunc createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string) func() tea.Msg {\n\treturn func() tea.Msg {\n\t\tctx := context.Background()\n\n\t\t// Get authentication token\n\t\ttoken, _, err := auth.GetToken(cfg)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"authentication failed: %w\", err)}\n\t\t}\n\n\t\t// Create client and syncer\n\t\tclient := github.NewClient(token)\n\t\tsyncer := sync.NewSyncer(client, store)\n\n\t\t// Run sync synchronously (progress callback not used in TUI for simplicity)\n\t\t_, err = syncer.Sync(ctx, owner, repo, nil)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"sync failed: %w\", err)}\n\t\t}\n\n\t\t// Re-fetch issues from database after sync\n\t\tissues, err := store.GetAllIssues(ctx)\n\t\tif err != nil {\n\t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n\t\t}\n\n\t\treturn tui.RefreshDoneMsg{Issues: issues}\n\t}\n}\n","structuredPatch":[{"oldStart":285,"oldLines":6,"newStart":285,"newLines":13,"lines":["       return tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}","     }"," ","-    return tui.RefreshDoneMsg{Issues: issues}","+    // Get the updated last sync time from the database","+    lastSyncTime, err := store.GetLastSyncTime(ctx)","+    if err != nil {","+      // Non-fatal - use current time as fallback","+      lastSyncTime = time.Now()","+    }","+","+    return tui.RefreshDoneMsg{Issues: issues, LastSyncTime: lastSyncTime}","   }"," }"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LyrrLtZWLM3KzDBKKxG5xT","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me run all the TUI tests to make sure nothing is broken:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":951,"cache_read_input_tokens":88134,"cache_creation":{"ephemeral_5m_input_tokens":951,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"775393a9-6ed6-4266-80a5-a2e3bf18ad3b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LyrrLtZWLM3KzDBKKxG5xT","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QypWJ9haBYP8WWf5Y9ncdw","name":"Bash","input":{"command":"go test ./internal/tui/... -v 2>&1 | tail -60"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":951,"cache_read_input_tokens":88134,"cache_creation":{"ephemeral_5m_input_tokens":951,"ephemeral_1h_input_tokens":0},"output_tokens":5,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"39f65ed3-8ece-484a-a4db-5fa1f88f1660"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QypWJ9haBYP8WWf5Y9ncdw","type":"tool_result","content":"=== RUN   TestCriticalErrorModalRequiresAcknowledgment\n--- PASS: TestCriticalErrorModalRequiresAcknowledgment (0.00s)\n=== RUN   TestCriticalErrorModalDismissedWithEscape\n--- PASS: TestCriticalErrorModalDismissedWithEscape (0.00s)\n=== RUN   TestErrorModalViewRendering\n--- PASS: TestErrorModalViewRendering (0.00s)\n=== RUN   TestDatabaseErrorShowsModal\n--- PASS: TestDatabaseErrorShowsModal (0.00s)\n=== RUN   TestNavigationBlockedDuringErrorModal\n--- PASS: TestNavigationBlockedDuringErrorModal (0.00s)\n=== RUN   TestRefreshBlockedDuringErrorModal\n--- PASS: TestRefreshBlockedDuringErrorModal (0.00s)\n=== RUN   TestNetworkErrorIncludesConnectivityGuidance\n--- PASS: TestNetworkErrorIncludesConnectivityGuidance (0.00s)\n=== RUN   TestSetLastSyncTime\n--- PASS: TestSetLastSyncTime (0.00s)\n=== RUN   TestLastSyncTimeDefaultIsZero\n--- PASS: TestLastSyncTimeDefaultIsZero (0.00s)\n=== RUN   TestStatusBarShowsLastSyncedTime\n--- PASS: TestStatusBarShowsLastSyncedTime (0.00s)\n=== RUN   TestLastSyncedRelativeTimeMinutesAgo\n--- PASS: TestLastSyncedRelativeTimeMinutesAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeSecondsAgo\n--- PASS: TestLastSyncedRelativeTimeSecondsAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeHoursAgo\n--- PASS: TestLastSyncedRelativeTimeHoursAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeDaysAgo\n--- PASS: TestLastSyncedRelativeTimeDaysAgo (0.00s)\n=== RUN   TestLastSyncedNeverSynced\n--- PASS: TestLastSyncedNeverSynced (0.00s)\n=== RUN   TestLastSyncTimeUpdatedAfterRefresh\n--- PASS: TestLastSyncTimeUpdatedAfterRefresh (0.00s)\n=== RUN   TestLastSyncTimeNotChangedOnRefreshError\n--- PASS: TestLastSyncTimeNotChangedOnRefreshError (0.00s)\n=== RUN   TestRelativeTimeFormat\n=== RUN   TestRelativeTimeFormat/30_seconds\n=== RUN   TestRelativeTimeFormat/1_minute\n=== RUN   TestRelativeTimeFormat/5_minutes\n=== RUN   TestRelativeTimeFormat/59_minutes\n=== RUN   TestRelativeTimeFormat/1_hour\n=== RUN   TestRelativeTimeFormat/2_hours\n=== RUN   TestRelativeTimeFormat/23_hours\n=== RUN   TestRelativeTimeFormat/1_day\n=== RUN   TestRelativeTimeFormat/3_days\n=== RUN   TestRelativeTimeFormat/7_days\n--- PASS: TestRelativeTimeFormat (0.00s)\n    --- PASS: TestRelativeTimeFormat/30_seconds (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_minute (0.00s)\n    --- PASS: TestRelativeTimeFormat/5_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/59_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_hour (0.00s)\n    --- PASS: TestRelativeTimeFormat/2_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/23_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_day (0.00s)\n    --- PASS: TestRelativeTimeFormat/3_days (0.00s)\n    --- PASS: TestRelativeTimeFormat/7_days (0.00s)\n=== RUN   TestRelativeTimeFormatNeverSynced\n--- PASS: TestRelativeTimeFormatNeverSynced (0.00s)\nPASS\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.415s","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"8a7d668b-3fed-4800-a1a8-2a1450c552d8","tool_use_result":{"stdout":"=== RUN   TestCriticalErrorModalRequiresAcknowledgment\n--- PASS: TestCriticalErrorModalRequiresAcknowledgment (0.00s)\n=== RUN   TestCriticalErrorModalDismissedWithEscape\n--- PASS: TestCriticalErrorModalDismissedWithEscape (0.00s)\n=== RUN   TestErrorModalViewRendering\n--- PASS: TestErrorModalViewRendering (0.00s)\n=== RUN   TestDatabaseErrorShowsModal\n--- PASS: TestDatabaseErrorShowsModal (0.00s)\n=== RUN   TestNavigationBlockedDuringErrorModal\n--- PASS: TestNavigationBlockedDuringErrorModal (0.00s)\n=== RUN   TestRefreshBlockedDuringErrorModal\n--- PASS: TestRefreshBlockedDuringErrorModal (0.00s)\n=== RUN   TestNetworkErrorIncludesConnectivityGuidance\n--- PASS: TestNetworkErrorIncludesConnectivityGuidance (0.00s)\n=== RUN   TestSetLastSyncTime\n--- PASS: TestSetLastSyncTime (0.00s)\n=== RUN   TestLastSyncTimeDefaultIsZero\n--- PASS: TestLastSyncTimeDefaultIsZero (0.00s)\n=== RUN   TestStatusBarShowsLastSyncedTime\n--- PASS: TestStatusBarShowsLastSyncedTime (0.00s)\n=== RUN   TestLastSyncedRelativeTimeMinutesAgo\n--- PASS: TestLastSyncedRelativeTimeMinutesAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeSecondsAgo\n--- PASS: TestLastSyncedRelativeTimeSecondsAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeHoursAgo\n--- PASS: TestLastSyncedRelativeTimeHoursAgo (0.00s)\n=== RUN   TestLastSyncedRelativeTimeDaysAgo\n--- PASS: TestLastSyncedRelativeTimeDaysAgo (0.00s)\n=== RUN   TestLastSyncedNeverSynced\n--- PASS: TestLastSyncedNeverSynced (0.00s)\n=== RUN   TestLastSyncTimeUpdatedAfterRefresh\n--- PASS: TestLastSyncTimeUpdatedAfterRefresh (0.00s)\n=== RUN   TestLastSyncTimeNotChangedOnRefreshError\n--- PASS: TestLastSyncTimeNotChangedOnRefreshError (0.00s)\n=== RUN   TestRelativeTimeFormat\n=== RUN   TestRelativeTimeFormat/30_seconds\n=== RUN   TestRelativeTimeFormat/1_minute\n=== RUN   TestRelativeTimeFormat/5_minutes\n=== RUN   TestRelativeTimeFormat/59_minutes\n=== RUN   TestRelativeTimeFormat/1_hour\n=== RUN   TestRelativeTimeFormat/2_hours\n=== RUN   TestRelativeTimeFormat/23_hours\n=== RUN   TestRelativeTimeFormat/1_day\n=== RUN   TestRelativeTimeFormat/3_days\n=== RUN   TestRelativeTimeFormat/7_days\n--- PASS: TestRelativeTimeFormat (0.00s)\n    --- PASS: TestRelativeTimeFormat/30_seconds (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_minute (0.00s)\n    --- PASS: TestRelativeTimeFormat/5_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/59_minutes (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_hour (0.00s)\n    --- PASS: TestRelativeTimeFormat/2_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/23_hours (0.00s)\n    --- PASS: TestRelativeTimeFormat/1_day (0.00s)\n    --- PASS: TestRelativeTimeFormat/3_days (0.00s)\n    --- PASS: TestRelativeTimeFormat/7_days (0.00s)\n=== RUN   TestRelativeTimeFormatNeverSynced\n--- PASS: TestRelativeTimeFormatNeverSynced (0.00s)\nPASS\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.415s","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A5uGzTZ19JnUCGd1jpnzn2","type":"message","role":"assistant","content":[{"type":"text","text":"All TUI tests pass. Now let me run all tests to make sure nothing else is broken:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1206,"cache_read_input_tokens":89085,"cache_creation":{"ephemeral_5m_input_tokens":1206,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"b05168a7-e368-4ddb-a4ab-97305b041dd1"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A5uGzTZ19JnUCGd1jpnzn2","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01L3LYpPzABLSrbnkQiVG6WJ","name":"Bash","input":{"command":"go test ./... 2>&1"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1206,"cache_read_input_tokens":89085,"cache_creation":{"ephemeral_5m_input_tokens":1206,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"1d740d81-7a4c-43f5-9921-6c5f9b3dd744"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01L3LYpPzABLSrbnkQiVG6WJ","type":"tool_result","content":"?   \tgithub.com/shepbook/ghissues/cmd/ghissues\t[no test files]\nok  \tgithub.com/shepbook/ghissues/internal/auth\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/cmd\t0.953s\nok  \tgithub.com/shepbook/ghissues/internal/config\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/db\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/github\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/setup\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/sync\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.313s","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"c9d84e4c-324a-4c63-8a4c-f2823d18f16c","tool_use_result":{"stdout":"?   \tgithub.com/shepbook/ghissues/cmd/ghissues\t[no test files]\nok  \tgithub.com/shepbook/ghissues/internal/auth\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/cmd\t0.953s\nok  \tgithub.com/shepbook/ghissues/internal/config\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/db\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/github\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/setup\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/sync\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/tui\t0.313s","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018zgD6RnNvDcQmfch8cXvah","type":"message","role":"assistant","content":[{"type":"text","text":"All tests pass. Now let me run the linter:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":539,"cache_read_input_tokens":90291,"cache_creation":{"ephemeral_5m_input_tokens":539,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"ee212aea-be8f-487f-b43a-488976288859"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_018zgD6RnNvDcQmfch8cXvah","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_0197jYdTh3dPVrCzgNnBZ6Mh","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"in_progress","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":539,"cache_read_input_tokens":90291,"cache_creation":{"ephemeral_5m_input_tokens":539,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"b2c0b91c-caa8-4809-93d0-d0e3b93cb8d8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_0197jYdTh3dPVrCzgNnBZ6Mh","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"8b9f78bd-4e0b-4de0-a168-5667de15806b","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"in_progress","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"pending","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"in_progress","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0158TvkzZBEdypd3vhbyezYK","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Hot8dtbi57mzpTrg1ayBv8","name":"Bash","input":{"command":"go vet ./... && echo \"=== vet passed ===\" && go build ./... && echo \"=== build passed ===\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":382,"cache_read_input_tokens":90830,"cache_creation":{"ephemeral_5m_input_tokens":382,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"af2ce3b5-8228-448f-8ef6-758820168e80"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Hot8dtbi57mzpTrg1ayBv8","type":"tool_result","content":"=== vet passed ===\n=== build passed ===","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2d2bdf66-dc86-44f4-b06c-b9873460a6f0","tool_use_result":{"stdout":"=== vet passed ===\n=== build passed ===","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A5aQgv4F1wTuX9x4pHYuuw","type":"message","role":"assistant","content":[{"type":"text","text":"Let me also check for any existing linter in the repo (e.g., golangci-lint):"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":105,"cache_read_input_tokens":91212,"cache_creation":{"ephemeral_5m_input_tokens":105,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"c7f28d21-ccbc-40e7-ad3b-726103d60e0b"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01A5aQgv4F1wTuX9x4pHYuuw","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014aRkHqCFearPDQCCAZ4MEc","name":"Glob","input":{"pattern":"**/.golangci*"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":105,"cache_read_input_tokens":91212,"cache_creation":{"ephemeral_5m_input_tokens":105,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"a8d39b81-d6a5-4770-81b9-6776d3cd5994"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014aRkHqCFearPDQCCAZ4MEc","type":"tool_result","content":"No files found"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"1205ff13-ebf2-4d88-a5ee-f6bd000b55eb","tool_use_result":{"filenames":[],"durationMs":507,"numFiles":0,"truncated":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01W1RFW4TjL17vbkKAigXNvE","type":"message","role":"assistant","content":[{"type":"text","text":"No golangci-lint config file. Let me run a basic check with `gofmt`:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":96,"cache_read_input_tokens":91317,"cache_creation":{"ephemeral_5m_input_tokens":96,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"06b25d4b-1174-4331-a061-44553db91759"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01W1RFW4TjL17vbkKAigXNvE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01C6U2BTr16SMV5CpWPx8FJp","name":"Bash","input":{"command":"gofmt -l ./internal/tui/model.go ./internal/cmd/root.go 2>&1"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":96,"cache_read_input_tokens":91317,"cache_creation":{"ephemeral_5m_input_tokens":96,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"6c20675a-9be1-4b7d-b318-c4d2ede4da4f"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01C6U2BTr16SMV5CpWPx8FJp","type":"tool_result","content":"./internal/tui/model.go","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"7d97de35-ed23-40ef-b926-824c3cae463d","tool_use_result":{"stdout":"./internal/tui/model.go","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Preh5bNu7F3wpiKdxkFTVp","type":"message","role":"assistant","content":[{"type":"text","text":"Let me fix the formatting:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":120,"cache_read_input_tokens":91413,"cache_creation":{"ephemeral_5m_input_tokens":120,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"099247e4-c9b3-4294-9aac-2220ba6802b7"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01Preh5bNu7F3wpiKdxkFTVp","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01SwzEKr8mMXucCQTPDjfu1Y","name":"Bash","input":{"command":"gofmt -w ./internal/tui/model.go && gofmt -l ./internal/tui/model.go ./internal/cmd/root.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":120,"cache_read_input_tokens":91413,"cache_creation":{"ephemeral_5m_input_tokens":120,"ephemeral_1h_input_tokens":0},"output_tokens":3,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"6e7a0452-acc1-4958-928f-016307c7403d"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01SwzEKr8mMXucCQTPDjfu1Y","type":"tool_result","content":"","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"7f1af44f-91ee-45b2-b196-660760f11bd5","tool_use_result":{"stdout":"","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017ULsk281sNyYtzXLbqiiMb","type":"message","role":"assistant","content":[{"type":"text","text":"Now the formatting is fixed. Let me run all tests one more time to confirm everything is good:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":594,"cache_read_input_tokens":91533,"cache_creation":{"ephemeral_5m_input_tokens":594,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"abf40951-a820-45dc-9c96-7f50b45ff41a"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_017ULsk281sNyYtzXLbqiiMb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FiFGRh5XSohnZuu6HEXoYM","name":"Bash","input":{"command":"go test ./... 2>&1"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":594,"cache_read_input_tokens":91533,"cache_creation":{"ephemeral_5m_input_tokens":594,"ephemeral_1h_input_tokens":0},"output_tokens":2,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"13900bfc-3477-45ec-842a-3abee2747968"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FiFGRh5XSohnZuu6HEXoYM","type":"tool_result","content":"?   \tgithub.com/shepbook/ghissues/cmd/ghissues\t[no test files]\nok  \tgithub.com/shepbook/ghissues/internal/auth\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/cmd\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/config\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/db\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/github\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/setup\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/sync\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/tui\t(cached)","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"98f02cf2-7d53-4ad7-b340-1fe47df1fb55","tool_use_result":{"stdout":"?   \tgithub.com/shepbook/ghissues/cmd/ghissues\t[no test files]\nok  \tgithub.com/shepbook/ghissues/internal/auth\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/cmd\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/config\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/db\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/github\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/setup\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/sync\t(cached)\nok  \tgithub.com/shepbook/ghissues/internal/tui\t(cached)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DRTWn9s6gJGev5aY8u9w9N","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Bx3L38x8bT4nXwTKP37U7u","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"in_progress","activeForm":"Committing changes"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":293,"cache_read_input_tokens":92127,"cache_creation":{"ephemeral_5m_input_tokens":293,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"73672f3d-4f1e-489a-bba0-eaa22fbe9136"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Bx3L38x8bT4nXwTKP37U7u","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"70ceadda-3039-45f1-8558-b5b58120c4b9","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"in_progress","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"pending","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"in_progress","activeForm":"Committing changes"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XKUGnaFRyZqK5CjmAH7tdb","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me commit the changes:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":369,"cache_read_input_tokens":92420,"cache_creation":{"ephemeral_5m_input_tokens":369,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"23c9a44f-1fc8-4c6a-9506-2b3a6dc0803e"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01XKUGnaFRyZqK5CjmAH7tdb","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01FZCsC8jhD5HEwh9XZpkDmV","name":"Bash","input":{"command":"git status"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":369,"cache_read_input_tokens":92420,"cache_creation":{"ephemeral_5m_input_tokens":369,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"cbf84405-3773-492b-b63c-ddef123bdbd8"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01FZCsC8jhD5HEwh9XZpkDmV","type":"tool_result","content":"On branch claude-code-opus-implementation\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/config.toml\n\tmodified:   .ralph-tui/progress.md\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   internal/cmd/root.go\n\tmodified:   internal/tui/model.go\n\tmodified:   internal/tui/model_test.go\n\tmodified:   tasks/prd.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.ralph-tui/iterations/\n\t.ralph-tui/ralph.lock\n\t.ralph-tui/session.json\n\tinternal/cmd/.ghissues.db\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"cf211702-43c3-4017-81bf-561cb4a5c266","tool_use_result":{"stdout":"On branch claude-code-opus-implementation\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git restore <file>...\" to discard changes in working directory)\n\tmodified:   .ralph-tui/config.toml\n\tmodified:   .ralph-tui/progress.md\n\tmodified:   .ralph-tui/session-meta.json\n\tmodified:   internal/cmd/root.go\n\tmodified:   internal/tui/model.go\n\tmodified:   internal/tui/model_test.go\n\tmodified:   tasks/prd.json\n\nUntracked files:\n  (use \"git add <file>...\" to include in what will be committed)\n\t.ralph-tui/iterations/\n\t.ralph-tui/ralph.lock\n\t.ralph-tui/session.json\n\tinternal/cmd/.ghissues.db\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01LYSs1JFbYoDGLXquhPG2sq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01S8aU1bec3KfKfoZ9bsLPHi","name":"Bash","input":{"command":"git diff internal/cmd/root.go internal/tui/model.go internal/tui/model_test.go"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":312,"cache_read_input_tokens":92789,"cache_creation":{"ephemeral_5m_input_tokens":312,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"864bf967-9541-4dc2-b022-033c8239cdf4"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01S8aU1bec3KfKfoZ9bsLPHi","type":"tool_result","content":"diff --git a/internal/cmd/root.go b/internal/cmd/root.go\nindex e54415f..a76f903 100644\n--- a/internal/cmd/root.go\n+++ b/internal/cmd/root.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"strings\"\n+\t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n \t\"github.com/shepbook/ghissues/internal/auth\"\n@@ -132,6 +133,13 @@ You can also run 'ghissues config' to reconfigure at any time.`,\n \t\t\t\t_, sortOrder = config.DefaultSortConfig()\n \t\t\t}\n \n+\t\t\t// Load last sync time from database\n+\t\t\tlastSyncTime, err := store.GetLastSyncTime(context.Background())\n+\t\t\tif err != nil {\n+\t\t\t\t// Non-fatal error - just log and continue with zero time\n+\t\t\t\tlastSyncTime = time.Time{}\n+\t\t\t}\n+\n \t\t\t// Skip TUI if disabled (for testing)\n \t\t\tif disableTUI {\n \t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n@@ -146,6 +154,7 @@ You can also run 'ghissues config' to reconfigure at any time.`,\n \n \t\t\t// Create and run TUI\n \t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n+\t\t\tmodel.SetLastSyncTime(lastSyncTime)\n \n \t\t\t// Set up refresh function for manual refresh (r key)\n \t\t\t// This creates a closure that captures the necessary context\n@@ -276,6 +285,13 @@ func createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string)\n \t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n \t\t}\n \n-\t\treturn tui.RefreshDoneMsg{Issues: issues}\n+\t\t// Get the updated last sync time from the database\n+\t\tlastSyncTime, err := store.GetLastSyncTime(ctx)\n+\t\tif err != nil {\n+\t\t\t// Non-fatal - use current time as fallback\n+\t\t\tlastSyncTime = time.Now()\n+\t\t}\n+\n+\t\treturn tui.RefreshDoneMsg{Issues: issues, LastSyncTime: lastSyncTime}\n \t}\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex d9e5a3f..e0da466 100644\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -32,7 +32,8 @@ type RefreshProgressMsg struct {\n \n // RefreshDoneMsg is sent when refresh completes successfully\n type RefreshDoneMsg struct {\n-\tIssues []github.Issue\n+\tIssues       []github.Issue\n+\tLastSyncTime time.Time\n }\n \n // RefreshErrorMsg is sent when refresh fails\n@@ -52,20 +53,20 @@ type CriticalErrorMsg struct {\n \n // Model represents the TUI application state\n type Model struct {\n-\tissues           []github.Issue\n-\tcomments         []github.Comment\n-\tcolumns          []string\n-\tcursor           int\n-\twidth            int\n-\theight           int\n-\tsortField        config.SortField\n-\tsortOrder        config.SortOrder\n-\tsortChanged      bool // Track if sort was changed during session\n-\trawMarkdown      bool // Toggle between raw and rendered markdown\n-\tdetailScrollY    int  // Scroll offset for detail panel\n-\tcommentsScrollY  int  // Scroll offset for comments view\n-\tinCommentsView   bool // Whether we're in the comments view\n-\tglamourRenderer  *glamour.TermRenderer\n+\tissues          []github.Issue\n+\tcomments        []github.Comment\n+\tcolumns         []string\n+\tcursor          int\n+\twidth           int\n+\theight          int\n+\tsortField       config.SortField\n+\tsortOrder       config.SortOrder\n+\tsortChanged     bool // Track if sort was changed during session\n+\trawMarkdown     bool // Toggle between raw and rendered markdown\n+\tdetailScrollY   int  // Scroll offset for detail panel\n+\tcommentsScrollY int  // Scroll offset for comments view\n+\tinCommentsView  bool // Whether we're in the comments view\n+\tglamourRenderer *glamour.TermRenderer\n \n \t// Refresh state\n \tisRefreshing    bool            // Whether a refresh is in progress\n@@ -74,10 +75,13 @@ type Model struct {\n \trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n \n \t// Error modal state (for critical errors)\n-\tshowErrorModal    bool   // Whether the error modal is visible\n-\terrorModalTitle   string // Title of the error modal\n-\terrorModalMessage string // Error message to display\n+\tshowErrorModal     bool   // Whether the error modal is visible\n+\terrorModalTitle    string // Title of the error modal\n+\terrorModalMessage  string // Error message to display\n \terrorModalGuidance string // Optional actionable guidance\n+\n+\t// Last sync time\n+\tlastSyncTime time.Time // When data was last synced (zero = never)\n }\n \n // NewModel creates a new TUI model with the given issues and columns\n@@ -261,6 +265,10 @@ func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n+\t\t// Update last sync time\n+\t\tif !msg.LastSyncTime.IsZero() {\n+\t\t\tm.lastSyncTime = msg.LastSyncTime\n+\t\t}\n \tcase RefreshErrorMsg:\n \t\tm.isRefreshing = false\n \t\tm.refreshProgress = RefreshProgress{}\n@@ -370,6 +378,9 @@ func (m Model) View() string {\n \t\tsortIndicator = \"↑\"\n \t}\n \n+\t// Format last sync time\n+\tlastSyncedStr := formatRelativeTime(m.lastSyncTime)\n+\n \t// Build status line with refresh indicator or error\n \tvar status string\n \tif m.isRefreshing {\n@@ -396,8 +407,8 @@ func (m Model) View() string {\n \t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n \t\tb.WriteString(errorStyle.Render(status))\n \t} else {\n-\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n-\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n+\t\tstatus = fmt.Sprintf(\"Last synced: %s | %d issues | %s %s | r: refresh | q: quit\",\n+\t\t\tlastSyncedStr, len(m.issues), m.sortField.DisplayName(), sortIndicator)\n \t\tb.WriteString(statusStyle.Render(status))\n \t}\n \n@@ -857,6 +868,39 @@ func (m Model) GetErrorModalGuidance() string {\n \treturn m.errorModalGuidance\n }\n \n+// SetLastSyncTime sets the last sync time\n+func (m *Model) SetLastSyncTime(t time.Time) {\n+\tm.lastSyncTime = t\n+}\n+\n+// GetLastSyncTime returns the last sync time (zero value if never synced)\n+func (m Model) GetLastSyncTime() time.Time {\n+\treturn m.lastSyncTime\n+}\n+\n+// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")\n+func formatRelativeTime(t time.Time) string {\n+\tif t.IsZero() {\n+\t\treturn \"never\"\n+\t}\n+\n+\tdiff := time.Since(t)\n+\n+\tif diff < time.Minute {\n+\t\treturn \"<1m ago\"\n+\t}\n+\tif diff < time.Hour {\n+\t\tminutes := int(diff.Minutes())\n+\t\treturn fmt.Sprintf(\"%dm ago\", minutes)\n+\t}\n+\tif diff < 24*time.Hour {\n+\t\thours := int(diff.Hours())\n+\t\treturn fmt.Sprintf(\"%dh ago\", hours)\n+\t}\n+\tdays := int(diff.Hours() / 24)\n+\treturn fmt.Sprintf(\"%dd ago\", days)\n+}\n+\n // sortIssues sorts the issues based on the current sort field and order\n func (m *Model) sortIssues() {\n \tif len(m.issues) == 0 {\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nindex b574e97..b430a28 100644\n--- a/internal/tui/model_test.go\n+++ b/internal/tui/model_test.go\n@@ -3,6 +3,7 @@ package tui\n import (\n \t\"fmt\"\n \t\"testing\"\n+\t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n \t\"github.com/shepbook/ghissues/internal/config\"\n@@ -1438,3 +1439,186 @@ func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n \t// The error message and retry option should be visible\n \tassert.Contains(t, view, \"dial tcp\")\n }\n+\n+// Tests for Last Synced Indicator (US-010)\n+\n+func TestSetLastSyncTime(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\n+\tsyncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tassert.Equal(t, syncTime, m.GetLastSyncTime())\n+}\n+\n+func TestLastSyncTimeDefaultIsZero(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\n+\t// Default should be zero time (never synced)\n+\tassert.True(t, m.GetLastSyncTime().IsZero())\n+}\n+\n+func TestStatusBarShowsLastSyncedTime(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30) // Wide enough to show full status bar\n+\n+\t// Set last sync time to a few minutes ago\n+\tsyncTime := time.Now().Add(-5 * time.Minute)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Status bar should show \"Last synced:\" indicator\n+\tassert.Contains(t, view, \"Last synced:\")\n+}\n+\n+func TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 5 minutes ago\n+\tsyncTime := time.Now().Add(-5 * time.Minute)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"5 minutes ago\")\n+\tassert.Contains(t, view, \"5m ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 30 seconds ago\n+\tsyncTime := time.Now().Add(-30 * time.Second)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show \"just now\" or \"<1m ago\"\n+\tassert.Contains(t, view, \"<1m ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 2 hours ago\n+\tsyncTime := time.Now().Add(-2 * time.Hour)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"2h ago\")\n+\tassert.Contains(t, view, \"2h ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 3 days ago\n+\tsyncTime := time.Now().Add(-3 * 24 * time.Hour)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"3d ago\")\n+\tassert.Contains(t, view, \"3d ago\")\n+}\n+\n+func TestLastSyncedNeverSynced(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Don't set last sync time (zero value = never synced)\n+\tview := m.View()\n+\n+\t// Should show \"never\" or similar indicator\n+\tassert.Contains(t, view, \"Last synced: never\")\n+}\n+\n+func TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Initially never synced\n+\tassert.True(t, m.GetLastSyncTime().IsZero())\n+\n+\t// Start refresh\n+\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n+\tm = newModel.(Model)\n+\n+\t// Complete refresh - this should include the new sync time\n+\tnewSyncTime := time.Now()\n+\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})\n+\tm = newModel.(Model)\n+\n+\t// Last sync time should be updated\n+\tassert.False(t, m.GetLastSyncTime().IsZero())\n+\t// Should be approximately now (within a second)\n+\tassert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)\n+}\n+\n+func TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set initial sync time\n+\tinitialSyncTime := time.Now().Add(-10 * time.Minute)\n+\tm.SetLastSyncTime(initialSyncTime)\n+\n+\t// Start refresh\n+\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n+\tm = newModel.(Model)\n+\n+\t// Simulate error\n+\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n+\tm = newModel.(Model)\n+\n+\t// Last sync time should remain unchanged\n+\tassert.Equal(t, initialSyncTime, m.GetLastSyncTime())\n+}\n+\n+func TestRelativeTimeFormat(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tduration time.Duration\n+\t\texpected string\n+\t}{\n+\t\t{name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},\n+\t\t{name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},\n+\t\t{name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},\n+\t\t{name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},\n+\t\t{name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},\n+\t\t{name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},\n+\t\t{name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},\n+\t\t{name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},\n+\t\t{name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},\n+\t\t{name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := formatRelativeTime(time.Now().Add(-tt.duration))\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestRelativeTimeFormatNeverSynced(t *testing.T) {\n+\t// Zero time should return \"never\"\n+\tresult := formatRelativeTime(time.Time{})\n+\tassert.Equal(t, \"never\", result)\n+}","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"9303c331-63ee-4055-8ac5-5bc7b8dabf04","tool_use_result":{"stdout":"diff --git a/internal/cmd/root.go b/internal/cmd/root.go\nindex e54415f..a76f903 100644\n--- a/internal/cmd/root.go\n+++ b/internal/cmd/root.go\n@@ -4,6 +4,7 @@ import (\n \t\"context\"\n \t\"fmt\"\n \t\"strings\"\n+\t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n \t\"github.com/shepbook/ghissues/internal/auth\"\n@@ -132,6 +133,13 @@ You can also run 'ghissues config' to reconfigure at any time.`,\n \t\t\t\t_, sortOrder = config.DefaultSortConfig()\n \t\t\t}\n \n+\t\t\t// Load last sync time from database\n+\t\t\tlastSyncTime, err := store.GetLastSyncTime(context.Background())\n+\t\t\tif err != nil {\n+\t\t\t\t// Non-fatal error - just log and continue with zero time\n+\t\t\t\tlastSyncTime = time.Time{}\n+\t\t\t}\n+\n \t\t\t// Skip TUI if disabled (for testing)\n \t\t\tif disableTUI {\n \t\t\t\tfmt.Fprintf(cmd.OutOrStdout(), \"Ready to browse issues from %s (%d issues)\\n\", cfg.Repository, len(issues))\n@@ -146,6 +154,7 @@ You can also run 'ghissues config' to reconfigure at any time.`,\n \n \t\t\t// Create and run TUI\n \t\t\tmodel := tui.NewModelWithSort(issues, columns, sortField, sortOrder)\n+\t\t\tmodel.SetLastSyncTime(lastSyncTime)\n \n \t\t\t// Set up refresh function for manual refresh (r key)\n \t\t\t// This creates a closure that captures the necessary context\n@@ -276,6 +285,13 @@ func createRefreshFunc(cfg *config.Config, store *db.Store, owner, repo string)\n \t\t\treturn tui.RefreshErrorMsg{Err: fmt.Errorf(\"failed to load issues after sync: %w\", err)}\n \t\t}\n \n-\t\treturn tui.RefreshDoneMsg{Issues: issues}\n+\t\t// Get the updated last sync time from the database\n+\t\tlastSyncTime, err := store.GetLastSyncTime(ctx)\n+\t\tif err != nil {\n+\t\t\t// Non-fatal - use current time as fallback\n+\t\t\tlastSyncTime = time.Now()\n+\t\t}\n+\n+\t\treturn tui.RefreshDoneMsg{Issues: issues, LastSyncTime: lastSyncTime}\n \t}\n }\ndiff --git a/internal/tui/model.go b/internal/tui/model.go\nindex d9e5a3f..e0da466 100644\n--- a/internal/tui/model.go\n+++ b/internal/tui/model.go\n@@ -32,7 +32,8 @@ type RefreshProgressMsg struct {\n \n // RefreshDoneMsg is sent when refresh completes successfully\n type RefreshDoneMsg struct {\n-\tIssues []github.Issue\n+\tIssues       []github.Issue\n+\tLastSyncTime time.Time\n }\n \n // RefreshErrorMsg is sent when refresh fails\n@@ -52,20 +53,20 @@ type CriticalErrorMsg struct {\n \n // Model represents the TUI application state\n type Model struct {\n-\tissues           []github.Issue\n-\tcomments         []github.Comment\n-\tcolumns          []string\n-\tcursor           int\n-\twidth            int\n-\theight           int\n-\tsortField        config.SortField\n-\tsortOrder        config.SortOrder\n-\tsortChanged      bool // Track if sort was changed during session\n-\trawMarkdown      bool // Toggle between raw and rendered markdown\n-\tdetailScrollY    int  // Scroll offset for detail panel\n-\tcommentsScrollY  int  // Scroll offset for comments view\n-\tinCommentsView   bool // Whether we're in the comments view\n-\tglamourRenderer  *glamour.TermRenderer\n+\tissues          []github.Issue\n+\tcomments        []github.Comment\n+\tcolumns         []string\n+\tcursor          int\n+\twidth           int\n+\theight          int\n+\tsortField       config.SortField\n+\tsortOrder       config.SortOrder\n+\tsortChanged     bool // Track if sort was changed during session\n+\trawMarkdown     bool // Toggle between raw and rendered markdown\n+\tdetailScrollY   int  // Scroll offset for detail panel\n+\tcommentsScrollY int  // Scroll offset for comments view\n+\tinCommentsView  bool // Whether we're in the comments view\n+\tglamourRenderer *glamour.TermRenderer\n \n \t// Refresh state\n \tisRefreshing    bool            // Whether a refresh is in progress\n@@ -74,10 +75,13 @@ type Model struct {\n \trefreshFunc     func() tea.Msg  // Function to call to perform refresh\n \n \t// Error modal state (for critical errors)\n-\tshowErrorModal    bool   // Whether the error modal is visible\n-\terrorModalTitle   string // Title of the error modal\n-\terrorModalMessage string // Error message to display\n+\tshowErrorModal     bool   // Whether the error modal is visible\n+\terrorModalTitle    string // Title of the error modal\n+\terrorModalMessage  string // Error message to display\n \terrorModalGuidance string // Optional actionable guidance\n+\n+\t// Last sync time\n+\tlastSyncTime time.Time // When data was last synced (zero = never)\n }\n \n // NewModel creates a new TUI model with the given issues and columns\n@@ -261,6 +265,10 @@ func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n+\t\t// Update last sync time\n+\t\tif !msg.LastSyncTime.IsZero() {\n+\t\t\tm.lastSyncTime = msg.LastSyncTime\n+\t\t}\n \tcase RefreshErrorMsg:\n \t\tm.isRefreshing = false\n \t\tm.refreshProgress = RefreshProgress{}\n@@ -370,6 +378,9 @@ func (m Model) View() string {\n \t\tsortIndicator = \"↑\"\n \t}\n \n+\t// Format last sync time\n+\tlastSyncedStr := formatRelativeTime(m.lastSyncTime)\n+\n \t// Build status line with refresh indicator or error\n \tvar status string\n \tif m.isRefreshing {\n@@ -396,8 +407,8 @@ func (m Model) View() string {\n \t\tstatus = fmt.Sprintf(\"Error: %s | r: retry | q: quit\", errMsg)\n \t\tb.WriteString(errorStyle.Render(status))\n \t} else {\n-\t\tstatus = fmt.Sprintf(\"%d issues | %s %s | s: sort | S: reverse | r: refresh | m: markdown | j/k: nav | h/l: scroll | Enter: comments | q: quit\",\n-\t\t\tlen(m.issues), m.sortField.DisplayName(), sortIndicator)\n+\t\tstatus = fmt.Sprintf(\"Last synced: %s | %d issues | %s %s | r: refresh | q: quit\",\n+\t\t\tlastSyncedStr, len(m.issues), m.sortField.DisplayName(), sortIndicator)\n \t\tb.WriteString(statusStyle.Render(status))\n \t}\n \n@@ -857,6 +868,39 @@ func (m Model) GetErrorModalGuidance() string {\n \treturn m.errorModalGuidance\n }\n \n+// SetLastSyncTime sets the last sync time\n+func (m *Model) SetLastSyncTime(t time.Time) {\n+\tm.lastSyncTime = t\n+}\n+\n+// GetLastSyncTime returns the last sync time (zero value if never synced)\n+func (m Model) GetLastSyncTime() time.Time {\n+\treturn m.lastSyncTime\n+}\n+\n+// formatRelativeTime formats a time as a relative duration (e.g., \"5m ago\")\n+func formatRelativeTime(t time.Time) string {\n+\tif t.IsZero() {\n+\t\treturn \"never\"\n+\t}\n+\n+\tdiff := time.Since(t)\n+\n+\tif diff < time.Minute {\n+\t\treturn \"<1m ago\"\n+\t}\n+\tif diff < time.Hour {\n+\t\tminutes := int(diff.Minutes())\n+\t\treturn fmt.Sprintf(\"%dm ago\", minutes)\n+\t}\n+\tif diff < 24*time.Hour {\n+\t\thours := int(diff.Hours())\n+\t\treturn fmt.Sprintf(\"%dh ago\", hours)\n+\t}\n+\tdays := int(diff.Hours() / 24)\n+\treturn fmt.Sprintf(\"%dd ago\", days)\n+}\n+\n // sortIssues sorts the issues based on the current sort field and order\n func (m *Model) sortIssues() {\n \tif len(m.issues) == 0 {\ndiff --git a/internal/tui/model_test.go b/internal/tui/model_test.go\nindex b574e97..b430a28 100644\n--- a/internal/tui/model_test.go\n+++ b/internal/tui/model_test.go\n@@ -3,6 +3,7 @@ package tui\n import (\n \t\"fmt\"\n \t\"testing\"\n+\t\"time\"\n \n \ttea \"github.com/charmbracelet/bubbletea\"\n \t\"github.com/shepbook/ghissues/internal/config\"\n@@ -1438,3 +1439,186 @@ func TestNetworkErrorIncludesConnectivityGuidance(t *testing.T) {\n \t// The error message and retry option should be visible\n \tassert.Contains(t, view, \"dial tcp\")\n }\n+\n+// Tests for Last Synced Indicator (US-010)\n+\n+func TestSetLastSyncTime(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\n+\tsyncTime := time.Date(2024, 1, 20, 14, 30, 0, 0, time.UTC)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tassert.Equal(t, syncTime, m.GetLastSyncTime())\n+}\n+\n+func TestLastSyncTimeDefaultIsZero(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\n+\t// Default should be zero time (never synced)\n+\tassert.True(t, m.GetLastSyncTime().IsZero())\n+}\n+\n+func TestStatusBarShowsLastSyncedTime(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30) // Wide enough to show full status bar\n+\n+\t// Set last sync time to a few minutes ago\n+\tsyncTime := time.Now().Add(-5 * time.Minute)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Status bar should show \"Last synced:\" indicator\n+\tassert.Contains(t, view, \"Last synced:\")\n+}\n+\n+func TestLastSyncedRelativeTimeMinutesAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 5 minutes ago\n+\tsyncTime := time.Now().Add(-5 * time.Minute)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"5 minutes ago\")\n+\tassert.Contains(t, view, \"5m ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeSecondsAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 30 seconds ago\n+\tsyncTime := time.Now().Add(-30 * time.Second)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show \"just now\" or \"<1m ago\"\n+\tassert.Contains(t, view, \"<1m ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeHoursAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 2 hours ago\n+\tsyncTime := time.Now().Add(-2 * time.Hour)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"2h ago\")\n+\tassert.Contains(t, view, \"2h ago\")\n+}\n+\n+func TestLastSyncedRelativeTimeDaysAgo(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set last sync time to 3 days ago\n+\tsyncTime := time.Now().Add(-3 * 24 * time.Hour)\n+\tm.SetLastSyncTime(syncTime)\n+\n+\tview := m.View()\n+\n+\t// Should show relative time (e.g., \"3d ago\")\n+\tassert.Contains(t, view, \"3d ago\")\n+}\n+\n+func TestLastSyncedNeverSynced(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Don't set last sync time (zero value = never synced)\n+\tview := m.View()\n+\n+\t// Should show \"never\" or similar indicator\n+\tassert.Contains(t, view, \"Last synced: never\")\n+}\n+\n+func TestLastSyncTimeUpdatedAfterRefresh(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Initially never synced\n+\tassert.True(t, m.GetLastSyncTime().IsZero())\n+\n+\t// Start refresh\n+\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n+\tm = newModel.(Model)\n+\n+\t// Complete refresh - this should include the new sync time\n+\tnewSyncTime := time.Now()\n+\tnewModel, _ = m.Update(RefreshDoneMsg{Issues: createTestIssues(), LastSyncTime: newSyncTime})\n+\tm = newModel.(Model)\n+\n+\t// Last sync time should be updated\n+\tassert.False(t, m.GetLastSyncTime().IsZero())\n+\t// Should be approximately now (within a second)\n+\tassert.WithinDuration(t, newSyncTime, m.GetLastSyncTime(), time.Second)\n+}\n+\n+func TestLastSyncTimeNotChangedOnRefreshError(t *testing.T) {\n+\tissues := createTestIssues()\n+\tm := NewModel(issues, nil)\n+\tm.SetWindowSize(160, 30)\n+\n+\t// Set initial sync time\n+\tinitialSyncTime := time.Now().Add(-10 * time.Minute)\n+\tm.SetLastSyncTime(initialSyncTime)\n+\n+\t// Start refresh\n+\tnewModel, _ := m.Update(tea.KeyMsg{Type: tea.KeyRunes, Runes: []rune{'r'}})\n+\tm = newModel.(Model)\n+\n+\t// Simulate error\n+\tnewModel, _ = m.Update(RefreshErrorMsg{Err: fmt.Errorf(\"network error\")})\n+\tm = newModel.(Model)\n+\n+\t// Last sync time should remain unchanged\n+\tassert.Equal(t, initialSyncTime, m.GetLastSyncTime())\n+}\n+\n+func TestRelativeTimeFormat(t *testing.T) {\n+\ttests := []struct {\n+\t\tname     string\n+\t\tduration time.Duration\n+\t\texpected string\n+\t}{\n+\t\t{name: \"30 seconds\", duration: 30 * time.Second, expected: \"<1m ago\"},\n+\t\t{name: \"1 minute\", duration: 1 * time.Minute, expected: \"1m ago\"},\n+\t\t{name: \"5 minutes\", duration: 5 * time.Minute, expected: \"5m ago\"},\n+\t\t{name: \"59 minutes\", duration: 59 * time.Minute, expected: \"59m ago\"},\n+\t\t{name: \"1 hour\", duration: 1 * time.Hour, expected: \"1h ago\"},\n+\t\t{name: \"2 hours\", duration: 2 * time.Hour, expected: \"2h ago\"},\n+\t\t{name: \"23 hours\", duration: 23 * time.Hour, expected: \"23h ago\"},\n+\t\t{name: \"1 day\", duration: 24 * time.Hour, expected: \"1d ago\"},\n+\t\t{name: \"3 days\", duration: 3 * 24 * time.Hour, expected: \"3d ago\"},\n+\t\t{name: \"7 days\", duration: 7 * 24 * time.Hour, expected: \"7d ago\"},\n+\t}\n+\n+\tfor _, tt := range tests {\n+\t\tt.Run(tt.name, func(t *testing.T) {\n+\t\t\tresult := formatRelativeTime(time.Now().Add(-tt.duration))\n+\t\t\tassert.Equal(t, tt.expected, result)\n+\t\t})\n+\t}\n+}\n+\n+func TestRelativeTimeFormatNeverSynced(t *testing.T) {\n+\t// Zero time should return \"never\"\n+\tresult := formatRelativeTime(time.Time{})\n+\tassert.Equal(t, \"never\", result)\n+}","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MxwrRgeLAVTFZjBNjoauhE","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me see recent commit messages to follow the style:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4766,"cache_read_input_tokens":93101,"cache_creation":{"ephemeral_5m_input_tokens":4766,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"93622775-d4dc-433d-87ea-0eee6d3c2612"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01MxwrRgeLAVTFZjBNjoauhE","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Fxm4s2RxW2cm4MuZddvjM9","name":"Bash","input":{"command":"git log --oneline -5"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":4766,"cache_read_input_tokens":93101,"cache_creation":{"ephemeral_5m_input_tokens":4766,"ephemeral_1h_input_tokens":0},"output_tokens":4,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"0067bebc-72a4-4920-b6f6-0de78e5a7ddb"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Fxm4s2RxW2cm4MuZddvjM9","type":"tool_result","content":"7931331 feat: US-013 - Error Handling\n45932ee feat: US-009 - Data Refresh\na8153a2 feat: US-008 - Comments View\n636f118 feat: US-007 - Issue Detail View\n7f705f5 feat: US-006 - Issue Sorting","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"0192eb38-c2a1-4ee3-a52a-b6f16028cdda","tool_use_result":{"stdout":"7931331 feat: US-013 - Error Handling\n45932ee feat: US-009 - Data Refresh\na8153a2 feat: US-008 - Comments View\n636f118 feat: US-007 - Issue Detail View\n7f705f5 feat: US-006 - Issue Sorting","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01SDKcihoN83rvpFghtBnFkq","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_018xboHJ6hJJ649suKYF2RrM","name":"Bash","input":{"command":"git add internal/cmd/root.go internal/tui/model.go internal/tui/model_test.go && git commit -m \"$(cat <<'EOF'\nfeat: US-010 - Last Synced Indicator\n\nCo-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>\nEOF\n)\""}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":159,"cache_read_input_tokens":97867,"cache_creation":{"ephemeral_5m_input_tokens":159,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"8c100ec6-41ee-42a4-868a-b6c8f56568c6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_018xboHJ6hJJ649suKYF2RrM","type":"tool_result","content":"[claude-code-opus-implementation f4dd066] feat: US-010 - Last Synced Indicator\n 3 files changed, 265 insertions(+), 21 deletions(-)","is_error":false}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"f0712625-7094-4d06-86d1-e27ea3e97065","tool_use_result":{"stdout":"[claude-code-opus-implementation f4dd066] feat: US-010 - Last Synced Indicator\n 3 files changed, 265 insertions(+), 21 deletions(-)","stderr":"","interrupted":false,"isImage":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01TgcezXLvLTDBPskwMm95SS","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01Mre34vCwk6KtRxi1HkSgUT","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"completed","activeForm":"Committing changes"},{"content":"Update progress.md with learnings","status":"in_progress","activeForm":"Updating progress documentation"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":192,"cache_read_input_tokens":98026,"cache_creation":{"ephemeral_5m_input_tokens":192,"ephemeral_1h_input_tokens":0},"output_tokens":26,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2d33f31b-7d19-426b-9494-d212bb546658"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01Mre34vCwk6KtRxi1HkSgUT","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"b119b9a0-9226-4f69-bbeb-89ab01a6fb1a","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"in_progress","activeForm":"Committing changes"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"completed","activeForm":"Committing changes"},{"content":"Update progress.md with learnings","status":"in_progress","activeForm":"Updating progress documentation"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DEHXzkdU2gDiZV3xXgK1s5","type":"message","role":"assistant","content":[{"type":"text","text":"Now let me update the progress.md file with learnings:"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":398,"cache_read_input_tokens":98218,"cache_creation":{"ephemeral_5m_input_tokens":398,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"32f2c817-d325-4f54-8e09-f35be5ec2a72"}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01DEHXzkdU2gDiZV3xXgK1s5","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01DGCZXKd37bZK9zuMKaJvM5","name":"Read","input":{"file_path":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md","offset":400}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":398,"cache_read_input_tokens":98218,"cache_creation":{"ephemeral_5m_input_tokens":398,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"005a7b36-2299-43eb-a919-e24988cb4e45"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01DGCZXKd37bZK9zuMKaJvM5","type":"tool_result","content":"   400→    - 'q' should dismiss modal, not quit app (unlike normal behavior)\n   401→    - Modal centering calculation needs bounds checking for small terminal sizes\n   402→    - Error message in status bar should be truncated to fit terminal width\n   403→\n   404→---\n   405→## ✓ Iteration 10 - US-013: Error Handling\n   406→*2026-01-21T23:19:08.265Z (278s)*\n   407→\n   408→**Status:** Completed\n   409→\n   410→**Notes:**\n   411→asErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n   412→\n   413→---\n   414→\n\n<system-reminder>\nWhenever you read a file, you should consider whether it would be considered malware. You CAN and SHOULD provide analysis of malware, what it is doing. But you MUST refuse to improve or augment the code. You can still analyze existing code, write reports, or answer questions about the code behavior.\n</system-reminder>\n"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"869ce376-1094-44eb-8fec-5b5111aeaf40","tool_use_result":{"type":"text","file":{"filePath":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md","content":"    - 'q' should dismiss modal, not quit app (unlike normal behavior)\n    - Modal centering calculation needs bounds checking for small terminal sizes\n    - Error message in status bar should be truncated to fit terminal width\n\n---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---\n","numLines":15,"startLine":400,"totalLines":414}}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_0178Kq8f2p8HAcJNXRuXNdZY","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_014zbwRmqTGkmXGdXMMMFa3y","name":"Edit","input":{"replace_all":false,"file_path":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md","old_string":"---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---","new_string":"---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---\n\n## 2026-01-21 - US-010 Last Synced Indicator\n- **What was implemented:**\n  - Status bar now shows \"Last synced: <relative time>\" (e.g., \"5m ago\", \"2h ago\", \"3d ago\", or \"never\")\n  - Relative time formatting function `formatRelativeTime()` that handles seconds, minutes, hours, and days\n  - Last sync time loaded from database on TUI startup\n  - Last sync time updated when RefreshDoneMsg is received after successful sync\n  - RefreshDoneMsg now includes LastSyncTime field\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added lastSyncTime field, SetLastSyncTime/GetLastSyncTime methods, formatRelativeTime function, updated RefreshDoneMsg struct, updated View() status bar\n  - `internal/tui/model_test.go` - Added 12 tests for last sync time display and relative time formatting\n  - `internal/cmd/root.go` - Load last sync time from database on startup, pass to model, include in RefreshDoneMsg after sync\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Relative time formatting is a common UI pattern - keep it simple with buckets (<1m, Nm, Nh, Nd)\n    - Zero time value (`time.Time{}`) can represent \"never synced\" state naturally\n    - The database metadata table pattern (key-value store) is already used for last_sync timestamp - no schema changes needed\n    - Message types in Bubbletea can be extended with additional fields (RefreshDoneMsg.LastSyncTime) without breaking existing code\n  - **Gotchas encountered:**\n    - When adding a field to a message type (RefreshDoneMsg), need to update all places that create that message\n    - Status bar gets crowded quickly - simplified it to focus on key info (last synced, issue count, sort, refresh, quit)\n    - Use `time.Since()` for duration calculation - simpler than manual subtraction\n\n---"}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":504,"cache_read_input_tokens":98616,"cache_creation":{"ephemeral_5m_input_tokens":504,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"2718dfff-a45d-4426-9cf9-25c6ba3ecfd6"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_014zbwRmqTGkmXGdXMMMFa3y","type":"tool_result","content":"The file /Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md has been updated successfully."}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"bc0ada75-5f11-42cf-96cb-aaf21157f71d","tool_use_result":{"filePath":"/Users/shepbook/git/github-issues-tui/.ralph-tui/progress.md","oldString":"---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---","newString":"---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---\n\n## 2026-01-21 - US-010 Last Synced Indicator\n- **What was implemented:**\n  - Status bar now shows \"Last synced: <relative time>\" (e.g., \"5m ago\", \"2h ago\", \"3d ago\", or \"never\")\n  - Relative time formatting function `formatRelativeTime()` that handles seconds, minutes, hours, and days\n  - Last sync time loaded from database on TUI startup\n  - Last sync time updated when RefreshDoneMsg is received after successful sync\n  - RefreshDoneMsg now includes LastSyncTime field\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added lastSyncTime field, SetLastSyncTime/GetLastSyncTime methods, formatRelativeTime function, updated RefreshDoneMsg struct, updated View() status bar\n  - `internal/tui/model_test.go` - Added 12 tests for last sync time display and relative time formatting\n  - `internal/cmd/root.go` - Load last sync time from database on startup, pass to model, include in RefreshDoneMsg after sync\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Relative time formatting is a common UI pattern - keep it simple with buckets (<1m, Nm, Nh, Nd)\n    - Zero time value (`time.Time{}`) can represent \"never synced\" state naturally\n    - The database metadata table pattern (key-value store) is already used for last_sync timestamp - no schema changes needed\n    - Message types in Bubbletea can be extended with additional fields (RefreshDoneMsg.LastSyncTime) without breaking existing code\n  - **Gotchas encountered:**\n    - When adding a field to a message type (RefreshDoneMsg), need to update all places that create that message\n    - Status bar gets crowded quickly - simplified it to focus on key info (last synced, issue count, sort, refresh, quit)\n    - Use `time.Since()` for duration calculation - simpler than manual subtraction\n\n---","originalFile":"# Ralph Progress Log\n\nThis file tracks progress across iterations. It's automatically updated\nafter each iteration and included in agent prompts for context.\n\n## Codebase Patterns (Study These First)\n\n### Project Structure\n- `cmd/ghissues/main.go` - Main entry point, minimal - just calls `cmd.Execute()`\n- `internal/config/` - Configuration types and TOML file handling\n- `internal/setup/` - Interactive setup prompts using charmbracelet/huh\n- `internal/cmd/` - Cobra CLI commands (root command and subcommands)\n\n### Configuration Pattern\n- Config struct lives in `internal/config/config.go`\n- Use `config.DefaultConfigPath()` to get `~/.config/ghissues/config.toml`\n- Config saved with 0600 permissions for security (tokens may be stored)\n- TOML format for human-readable configuration\n\n### CLI Command Pattern (Cobra)\n- Root command created by `NewRootCmd()` function\n- Subcommands added via `rootCmd.AddCommand()`\n- For testable output, use `cmd.OutOrStdout()` not `fmt.Println()`\n- Global state (like configPath, dbPath) exposed via getter/setter for testing\n- Use `PersistentFlags()` for flags available to all subcommands (like --db)\n- Use `PersistentPreRunE` to set global state from flags before RunE executes\n\n### Database Path Pattern\n- `internal/db/path.go` - Database path resolution with precedence: flag -> config -> default\n- Default database path is `.ghissues.db` in current working directory\n- Config can override via `[database] path = \"...\"` in TOML\n- `--db` flag takes highest precedence\n- `EnsureDBPath()` creates parent directories and validates writability\n- `IsPathWritable()` uses temp file creation to verify write access\n\n### Testing Pattern\n- Tests use `t.TempDir()` for isolated file system tests\n- Use `defer SetConfigPath(\"\")` to reset global state after tests\n- Interactive prompts (huh) can't be tested directly - use `RunSetupWithValues()` for programmatic setup\n- For external dependencies (gh CLI, APIs), use package-level function variables that can be replaced in tests\n- Example: `var ghCLITokenFunc = getTokenFromGhCLI` allows mocking in tests\n- Use `httptest.NewServer` to mock HTTP APIs in tests\n- GitHub client has `SetBaseURL()` method for testing with mock servers\n\n### GitHub API Pattern\n- `internal/github/client.go` - GraphQL API client for fetching issues and comments\n- Use GraphQL for efficient fetching with automatic pagination\n- `FetchIssues()` and `FetchIssueComments()` handle pagination automatically\n- Progress callbacks allow real-time progress reporting\n- Context cancellation support for graceful shutdown\n\n### Database Pattern\n- `internal/db/store.go` - LibSQL/SQLite storage using `github.com/tursodatabase/go-libsql`\n- Schema created on `NewStore()` - tables for issues, comments, metadata\n- Store labels and assignees as JSON strings in issue table\n- Use transactions for batch operations (`SaveIssues`, `SaveComments`)\n- `defer func() { _ = tx.Rollback() }()` pattern for safe transaction cleanup\n\n### Sync Pattern\n- `internal/sync/sync.go` - Orchestrates fetching and storing\n- Progress callback reports phase (\"issues\" or \"comments\") and counts\n- Fetches all issues first, then comments for issues that have them\n- Updates `last_sync` metadata after successful sync\n\n### Authentication Pattern\n- `internal/auth/auth.go` - Token retrieval with priority: env var -> config -> gh CLI\n- `GetToken(cfg)` returns (token, source, error) - source indicates where token came from\n- `ValidateToken(token)` validates against GitHub API with helpful error messages\n- Sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) allow callers to check error types with `errors.Is()`\n\n### TUI Pattern\n- `internal/tui/model.go` - Bubbletea Model for issue list view\n- Model implements `tea.Model` interface: `Init()`, `Update()`, `View()`\n- Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n- `SetDisableTUI(true)` package-level variable allows bypassing TUI in tests\n- Test TUI by calling `Update()` with `tea.KeyMsg` directly - no TTY needed\n- View() can be tested by setting window size and checking output strings\n\n---\n\n## 2026-01-21 - US-001 First-Time Setup\n- **What was implemented:**\n  - Complete first-time setup flow with interactive prompts\n  - Config package for TOML configuration file handling\n  - Setup package with charmbracelet/huh for interactive forms\n  - CLI commands using cobra (root and config subcommand)\n  - Non-interactive setup via flags (--repo, --auth-method, --token)\n\n- **Files changed:**\n  - `cmd/ghissues/main.go` - Main entry point\n  - `go.mod`, `go.sum` - Module definition and dependencies\n  - `internal/config/config.go` - Config types, load/save, validation\n  - `internal/config/config_test.go` - Config tests\n  - `internal/setup/setup.go` - Interactive and programmatic setup\n  - `internal/setup/setup_test.go` - Setup tests\n  - `internal/cmd/root.go` - Root and config CLI commands\n  - `internal/cmd/root_test.go` - CLI tests\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Separating interactive setup (`RunInteractiveSetup`) from programmatic setup (`RunSetupWithValues`) enables testability\n    - Use `cmd.OutOrStdout()` in cobra commands for testable output instead of `fmt.Println()`\n    - Global package variables (configPath) need getter/setter functions for testing\n  - **Gotchas encountered:**\n    - `huh` forms require TTY and fail in test environments - provide programmatic alternative\n    - When testing cobra subcommands, use `rootCmd.SetArgs([]string{\"subcommand\", \"--flag\", \"value\"})` then `rootCmd.Execute()` - not direct subcommand execution\n    - `go mod tidy` may remove indirect dependencies needed by tests - run after adding test imports\n\n---\n\n## 2026-01-21 - US-002 GitHub Authentication\n- **What was implemented:**\n  - Auth package with `GetToken()` function supporting three authentication methods in priority order:\n    1. GITHUB_TOKEN environment variable\n    2. Config file token (when auth.method is \"token\")\n    3. GitHub CLI (`gh auth token`)\n  - `ValidateToken()` function that validates tokens against GitHub API\n  - Clear, helpful error messages for authentication failures\n  - TokenSource type to indicate where the token was retrieved from\n\n- **Files changed:**\n  - `internal/auth/auth.go` - Token retrieval and validation logic\n  - `internal/auth/auth_test.go` - Comprehensive tests with mocked gh CLI\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use package-level function variables (`var ghCLITokenFunc = getTokenFromGhCLI`) to enable mocking external commands in tests\n    - Return source information (TokenSource) alongside the token so callers know where auth came from\n    - Use sentinel errors (`ErrNoAuth`, `ErrInvalidToken`) with `fmt.Errorf(\"%w: ...\")` to allow `errors.Is()` checks\n  - **Gotchas encountered:**\n    - When the gh CLI is installed and authenticated on the dev machine, tests that expect \"no auth available\" will fail - must mock the gh CLI function\n    - Use test helper functions (`mockGhCLI`, `mockGhCLIUnavailable`) that return cleanup functions for consistent test isolation\n\n---\n\n## 2026-01-21 - US-004 Database Storage Location\n- **What was implemented:**\n  - Database path configuration with three-level precedence: `--db` flag > config file > default\n  - Default location is `.ghissues.db` in current working directory\n  - `DatabaseConfig` struct added to config with TOML support\n  - `internal/db/path.go` package for path resolution and validation\n  - Parent directory creation when using custom paths\n  - Clear error messages when paths are not writable\n\n- **Files changed:**\n  - `internal/config/config.go` - Added `DatabaseConfig` struct to `Config`\n  - `internal/config/config_test.go` - Tests for database config loading/saving\n  - `internal/db/path.go` - New package for database path resolution\n  - `internal/db/path_test.go` - Comprehensive tests for path resolution\n  - `internal/cmd/root.go` - Added `--db` flag, `SetDBPath()`/`GetDBPath()` functions\n  - `internal/cmd/root_test.go` - Tests for `--db` flag behavior and precedence\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `PersistentPreRunE` to set global state from flags before `RunE` executes\n    - Use `PersistentFlags()` for flags that should be available to all subcommands\n    - Test writability by attempting to create a temp file, not just checking permissions\n  - **Gotchas encountered:**\n    - `os.Getuid() == 0` check needed to skip writability tests when running as root\n    - When testing path validation, use `/root/...` paths on Unix (generally unwritable)\n    - Relative paths like `.ghissues.db` have parent dir `.` which requires special handling\n\n---\n\n## 2026-01-21 - US-003 Initial Issue Sync\n- **What was implemented:**\n  - GitHub GraphQL API client for fetching issues and comments with automatic pagination\n  - LibSQL database store with schema for issues, comments, labels, assignees\n  - Sync command (`ghissues sync`) with progress bar and Ctrl+C cancellation\n  - Progress callback reporting during fetch operations\n\n- **Files changed:**\n  - `internal/github/client.go` - GitHub GraphQL API client\n  - `internal/github/client_test.go` - Tests with mock HTTP server\n  - `internal/db/store.go` - Database store using libsql\n  - `internal/db/store_test.go` - Database operation tests\n  - `internal/sync/sync.go` - Sync orchestration logic\n  - `internal/sync/sync_test.go` - Sync tests with mocked GitHub\n  - `internal/cmd/sync.go` - CLI sync subcommand\n  - `internal/cmd/sync_test.go` - CLI sync tests\n  - `internal/cmd/root.go` - Added sync subcommand registration\n  - `go.mod`, `go.sum` - Added libsql dependency\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - LibSQL driver requires executing schema statements one at a time (not batched in single Exec)\n    - Use `Client.SetBaseURL()` method to allow test injection of mock server URLs\n    - Store complex data (labels, assignees) as JSON strings in SQLite for simplicity\n    - Use `signal.Notify` with context cancellation for graceful Ctrl+C handling\n  - **Gotchas encountered:**\n    - LibSQL multi-statement Exec fails silently - split into individual statements\n    - In tests with `httptest.NewServer`, need to check for context cancellation in handler\n    - Transaction rollback return values should be explicitly ignored with `_ = tx.Rollback()`\n    - When gh CLI is installed locally, tests expecting \"no auth\" may pass due to fallback auth\n\n---\n\n## 2026-01-21 - US-005 Issue List View\n- **What was implemented:**\n  - TUI package using charmbracelet/bubbletea for the issue list view\n  - Configurable columns with defaults: number, title, author, date, comments\n  - DisplayConfig struct added to config for storing column configuration\n  - Vim keys (j/k) and arrow keys for navigation\n  - Issue count shown in status bar\n  - Selected issue highlighting\n  - Empty state handling when no issues are synced\n\n- **Files changed:**\n  - `internal/tui/model.go` - TUI model with bubbletea tea.Model implementation\n  - `internal/tui/model_test.go` - Comprehensive tests for TUI navigation and rendering\n  - `internal/config/config.go` - Added DisplayConfig struct, DefaultDisplayColumns(), ValidateDisplayColumn()\n  - `internal/config/config_test.go` - Tests for display column configuration\n  - `internal/cmd/root.go` - Integrated TUI startup, added SetDisableTUI() for testing\n  - `internal/cmd/root_test.go` - Updated tests to use SetDisableTUI(true)\n  - `go.mod`, `go.sum` - Added bubbletea and lipgloss as direct dependencies\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `tea.WithAltScreen()` for full-screen TUI that restores terminal on exit\n    - Test TUI models by calling Update() with tea.KeyMsg directly - no TTY needed\n    - Use `SetDisableTUI(true)` pattern to skip TUI in tests (similar to other mock patterns)\n    - Bubbletea Model.View() can be tested by setting window size and checking output strings\n  - **Gotchas encountered:**\n    - `tea.NewProgram().Run()` requires a TTY - tests fail with \"could not open a new TTY\"\n    - Add package-level `disableTUI` variable with setter for testing to bypass TUI in tests\n    - Remember to defer `SetDisableTUI(false)` to reset state after tests\n\n---\n\n## 2026-01-21 - US-006 Issue Sorting\n- **What was implemented:**\n  - Sorting functionality for the issue list view\n  - Default sort: most recently updated first (updated date, descending)\n  - Four sort options: updated date, created date, issue number, comment count\n  - Keybindings: 's' cycles sort fields, 'S' (shift+s) toggles sort order\n  - Status bar shows current sort field and direction with ↑/↓ indicators\n  - Sort preference persisted to config file when changed\n\n- **Files changed:**\n  - `internal/config/config.go` - Added SortField, SortOrder types, validation functions, and DisplayConfig fields\n  - `internal/config/config_test.go` - Tests for sort configuration\n  - `internal/tui/model.go` - Added sorting logic, keybindings, status bar display, NewModelWithSort()\n  - `internal/tui/model_test.go` - Comprehensive tests for all sort options and keybindings\n  - `internal/cmd/root.go` - Load sort prefs from config, save when changed\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `NewModelWithSort()` constructor variant to allow passing initial sort config from outside\n    - Copy slice before sorting with `copy()` to avoid modifying original data\n    - Use `sort.Slice()` with a comparison function that checks `sortOrder` to flip direction\n    - Track state changes with a `sortChanged` bool to avoid unnecessary config saves\n    - Return final model from `p.Run()` to extract state after TUI exits\n  - **Gotchas encountered:**\n    - When adding default sorting, existing tests that assumed original order will fail - must update to expect sorted order\n    - Use `github.Issue.UpdatedAtTime()` / `CreatedAtTime()` helper methods to parse RFC3339 dates for comparison\n    - Cursor should reset to 0 when sort changes to avoid confusing UX\n\n---\n\n## 2026-01-21 - US-007 Issue Detail View\n- **What was implemented:**\n  - Split-panel TUI layout with issue list on left and detail panel on right\n  - Detail panel header shows: issue number, title, author, created/updated dates\n  - Body rendered with glamour (charmbracelet markdown renderer)\n  - Toggle between raw markdown and rendered view with 'm' key\n  - Labels and assignees displayed when present\n  - Scrollable detail panel with 'h' (up) and 'l' (down) keys\n  - Enter key opens comments view (state tracking added)\n  - Escape key exits comments view\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added detail panel rendering, new state fields, key handlers\n  - `internal/tui/model_test.go` - Added comprehensive tests for detail view functionality\n  - `go.mod`, `go.sum` - Added glamour dependency\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use `glamour.NewTermRenderer()` with `WithAutoStyle()` and `WithWordWrap()` for terminal-aware markdown rendering\n    - Use `lipgloss.Width()` to get visual width of strings with ANSI codes for proper padding\n    - Store glamour renderer in Model struct to avoid recreating it on each render\n    - Reset detail scroll offset when changing selected issue for better UX\n  - **Gotchas encountered:**\n    - When refactoring View() to use split panels, old column-based rendering methods become unused - clean them up\n    - Glamour renderer width is set at creation time, not per-render - pass width to `WithWordWrap()` at initialization\n    - Use `strings.TrimSpace()` on glamour output to remove trailing newlines\n\n---\n## ✓ Iteration 7 - US-007: Issue Detail View\n*2026-01-21T23:02:27.476Z (302s)*\n\n**Status:** Completed\n\n**Notes:**\ney toggles `rawMarkdown` boolean and `renderBody()` renders accordingly\\n- [x] **Labels and assignees displayed if present** - The detail panel conditionally shows labels and assignees when present\\n- [x] **Scrollable if content exceeds panel height** - The 'h' and 'l' keys scroll the detail panel, with `detailScrollY` tracking offset\\n- [x] **Enter on issue list opens dedicated comments view** - Enter key sets `inCommentsView = true`, Escape returns\\n\\nAll acceptance criteria are satisfied.\\n\\n\n\n---\n\n## 2026-01-21 - US-008 Comments View\n- **What was implemented:**\n  - Full-screen comments drill-down view that replaces the main interface\n  - Issue title/number displayed as header in comments view\n  - Comments displayed chronologically with author and date for each comment\n  - Comment body with markdown rendering (reuses existing glamour renderer)\n  - Toggle markdown rendering with 'm' key (shares state with detail panel)\n  - Scrollable comment list with 'h' (scroll up) and 'l' (scroll down) keys\n  - Esc or 'q' returns to issue list view\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added comments field, commentsScrollY, SetComments/GetComments/CommentsScrollOffset methods, renderCommentsView() function, updated View() and Update() to handle comments view\n  - `internal/tui/model_test.go` - Added 15 new tests for comments view functionality\n  - `go.mod`, `go.sum` - Updated dependencies (go mod tidy)\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Drill-down views can be implemented by checking state flag early in View() and returning different render function\n    - Share state like `rawMarkdown` between views for consistent UX across detail panel and comments view\n    - Use separate scroll offsets (`detailScrollY`, `commentsScrollY`) for independent scrolling contexts\n    - When a key should behave differently based on context (like 'q' returning from comments vs quitting app), check state in Update() before processing\n  - **Gotchas encountered:**\n    - Go time format strings use specific reference date (2006-01-02 15:04:05) - using \"2024-01-02\" instead causes wrong date parsing\n    - Need to reset scroll offset when entering comments view (`commentsScrollY = 0`) and when exiting\n    - Disable navigation keys (j/k) when in comments view to prevent cursor changes while viewing comments\n\n---\n## ✓ Iteration 8 - US-008: Comments View\n*2026-01-21T23:07:06.878Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nodies are rendered with glamour markdown\\n- **Markdown toggle** - Press 'm' to toggle between raw and rendered markdown\\n- **Scrollable list** - 'h' scrolls up, 'l' scrolls down through comments\\n- **Navigation back** - Esc or 'q' returns to the issue list view\\n\\n**Files changed:**\\n- `internal/tui/model.go` - Added comments state, scroll offset, rendering methods\\n- `internal/tui/model_test.go` - Added 15 comprehensive tests for comments view\\n- `go.mod`, `go.sum` - Updated via go mod tidy\\n\\n\n\n---\n\n## 2026-01-21 - US-009 Data Refresh\n- **What was implemented:**\n  - Manual refresh with 'r' or 'R' keybinding in TUI\n  - Auto-refresh triggered on app launch via RefreshStartMsg sent after program starts\n  - Progress indicator shown in status bar during refresh (\"Refreshing...\" or \"Refreshing issues: X/Y\")\n  - Sync now removes closed/deleted issues from local database\n  - Database methods GetAllIssueNumbers() and DeleteIssues() for tracking and removing closed issues\n  - Cursor position maintained after refresh when possible (by remembering selected issue number)\n  - Refresh disabled during comments view for better UX\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added refresh state (isRefreshing, refreshProgress, refreshError, refreshFunc), message types (RefreshProgressMsg, RefreshDoneMsg, RefreshErrorMsg, RefreshStartMsg), keybindings for 'r'/'R', status bar updates during refresh\n  - `internal/tui/model_test.go` - Added 11 tests for refresh functionality\n  - `internal/sync/sync.go` - Added logic to detect and remove closed/deleted issues\n  - `internal/sync/sync_test.go` - Added 5 tests for incremental sync and deleted issue handling\n  - `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\n  - `internal/cmd/root.go` - Integrated refresh with TUI via createRefreshFunc(), auto-refresh on launch\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Bubbletea refresh pattern: Model stores refreshFunc (func() tea.Msg), keybinding triggers state change + returns refreshFunc as command\n    - Use message types (RefreshDoneMsg, RefreshErrorMsg) to communicate async operation results back to model\n    - Auto-refresh on launch: Start TUI first, then use goroutine to send RefreshStartMsg via p.Send()\n    - Track existing issue numbers before sync, compare with fetched issues, delete the difference\n    - Preserve cursor position across refresh by remembering selected issue number, then finding its new index after sort\n  - **Gotchas encountered:**\n    - refreshFunc must be set before TUI starts - can't access external dependencies from within tea.Cmd directly\n    - Need SetRefreshFunc() method to allow injection of the refresh closure from root command\n    - When checking if key was pressed, test for cmd != nil only if refreshFunc is set (tests need to set mock function)\n    - p.Send() must be called after p.Run() starts - use goroutine to avoid race\n\n---\n## ✓ Iteration 9 - US-009: Data Refresh\n*2026-01-21T23:14:29.638Z (442s)*\n\n**Status:** Completed\n\n**Notes:**\nured.\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Added refresh state, message types, and keybindings\\n- `internal/tui/model_test.go` - Added 11 tests for refresh functionality\\n- `internal/sync/sync.go` - Added closed issue detection and removal logic\\n- `internal/sync/sync_test.go` - Added 5 tests for deleted issue handling\\n- `internal/db/store.go` - Added GetAllIssueNumbers() and DeleteIssues() methods\\n- `internal/cmd/root.go` - Integrated refresh with TUI, auto-refresh on launch\\n\\n\n\n---\n\n## 2026-01-21 - US-013 Error Handling\n- **What was implemented:**\n  - Two-tier error display system: minor errors in status bar, critical errors as modal\n  - Minor errors (network timeout, rate limit) shown in red text in status bar with retry hint\n  - Critical errors (invalid token, database corruption) shown as centered modal dialog\n  - Modal requires acknowledgment (Enter, Escape, or 'q') before user can continue\n  - Navigation and refresh blocked while error modal is shown\n  - Actionable guidance displayed in modal when provided\n  - CriticalErrorMsg message type for triggering modal errors from anywhere\n\n- **Files changed:**\n  - `internal/tui/model.go` - Added CriticalErrorMsg type, error modal state fields, renderErrorModal(), wrapText(), modal key handling in Update(), error display in status bar\n  - `internal/tui/model_test.go` - Added 12 tests for error handling: minor errors in status bar, critical errors as modal, modal acknowledgment, navigation blocking\n\n- **Learnings:**\n  - **Patterns discovered:**\n    - Use separate message types for minor vs critical errors (RefreshErrorMsg for minor, CriticalErrorMsg for modal)\n    - Handle modal keys first in Update() before normal key handling to block actions while modal is shown\n    - Use early return pattern `if m.showErrorModal { return m.renderErrorModal() }` at start of View() for modal overlay\n    - Text wrapping helper function `wrapText()` useful for fitting content into modal width\n    - Modal state requires multiple fields: showErrorModal (bool), errorModalTitle, errorModalMessage, errorModalGuidance\n  - **Gotchas encountered:**\n    - When blocking keys during modal, still allow Ctrl+C for emergency exit\n    - 'q' should dismiss modal, not quit app (unlike normal behavior)\n    - Modal centering calculation needs bounds checking for small terminal sizes\n    - Error message in status bar should be truncated to fit terminal width\n\n---\n## ✓ Iteration 10 - US-013: Error Handling\n*2026-01-21T23:19:08.265Z (278s)*\n\n**Status:** Completed\n\n**Notes:**\nasErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n\n\n---\n","structuredPatch":[{"oldStart":411,"oldLines":3,"newStart":411,"newLines":29,"lines":[" asErrorModal()`, `GetErrorModalTitle()`, `GetErrorModalMessage()`, `GetErrorModalGuidance()` - State accessors\\n   - `renderErrorModal()` - Renders the centered modal dialog\\n   - `wrapText()` - Helper for text wrapping in modal\\n\\n4. **Tests Added:** 12 new tests covering all acceptance criteria\\n\\n### Files Changed:\\n- `internal/tui/model.go` - Core error handling implementation\\n- `internal/tui/model_test.go` - Comprehensive test coverage\\n- `.ralph-tui/progress.md` - Documented learnings\\n\\n"," "," ---","+","+## 2026-01-21 - US-010 Last Synced Indicator","+- **What was implemented:**","+  - Status bar now shows \"Last synced: <relative time>\" (e.g., \"5m ago\", \"2h ago\", \"3d ago\", or \"never\")","+  - Relative time formatting function `formatRelativeTime()` that handles seconds, minutes, hours, and days","+  - Last sync time loaded from database on TUI startup","+  - Last sync time updated when RefreshDoneMsg is received after successful sync","+  - RefreshDoneMsg now includes LastSyncTime field","+","+- **Files changed:**","+  - `internal/tui/model.go` - Added lastSyncTime field, SetLastSyncTime/GetLastSyncTime methods, formatRelativeTime function, updated RefreshDoneMsg struct, updated View() status bar","+  - `internal/tui/model_test.go` - Added 12 tests for last sync time display and relative time formatting","+  - `internal/cmd/root.go` - Load last sync time from database on startup, pass to model, include in RefreshDoneMsg after sync","+","+- **Learnings:**","+  - **Patterns discovered:**","+    - Relative time formatting is a common UI pattern - keep it simple with buckets (<1m, Nm, Nh, Nd)","+    - Zero time value (`time.Time{}`) can represent \"never synced\" state naturally","+    - The database metadata table pattern (key-value store) is already used for last_sync timestamp - no schema changes needed","+    - Message types in Bubbletea can be extended with additional fields (RefreshDoneMsg.LastSyncTime) without breaking existing code","+  - **Gotchas encountered:**","+    - When adding a field to a message type (RefreshDoneMsg), need to update all places that create that message","+    - Status bar gets crowded quickly - simplified it to focus on key info (last synced, issue count, sort, refresh, quit)","+    - Use `time.Since()` for duration calculation - simpler than manual subtraction","+","+---"]}],"userModified":false,"replaceAll":false}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_01QML3eQqxGsx5zGnp7iT7kN","type":"message","role":"assistant","content":[{"type":"tool_use","id":"toolu_01QAnaNPxmrkznTNALNdBwGX","name":"TodoWrite","input":{"todos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"completed","activeForm":"Committing changes"},{"content":"Update progress.md with learnings","status":"completed","activeForm":"Updating progress documentation"}]}}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":1067,"cache_read_input_tokens":99120,"cache_creation":{"ephemeral_5m_input_tokens":1067,"ephemeral_1h_input_tokens":0},"output_tokens":25,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"9ec0f395-ce5b-4643-991f-86f9770313ba"}
{"type":"user","message":{"role":"user","content":[{"tool_use_id":"toolu_01QAnaNPxmrkznTNALNdBwGX","type":"tool_result","content":"Todos have been modified successfully. Ensure that you continue to use the todo list to track your progress. Please proceed with the current tasks if applicable"}]},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"4659ffbd-c432-4aa0-a931-9e426954ba41","tool_use_result":{"oldTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"completed","activeForm":"Committing changes"},{"content":"Update progress.md with learnings","status":"in_progress","activeForm":"Updating progress documentation"}],"newTodos":[{"content":"Write tests for last sync time display in TUI","status":"completed","activeForm":"Writing tests for last sync time display"},{"content":"Add lastSyncTime field to TUI Model and pass from root command","status":"completed","activeForm":"Adding lastSyncTime field to TUI Model"},{"content":"Implement relative time formatting function","status":"completed","activeForm":"Implementing relative time formatting"},{"content":"Update status bar to show Last synced indicator","status":"completed","activeForm":"Updating status bar"},{"content":"Update lastSyncTime on RefreshDoneMsg","status":"completed","activeForm":"Updating lastSyncTime on refresh"},{"content":"Update root.go to load and pass lastSyncTime","status":"completed","activeForm":"Updating root.go for last sync time"},{"content":"Run all tests and lint checks","status":"completed","activeForm":"Running tests and lint checks"},{"content":"Commit with feat: US-010","status":"completed","activeForm":"Committing changes"},{"content":"Update progress.md with learnings","status":"completed","activeForm":"Updating progress documentation"}]}}
{"type":"assistant","message":{"model":"claude-opus-4-5-20251101","id":"msg_012sU2C8tjBrk6jvAhMvnPjS","type":"message","role":"assistant","content":[{"type":"text","text":"Let me verify the acceptance criteria are met:\n\n**Acceptance Criteria for US-010:**\n- [x] **Status bar shows Last synced: <relative time> (e.g., 5 minutes ago)** - Implemented in `View()` method, showing \"Last synced: <time>\" with relative time formatting (e.g., \"5m ago\", \"2h ago\", \"3d ago\", \"never\")\n- [x] **Timestamp stored in database metadata table** - Already existed in `db/store.go` with `GetLastSyncTime()` and `SetLastSyncTime()` methods, using the metadata table\n- [x] **Updates after each successful sync** - `RefreshDoneMsg` now includes `LastSyncTime` field, and the model updates `lastSyncTime` when receiving this message\n\nAll tests pass and the implementation is complete.\n\n<promise>COMPLETE</promise>"}],"stop_reason":null,"stop_sequence":null,"usage":{"input_tokens":1,"cache_creation_input_tokens":396,"cache_read_input_tokens":100187,"cache_creation":{"ephemeral_5m_input_tokens":396,"ephemeral_1h_input_tokens":0},"output_tokens":1,"service_tier":"standard"},"context_management":null},"parent_tool_use_id":null,"session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","uuid":"868ee897-ee54-42eb-a463-3aff89e2ae13"}
{"type":"result","subtype":"success","is_error":false,"duration_ms":238162,"duration_api_ms":244306,"num_turns":40,"result":"Let me verify the acceptance criteria are met:\n\n**Acceptance Criteria for US-010:**\n- [x] **Status bar shows Last synced: <relative time> (e.g., 5 minutes ago)** - Implemented in `View()` method, showing \"Last synced: <time>\" with relative time formatting (e.g., \"5m ago\", \"2h ago\", \"3d ago\", \"never\")\n- [x] **Timestamp stored in database metadata table** - Already existed in `db/store.go` with `GetLastSyncTime()` and `SetLastSyncTime()` methods, using the metadata table\n- [x] **Updates after each successful sync** - `RefreshDoneMsg` now includes `LastSyncTime` field, and the model updates `lastSyncTime` when receiving this message\n\nAll tests pass and the implementation is complete.\n\n<promise>COMPLETE</promise>","session_id":"ade9f8f5-3daf-4bc1-97bc-01f3b6b5c318","total_cost_usd":2.4125895000000006,"usage":{"input_tokens":39,"cache_creation_input_tokens":82960,"cache_read_input_tokens":3050451,"output_tokens":13734,"server_tool_use":{"web_search_requests":0,"web_fetch_requests":0},"service_tier":"standard","cache_creation":{"ephemeral_1h_input_tokens":0,"ephemeral_5m_input_tokens":82960}},"modelUsage":{"claude-opus-4-5-20251101":{"inputTokens":39,"outputTokens":13734,"cacheReadInputTokens":3050451,"cacheCreationInputTokens":82960,"webSearchRequests":0,"costUSD":2.3872705,"contextWindow":200000,"maxOutputTokens":64000},"claude-haiku-4-5-20251001":{"inputTokens":22679,"outputTokens":528,"cacheReadInputTokens":0,"cacheCreationInputTokens":0,"webSearchRequests":0,"costUSD":0.025319,"contextWindow":200000,"maxOutputTokens":64000}},"permission_denials":[],"uuid":"b65e1257-8911-4b76-a437-0f4fd5ea988d"}
